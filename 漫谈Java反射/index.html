<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<!--

  <script src="//code.tidio.co/oixl41gwhy8tvqy6jte9uvglyrqcjrvc.js" async></script>

-->

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fynch3r.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>
  <meta name="description" content="序言  看试手，补天裂。  今天来总结一下Java反射，在它面前，任何事物没有任何隐私。">
<meta property="og:type" content="article">
<meta property="og:title" content="漫谈Java反射">
<meta property="og:url" content="https://fynch3r.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/index.html">
<meta property="og:site_name" content="fynch3r的小窝">
<meta property="og:description" content="序言  看试手，补天裂。  今天来总结一下Java反射，在它面前，任何事物没有任何隐私。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411205831842.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411221213662.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411224713717.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200412135058766.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200412135158822.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512223546220.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512225432055.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512231233941.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232314719.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232520503.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232900943.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232631973.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512233149513.png">
<meta property="og:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512233242268.png">
<meta property="article:published_time" content="2020-04-11T08:18:04.000Z">
<meta property="article:modified_time" content="2022-01-27T04:19:51.232Z">
<meta property="article:author" content="fynch3r">
<meta property="article:tag" content="Java反射">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fynch3r.github.io/images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411205831842.png">

<link rel="canonical" href="https://fynch3r.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>漫谈Java反射 | fynch3r的小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="fynch3r的小窝" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
<a href="https://github.com/fynch3r" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#FFA500; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fynch3r的小窝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Trust the process.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">57</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fynch3r.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yfy.png">
      <meta itemprop="name" content="fynch3r">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fynch3r的小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          漫谈Java反射
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-11 16:18:04" itemprop="dateCreated datePublished" datetime="2020-04-11T16:18:04+08:00">2020-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-27 12:19:51" itemprop="dateModified" datetime="2022-01-27T12:19:51+08:00">2022-01-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/" class="post-meta-item leancloud_visitors" data-flag-title="漫谈Java反射" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
              <span>°C</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p> 看试手，补天裂。</p>
</blockquote>
<p>今天来总结一下Java反射，在它面前，任何事物没有任何隐私。</p>
<a id="more"></a>

<h1 id="什么是Java反射？"><a href="#什么是Java反射？" class="headerlink" title="什么是Java反射？"></a>什么是Java反射？</h1><blockquote>
<p>将类的各个组成部分封装为其他对象，这就是反射机制。</p>
</blockquote>
<p>Java中的反射机制是指<strong>在运行状态中</strong>，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p>
<p><strong><em>让Java可以在运行时，根据传入的类名字符串，去执行这个类存在的方法。</em></strong></p>
<p>举个例子，Java代码在计算机中经历的三个阶段：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411205831842.png" alt="image-20200411205831842"></p>
<ul>
<li><p>source源代码阶段：此时刚刚编译为字节码，仍然保存在硬盘上。</p>
</li>
<li><p>Class类对象阶段：类加载器把Person.class字节码加载进内存。</p>
<p>对于java来说，万物皆对象，那么这时内存里会有一个Person这个类的类对象，也就是<strong>Class类对象</strong>，这个东西就很抽象。</p>
<blockquote>
<p>在Java里面有个类叫做<strong>Class</strong>，它是来描述<strong><em>所有字节码物理文件的一些共同特征和行为</em></strong>。例如成员变量，构造方法，普通的成员方法。</p>
<p>Class类对象会对重点内容进行封装成成员变量：</p>
<p>成员变量 ——-&gt; Field对象，Field[] fields</p>
<p>构造方法 ——-&gt; Constructor对象，Constructor[] cons</p>
<p>成员方法 ——-&gt; Method对象，Method[] methods</p>
</blockquote>
</li>
<li><p>运行时阶段：这个时候类对象已经实例化成为了一个对象</p>
</li>
</ul>
<p>好处：</p>
<ol>
<li>可以在程序<strong>运行过程中</strong>，操作对象。例如：获取，设置</li>
<li>可以降低程序耦合性，提高程序的扩展性</li>
</ol>
<h2 id="如何获取Class类对象？"><a href="#如何获取Class类对象？" class="headerlink" title="如何获取Class类对象？"></a>如何获取Class类对象？</h2><h3 id="字节码文件阶段"><a href="#字节码文件阶段" class="headerlink" title="字节码文件阶段"></a>字节码文件阶段</h3><blockquote>
<p>Class.forname(“全类名”)//包名.类名</p>
</blockquote>
<p>将字节码文件加载进内存 返回Class类对象</p>
<h3 id="内存阶段"><a href="#内存阶段" class="headerlink" title="内存阶段"></a>内存阶段</h3><blockquote>
<p>类名.class</p>
</blockquote>
<p>当class字节码加载进内存，那么这个Class类对象就有一个<strong>类名</strong>属性，可以用来索引</p>
<h3 id="运行时阶段"><a href="#运行时阶段" class="headerlink" title="运行时阶段"></a>运行时阶段</h3><blockquote>
<p>对象.getClass()</p>
</blockquote>
<p>所有对象的父类都是Object类，这个类有自己的getClass方法，所有对象都可以拿来用</p>
<h3 id="注意⚠️"><a href="#注意⚠️" class="headerlink" title="注意⚠️"></a>注意⚠️</h3><p>类名.class 最安全 性能最好</p>
<p>Class.forName() 属于动态加载类。将字节码文件加载进内存，参数需要类的全限定名</p>
<p>使用类名.class来创建Class对象的引用时，不会自动初始化该Class对象</p>
<p>使用Class.forName()会自动初始化该Class对象</p>
<p>Class.forName() 方法 当类加载进了内存，只有<strong>静态初始块</strong>得到了执行。</p>
<p>getDeclaredxxx 不能获取父类的方法</p>
<h2 id="实例demo"><a href="#实例demo" class="headerlink" title="实例demo"></a>实例demo</h2><h3 id="字节码阶段"><a href="#字节码阶段" class="headerlink" title="字节码阶段"></a>字节码阶段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class.forName("全类名")</span></span><br><span class="line">Class cls1 = Class.forName(<span class="string">"domain.Person"</span>);</span><br><span class="line">System.out.println(cls1);</span><br></pre></td></tr></table></figure>

<h3 id="内存阶段-1"><a href="#内存阶段-1" class="headerlink" title="内存阶段"></a>内存阶段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类名.class属性</span></span><br><span class="line">Class cls2 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">System.out.println(cls2);</span><br></pre></td></tr></table></figure>

<h3 id="运行时阶段-1"><a href="#运行时阶段-1" class="headerlink" title="运行时阶段"></a>运行时阶段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象.getClass()方法</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class cls3 = p.getClass();</span><br><span class="line">System.out.println(cls3);</span><br></pre></td></tr></table></figure>

<h3 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用==去比较三个class类对象，==比较的是对象的内存地址，如果内存地址相同，那么就是同一个对象</span></span><br><span class="line">System.out.println(cls1 == cls2);<span class="comment">//true</span></span><br><span class="line">System.out.println(cls1 == cls3);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//结论：同一个字节码文件（xx.class）在一次程序运行的过程中，只会被加载一次</span></span><br><span class="line"><span class="comment">//不论是哪种方式获取的Class类对象，都是同一个。</span></span><br></pre></td></tr></table></figure>

<h1 id="实例对照"><a href="#实例对照" class="headerlink" title="实例对照"></a>实例对照</h1><p>下面看一个demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  	<span class="comment">//public String a;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat..."</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取Fields"><a href="#获取Fields" class="headerlink" title="获取Fields"></a>获取Fields</h2><blockquote>
<p> 获取成员变量们：</p>
<ul>
<li>Fields[] getFields()：只能获取所有public修饰的成员变量</li>
<li>Fields    getField(String name)：获取特定成员变量</li>
<li>Fields[] getDeclaredFields()：获取所有的成员变量，【不考虑】修饰符，不考虑继承</li>
<li>Fields    getDeclaredField(String name)：获取特定的成员变量，【不考虑】修饰符，不考虑继承</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//Fields[] getFields()：只会获取全部的【public修饰】的成员变量</span></span><br><span class="line">Field[] fields = personClass.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="comment">//由于都是private，什么都不输出</span></span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里新增测试字段 public a</span></span><br><span class="line"><span class="comment">//public String a;</span></span><br><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field a = personClass.getField(<span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//获取成员变量a的值</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Object value = a.get(p);</span><br><span class="line">System.out.println(value);<span class="comment">//null</span></span><br><span class="line"><span class="comment">//设置a的值</span></span><br><span class="line">a.set(p,<span class="string">"张三"</span>)；</span><br><span class="line">System.out.println(p);<span class="comment">//Person&#123;name='null',age=0,a='张三'&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里新增测试字段private d</span></span><br><span class="line"><span class="comment">//private String d</span></span><br><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line"><span class="comment">// 获取所有的成员变量，不考虑修饰符，这个方法超级暴力</span></span><br><span class="line"><span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">    <span class="comment">//由于都是private，什么都不输出</span></span><br><span class="line">    System.out.println(declaredField);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Field d = personClass.getDeclaredField(<span class="string">"d"</span>);</span><br><span class="line"><span class="comment">//当访问private时，忽略访问权限符的安全检查</span></span><br><span class="line"><span class="comment">//暴力反射</span></span><br><span class="line">d.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object value= d.get(p);</span><br><span class="line">System.out.println(value);<span class="comment">//null,因为初始化，还没有设置值</span></span><br></pre></td></tr></table></figure>

<h2 id="获取Constructor"><a href="#获取Constructor" class="headerlink" title="获取Constructor"></a>获取Constructor</h2><blockquote>
<p>获取构造方法们：</p>
<p>Constructor[] getConstructors()</p>
<p>Constructor getConstructor(类 &lt;?&gt; … parameterTypes)</p>
<p>Constructor getDeclaredConstructors()</p>
<p>Constructor getDeclaredConstructor(类 &lt;?&gt; … parameterTypes)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = personClass.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;<span class="comment">//每一个构造方法的参数种类不一样，这一步是获取构造方法</span></span><br><span class="line">System.out.println(constructor);</span><br><span class="line"><span class="comment">//所以可以执行构造函数，进而创建对象，[构造器.newInstance]</span></span><br><span class="line">Object person = constructor.newInstance(<span class="string">"张三"</span>, <span class="number">23</span>);<span class="comment">//传递对应的参数值</span></span><br><span class="line">System.out.println(person);<span class="comment">//Person&#123;name=‘张三‘，age=’23‘&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//对于无参的构造方法，可以直接使用Class类对象的newInstance方法</span></span><br><span class="line">Object o = personClass.newInstance();</span><br><span class="line">System.out.println(o);</span><br></pre></td></tr></table></figure>

<h2 id="获取Methods"><a href="#获取Methods" class="headerlink" title="获取Methods"></a>获取Methods</h2><blockquote>
<p>获取成员方法们：</p>
<p>Method[]  getMethods()//获取所有【public】修饰的方法，父类Object的方法也能看到</p>
<p>Method getMethod(String name，类 &lt;?&gt; … parameterTypes)</p>
<p>Method[] getDeclaredMethods()//获取所有声明方法 不考虑修饰符 不考虑继承的方法</p>
<p>Method getDeclaredMethod(String name，类 &lt;?&gt; … parameterTypes) 不考虑修饰符 不考虑继承的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//获取制定名称的方法</span></span><br><span class="line">Method eat_Method = personClass.getMethod(<span class="string">"eat"</span>);</span><br><span class="line"><span class="comment">//进而执行方法,【invoke】，它需要一个真实的对象，以及方法的实际参数列表</span></span><br><span class="line">Person pp = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//因为是空参方法，所以直接放进来一个对象就行</span></span><br><span class="line"><span class="comment">//执行方法，eat...</span></span><br><span class="line">eat_Method.invoke(pp);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Method eat_Method2 = personClass.getMethod(<span class="string">"eat"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//eat方法重载，eat方法的需要传入的参数是String类型</span></span><br><span class="line">eat_Method2.invoke(pp,<span class="string">"jiaozi"</span>);<span class="comment">//吃饺子</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Method[] methods = personClass.getMethods();<span class="comment">//获取所有public方法名</span></span><br><span class="line"><span class="comment">//获取类名</span></span><br><span class="line">String className = personClass.getName;<span class="comment">//获取类名</span></span><br><span class="line">System.out.println(className);<span class="comment">//包名.类名</span></span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    <span class="comment">//也支持暴力反射：method.setAccessible(true);</span></span><br><span class="line">    System.out.println(method);</span><br><span class="line">    <span class="comment">//获取所有方法名</span></span><br><span class="line">    String methodname = method.getName();</span><br><span class="line">    System.out.println(methodname);</span><br></pre></td></tr></table></figure>

<h1 id="灵魂体现"><a href="#灵魂体现" class="headerlink" title="灵魂体现"></a>灵魂体现</h1><p>这里引入一个实际利用中的小demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(className);    </span><br><span class="line">    clazz.getMethod(methodName).invoke(clazz.newInstance()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分步解读：</p>
<ol>
<li>首先两个参数：<code>className</code>、<code>methodName</code>分别代表了传入的类名和方法名。</li>
<li>首先<code>Class clazz = Class.forName(className);</code>这里的意思是在字节码层面，先获取你的Class类对象<code>clazz</code>。</li>
<li>接下来<code>clazz.getMethod(methodName).invoke(clazz.newInstance());</code>这里的含义可以分步解读：<ol>
<li><code>clazz.getMethod(methodName)</code>这里我先根据传进来的方法名<code>methodName</code>获取你的Method对象;</li>
<li>接下来<code>.invoke(clazz.newInstance())</code>这个含义是对于我获取的method方法对象，我要执行这个方法，那么问题来了，我如何才能执行这个方法呢？？？</li>
<li>这里我先<code>clazz.newInstance()</code>，这一手的含义是我要先生成一个指定类的对象，那么如何生成呢？之前我已经获取了Class类对象，那么就可以用这个类对象来生成这个类的实例化对象</li>
<li><code>clazz.newInstance()</code>这样就可以生成一个实例化对象了</li>
<li>那么有了类的实例化对象之后，直接放入invoke参数里面，就可以凭借我们之前的Method对象来执行这个特殊的<code>className</code>方法了!</li>
</ol>
</li>
</ol>
<p>说了这么多嗷，我分步拆开来写一下，会更清晰一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  		<span class="comment">//首先找到类对象</span></span><br><span class="line">  		Class clazz = Class.forName(className);</span><br><span class="line">  		<span class="comment">//根据类对象找到Method方法对象</span></span><br><span class="line">      Method mtd = clazz.getMethod(methodName);</span><br><span class="line">  		<span class="comment">//动态生成类实例化对象obj</span></span><br><span class="line">      Object obj = clazz.newInstance();</span><br><span class="line">  		<span class="comment">//调用类中方法mtd</span></span><br><span class="line">      mtd.invoke(obj); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>以下一步步使用反射机制实现<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code>这个语句</p>
<ul>
<li>getRuntime()：其实就是<strong>Runtime类获取对象</strong>的方式，等于new一个Runtime类。之所以封装成一个函数是为了不调用一次建立一个对象，只获取一个对象来执行操作。</li>
<li>exec()：调用exec函数</li>
<li>calc.exe：调用计算器程序</li>
</ul>
<h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>这里我再写一个小demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainPrint</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Empty block initial %s\n"</span>, <span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态初始块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">"Static initial %s\n"</span>, TrainPrint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Initial %s\n"</span>, <span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我写一个测试类，对于这个测试类，它有初始块，静态初始块，构造函数。</p>
<p>那么下面我来获取它的Class对象，想看看当这个<code>TrainPrint</code>测试类加载进内存之后，哪些部分执行了，好主意，说写就写：</p>
<p>首先<strong>类的初始化</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> domain.TrainPrint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">initTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"domain.TrainPrint"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：<code>Static initial class domain.TrainPrint</code></p>
<p>这说明当类加载进了内存，只有<strong>静态初始块</strong>得到了执行。</p>
<p>那么<strong>类的实例化</strong>呢:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> domain.TrainPrint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">initTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        TrainPrint test= <span class="keyword">new</span> TrainPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Static initial class domain.TrainPrint</span><br><span class="line">Empty block initial class domain.TrainPrint</span><br><span class="line">Initial class domain.TrainPrint</span><br></pre></td></tr></table></figure>

<p>这也暴露了顺序：<code>静态初始块</code>-&gt;<code>初始块</code>-&gt;<code>构造函数</code></p>
<p>补充：</p>
<p>具有父类的类的实例化：<code>父类静态初始块</code>-&gt;<code>子类静态初始块</code>-&gt;<code>父类初始块</code>-&gt;<code>父类构造函数</code>-&gt;<code>子类初始块</code>-&gt;<code>子类构造函数</code></p>
<p>以上对于类初始化的说明其实就是说，单独一个Class.forName()，在<strong>类静态初始块可控的情况</strong>下，可以执行恶意代码。</p>
<h2 id="调用内部类"><a href="#调用内部类" class="headerlink" title="调用内部类"></a>调用内部类</h2><p>Java的普通类 C1 中支持编写内部类 C2 ，而在编译的时候，会生成两个文件： <code>C1.class</code> 和 <code>C1$C2.class</code>，可以把他们看作两个无关的类。</p>
<p><code>Class.forName(&quot;C1$C2&quot;)</code>可以调用这个内部类。</p>
<p>我们可以通过<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>来获取类（java.lang.Runtime是Runtime类的完整路径）</p>
<h2 id="getMethod"><a href="#getMethod" class="headerlink" title="getMethod"></a>getMethod</h2><p>Java中支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用 getMethod 的时候，我们需要传给他你需要获取的函数的参数类型列表，如下：<br><code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class)</code></p>
<h2 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h2><p>invoke方法位于Method类下，其作用是传入参数，执行方法，<br><code>public Object invoke(Object obj, Object... args)</code><br>它的第一个参数是执行method的实例化对象：</p>
<ul>
<li>如果这个方法是一个普通方法，那么第一个参数是类对象。</li>
<li>如果这个方法是一个静态方法，那么第一个参数是类（之后会提到，这里其实不用那么死板，null也行），它接下来的参数才是需要传入的参数。</li>
</ul>
<p>由于我们的exec函数是一个普通方法，需要传入类对象，即<code>invoke(类对象，exec方法传入的参数)</code> 。<br>之前说到Runtime的类对象不能通过newInstance()来获取对象（class.newInstance等于new class）,是因为Runtime的类构造函数是一个private构造函数，只能通过getRuntime方法返回一个对象。</p>
<p>获取类对象：</p>
<figure class="highlight plain"><figcaption><span>(由于getRuntime是一个静态方法，invoke传入Runtime类，进行调用)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;invoke(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))，&quot;calc.exe&quot;)&#96;</span><br><span class="line"></span><br><span class="line">合并：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class).</span><br><span class="line">                invoke(</span><br><span class="line">                        Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(</span><br><span class="line">                                Class.forName(&quot;java.lang.Runtime&quot;)),&quot;&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411221213662.png" alt="image-20200411221213662"></p>
<p>再简化一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">clazz.getMethod("exec", String.class).invoke(clazz.getMethod("getRuntime").invoke(clazz), "/Applications/Calculator.app/Contents/MacOS/Calculator");</span><br></pre></td></tr></table></figure>

<p>详细解读，这里是一个疯狂套娃的过程：</p>
<ol>
<li>首先先要找到类对象，clazz，不多说了</li>
<li>接下来我要告诉这个类对象我要执行的方法是<code>exec</code>，这个exec方法接受的参数类型是<code>String</code>类型，当然就是恶意命令字符串</li>
<li>那么我们的invoke函数需要的操作就是<code>invoke(类对象，exec方法等待接收的参数)</code>，那么问题来了：Runtime类不允许<code>newInstance()</code>来实例化对象！！！但是他允许通过<code>getRuntime</code>方法返回一个对象，那么我就用getRuntime方法来返回一个对象！</li>
<li>现在开始疯狂套娃！</li>
<li>首先既然你不允许instance，那么我就在那个类对象的位置“套”出来一个对象！思路其实就是既然我没办法给你在那个位置“放”上一个实例化对象，那么我就在你的位置上<strong>使用反射invoke执行<code>getRuntime</code>方法</strong>，不就可以了么！</li>
<li>那么就有了简化版代码！</li>
<li>这里仔细看，可以看到，其实<code>getRuntime</code>方法它也是一个无参构造方法！</li>
</ol>
<h2 id="指定的构造方法生成类的实例"><a href="#指定的构造方法生成类的实例" class="headerlink" title="指定的构造方法生成类的实例"></a>指定的构造方法生成类的实例</h2><p>继续举一个演化成反射机制的执行命令payload的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">paramList.add(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(paramList);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure>

<p>可见，其构造函数是写入了一个字符串，不是无参构造方法，接下来我们会一步步进行转化。</p>
<p>ProcessBuilder有两个构造函数：</p>
<ul>
<li><code>public ProcessBuilder(List command)</code></li>
<li><code>public ProcessBuilder(String... command)</code>(此处，String<code>...</code>这种语法表示String参数数量是可变的，与String[]一样)</li>
</ul>
<p><code>getConsturctor()</code>函数可以选定指定接口格式的构造函数(由于构造函数也可以根据参数来进行重载)，<code>getConsturctor(参数类型)</code></p>
<p>选定后我们可以通过<code>newInstance()</code>,并传入构造函数的参数执行构造函数，即<code>newInstance(传入的构造函数参数)</code>。</p>
<p>start函数不是一个静态函数,需要传入类的实例，所以这里可以继续使用反射：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">clazz.getMethod("start").invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList("/Applications/Calculator.app/Contents/MacOS/Calculator")));</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200411224713717.png" alt="image-20200411224713717"></p>
<p>这里还有一种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个可以传入多个字符串</span></span><br><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure>

<p>那么payload就这样写吧：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)).start();</span><br></pre></td></tr></table></figure>

<p>但是实际上我们这样调用是会报错的，因为newInstance函数接受参数是一个<code>Object..</code>也就是Object数组，它会完美契合我们提供的String[]，剥去一层数组。</p>
<p>那就再套一层：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[][]&#123;&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;&#125;)).start();</span><br></pre></td></tr></table></figure>

<h2 id="执行私有方法"><a href="#执行私有方法" class="headerlink" title="执行私有方法"></a>执行私有方法</h2><p>以上都是方法或构造方法是public函数，但是如果是私有方法，该如何调用？<br>之前用的都是getMethod、getConstructor，接下来需要使用getDeclaredMethod、getDeclaredConstructor：</p>
<ul>
<li>getMethod等方法获取的是当前类中所有<strong>公共</strong>方法，包括从父类继承的方法</li>
<li>getDeclared等方法获取的是<strong>当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了</strong></li>
</ul>
<p>之前说到Runtime的构造方式是一个私有方法，从而不能直接调用，那么接下来我就来调用Runtime的构造方法来获取一个实例来执行计算器弹出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">Constructor m = clazz.getDeclaredConstructor(); </span><br><span class="line">m.setAccessible(<span class="keyword">true</span>); <span class="comment">//暴力反射</span></span><br><span class="line">clazz.getMethod("exec", String.class).invoke(m.newInstance(), "/Applications/Calculator.app/Contents/MacOS/Calculator");</span><br></pre></td></tr></table></figure>

<p>在获取到私有方法后，通过<code>setAccessible(true)</code>可以打破私有方法访问限制，从而进行调用。</p>
<h1 id="从Commons-collections收获的一点反思"><a href="#从Commons-collections收获的一点反思" class="headerlink" title="从Commons-collections收获的一点反思"></a>从Commons-collections收获的一点反思</h1><p>对于正常的反射模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))</span><br></pre></td></tr></table></figure>

<p>但其实我们很容易忽略反射机制中调用的函数实际上可以在两个不同的class中调用，<strong>就像好比有一个函数可以在两个class中调用</strong>。</p>
<p>在Commons-Collections的环境中，我们是没法得到<code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(...)</code>的，但是可以得到<code>Class.forName(&quot;java.lang.Class&quot;).getMethod(...)</code>。</p>
<p>可以理解为我们可以抓到<code>Runtime</code>的父类，那么就可以得到以下途径进行变形：</p>
<ul>
<li>用反射机制去调用反射机制中使用的函数getMethod</li>
<li>使用invoke传入的obj去指定getMethod的当前的调用环境（在实际代码执行中是this变量的区别）</li>
</ul>
<p>继续看一下Class类中getMethod方法的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span><span class="comment">////&lt;?&gt;... 表示任意类型任意数量的Class数组</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">    Method method = getMethod0(name, parameterTypes, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(getName() + <span class="string">"."</span> + name + argumentTypesToString(parameterTypes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们传数组，来拿到<code>getmethod</code>这个方法不就行了么：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method1= Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">        .getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;);//根据getMethod方法接口进行封装</span><br></pre></td></tr></table></figure>

<p>以下套娃警告！</p>
<p>这里的Class类，它有所有方法，我们就是先拿到<code>getmethod</code>这个方法，这里是为什么呢？因为对于想用反射来调用方法其他类的方法，你必须会用到<code>getmethod</code>方法（忘了的向上翻模板），这里就相当于我先把梯子拿到！</p>
<p>那么有了<code>getmethod</code>方法之后，我需要一个obj对象来调用呀，这个obj其实就是<code>java.lang.Runtime</code>。之前也说了，这个对象很有脾气，需要执行这个类下面的<code>Runtime</code>方法，才能实例化一个<code>Runtime</code>对象。</p>
<p>结合上面刚刚获取的<code>getmethod</code>梯子方法，继续写吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下语句执行结果等同于Class.forName("java.lang.Runtime").getMethod(getRunime)</span></span><br><span class="line">method1.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//用于对比：以下语句等同于Class.forName("java.lang.Class").getMethod(getRunime)</span></span><br><span class="line"><span class="comment">//method1.invoke(Class.forName("java.lang.Class"),"getRuntime",new Class[0]);</span></span><br></pre></td></tr></table></figure>

<p>合起来就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.正常的反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br><span class="line"><span class="comment">// 2.经过变形的反射调用，需要绕一圈</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">    .getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;)//得到getMethod方法</span><br><span class="line">   .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);<span class="comment">//new Class[0]其实就是占位</span></span><br></pre></td></tr></table></figure>

<p><code>new Class[0]</code>其实就是占位，因为阅读源码能看到invoke方法参数规范，是硬性标准需要两个参数的，第二个是一个<code>Object</code>类的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">       InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以现在我们只是以<code>Class.forName(&quot;java.lang.Class&quot;)</code>开头获取到了Runtime类下的getRuntime方法。还没有执行。</p>
<h2 id="神奇的invoke参数"><a href="#神奇的invoke参数" class="headerlink" title="神奇的invoke参数"></a>神奇的invoke参数</h2><p>自己写完总觉得invoke参数奇奇怪怪的，淦，研究一下。</p>
<p>invoke有一个非常神奇的特性，它不会那么严格地校验obj。回顾之前总结的invoke传参规则：</p>
<blockquote>
<p>它的第一个参数是执行method的对象obj：</p>
<ul>
<li>如果这个方法是一个普通方法，那么第一个参数是类对象</li>
<li>如果这个方法是一个静态方法，那么第一个参数是类<br>它接下来的参数才是需要传入的参数。</li>
</ul>
</blockquote>
<p>但是，<strong>传入的第一个参数其实不一定要是正确的类或者类对象!</strong></p>
<p>下面一个小例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数</span></span><br><span class="line">Class.forName(<span class="string">"a"</span>).getMethod(<span class="string">"print"</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//内部类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照规则，print函数是一个<strong>静态方法</strong>，实际上我们应该invoke传入一个a的类。但是以上代码的执行结果却是成功的：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200412135058766.png" alt="image-20200412135058766"></p>
<p>但是如果<code>print</code>方法不是静态防范时就会执行失败：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20200412135158822.png" alt="image-20200412135158822"></p>
<p>这是因为invoke函数null抛出报错的机制导致的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@exception</span> NullPointerException      </span><br><span class="line">* <span class="keyword">if</span> the specified object is <span class="keyword">null</span> and the method is an instance method. <span class="comment">//obj为null，并且method是一个实例method</span></span><br><span class="line">*/</span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当method是一个普通函数时，传入obj不能为null，并且其类对象要与方法匹配；但是当method是一个静态函数时，就很随便了(可能是因为压根不会被用到吧)。</p>
<p>这里我迷茫了好久，知道我看到这样一句话才弄懂：</p>
<blockquote>
<p><strong>类实例</strong>是其他类的实例，<strong>类</strong>实际上是Class.class这个类的实例。<br>这边之前的疑问是，getMethod不是静态方法而invoke中传入的是类而不是类实例。<br>实际上因为getMethod本来就是class类中的方法，而<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>获取到的class类的实例<br>我们调用getMethod传入的不是之前的模糊类的概念，而是class类的实例（类实例），所以这里是没毛病的调用class类下的非静态方法，传入class类实例。</p>
</blockquote>
<h2 id="回来继续构造调用"><a href="#回来继续构造调用" class="headerlink" title="回来继续构造调用"></a>回来继续构造调用</h2><p>上面我们只是获取到了getRuntime方法，我们还没有调用这个方法获取其Runtime对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通调用形式</span></span><br><span class="line">Runtime.getRuntime()</span><br><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))</span><br><span class="line"><span class="comment">// 经过变形的反射调用</span></span><br><span class="line">Method method = (Method) Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">                .getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;)//得到getMethod方法，这个方法需要两个型参，这里要列好，分别是String和Class</span><br><span class="line">  .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);<span class="comment">//调用getMethod方法，得到getRuntime方法</span></span><br><span class="line"><span class="comment">//以上等于执行Class.forName("java.lang.Runtime").getMethod("getRuntime")</span></span><br><span class="line"><span class="comment">//调用Runtime.getRuntime函数，传入的obj根据上面的分析可以随便写</span></span><br><span class="line">method.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">method.invoke(<span class="keyword">null</span>,<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">method.invoke(Class.forName(<span class="string">"java.lang.String"</span>),<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>



<h1 id="搞懂invoke函数"><a href="#搞懂invoke函数" class="headerlink" title="搞懂invoke函数"></a>搞懂invoke函数</h1><p>直接上源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> <span class="keyword">extends</span> <span class="title">AccessibleObject</span> <span class="keyword">implements</span> <span class="title">GenericDeclaration</span>,<span class="title">Member</span>...</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Object</span> <span class="title">invoke</span>(<span class="title">Object</span> <span class="title">obj</span>, <span class="title">Object</span>... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">        <span class="title">throws</span> <span class="title">IllegalAccessException</span>, <span class="title">IllegalArgumentException</span>,</span></span><br><span class="line"><span class="class">           <span class="title">InvocationTargetException</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">                Class&lt;?&gt; caller = Reflection.getCallerClass(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ma = acquireMethodAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>override参数</strong></p>
<p>它是父类AccessibleObject的一个属性，AccessibleObject这个类有三个子类：构造函数、属性、方法。</p>
<img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512223546220.png" alt="image-20210512223546220" style="zoom:80%;">

<p>override这个值默认是false，但是我们可以通过method.setAccessible(true)来改掉它的值。</p>
<p><strong>Reflection.quickCheckMemberAccess(clazz, modifiers)</strong></p>
<p>如果是override是默认值false，那么继续往下走。</p>
<p>我们这里假设：<strong>m.invoke(obj,args)</strong></p>
<p>参数：</p>
<ul>
<li><p>clazz：m所属类的Class对象 </p>
</li>
<li><p>args：m的所需参数</p>
</li>
</ul>
<p>这里<strong>quickCheckMemberAccess先检查Class对象是不是public的</strong>。</p>
<ul>
<li><p>如果是public,那么就跳出本方法；</p>
</li>
<li><p>如果不是public,那继续来到Reflection.getCallerClass(1);</p>
<p>这是一个native方法，返回的是获取调用这个方法的Class对象，赋值给caller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getCallerClass();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>checkAccess</strong></p>
<p>然后通过checkAccess(checkAccess(caller, clazz, obj, modifiers)做一次快速的权限校验</p>
<img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512225432055.png" alt="image-20210512225432055" style="zoom:80%;">

<p>不难看出，还进行了一个很简单的缓冲机制，只适用于一个类的重复调用。</p>
<p><strong>MethodAccessor ma = methodAccessor;</strong></p>
<p>接下来是重头戏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line"><span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">	ma = acquireMethodAccessor();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ma.invoke(obj, args);</span><br></pre></td></tr></table></figure>

<p>首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。<br>当第一次调用一个Java方法对应的Method对象的invoke()方法之前，实现调用逻辑的MethodAccessor对象还没有创建(第一次调用，methodAccessor属性为null)，所以通过<code>reflectionFactory</code>创建MethodAccessor并更新给root，然后调用<code>MethodAccessor.invoke()</code>完成反射调用。</p>
<p>具体细看，可以看到invoke方法实际是委派给了MethodAccessor类型的ma对象来处理。MethodAccessor是一个接口，主要有两个实现类。</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512231233941.png" alt="image-20210512231233941"></p>
<p>一个委派实现(<code>DelegatingMethodAccessorImpl</code>)，一个本地实现(<code>NativeMethodAccessorImpl</code>)。这里调用的委派实现主要是为了在本地实现和动态实现之间做切换。考虑到许多反射调用仅会执行一次，Java虚拟机设置了一个阈值15(是从0开始计算,&gt;15)：</p>
<ul>
<li>当某个反射调用的调用次数&lt;=15 时，采用本地实现；</li>
<li>当大于15时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现。这个过程我们称之为Infation。</li>
</ul>
<p>这里我们以<code>NativeMethodAccessorImpl</code>本地实现为例：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232314719.png" alt="image-20210512232314719"></p>
<p>每次调用其invoke时会做一个累加，判断是否到达阙值，如果没有则调用native的invoke0方法，当超过时则调用<code>MethodAccessorGenerator.generateMethod()</code>，并将其设置到<code>DelegatingMethodAccessorImpl</code>的delegate，这样下次就会直接调用到动态实现的位置。</p>
<p>m.invoke(o，args)</p>
<p>invoke0参数：</p>
<ul>
<li>this.method 就是m</li>
<li>var1就是o，如果m是静态方法的话，这里写null也可以</li>
<li>var2就是args参数</li>
</ul>
<p>我们重点分析一下invoke0这个native方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jobject JNICALL Java_sun_reflect_NativeMethodAccessorImpl_invoke0</span><br><span class="line">(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_InvokeMethod(env, m, obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借用ruilin的图，继续看JVM_InvokeMethod方法：</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232520503.png" alt="image-20210512232520503"></p>
<p>发现提到了oop，简单写一下oop-klass理解：</p>
<p>JVM就是用这种方式，将一个对象的数据和对象模型进行分离。普遍意义上来说，我们说持有一个对象的引用，指的是图中的handle(存放在栈区)，它是oop(存放在堆区)的一个封装。</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232900943.png" alt="image-20210512232900943"></p>
<p>关键点是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);</span><br></pre></td></tr></table></figure>

<p>跟进hotspot/src/share/vm/runtime/reflection.cpp</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512232631973.png" alt="image-20210512232631973"></p>
<p>Reflection::invoke_method()中接受的method_mirror(oop)就是我们要反射调用的方法。然后代码调用了Reflection::invoke()，跟进之后最终到JavaCalls::call()执行</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512233149513.png" alt="image-20210512233149513"></p>
<p>最后的<code>os_exception_wrapper</code>其实就是调用了<code>call_help</code>，也就是说本地实现的<strong>反射最终的方法执行是通过<code>JavaCalls::call_helper</code>方法来完成的</strong>。</p>
<p><img src="../images/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/image-20210512233242268.png" alt="image-20210512233242268"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>反射，永远滴神！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%8F%8D%E5%B0%84/" rel="tag"><i class="fa fa-tag"></i>Java反射</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/" rel="prev" title="动态代理那点事">
      <i class="fa fa-chevron-left"></i> 动态代理那点事
    </a></div>
      <div class="post-nav-item">
    <a href="/JVM%E6%A2%B3%E7%90%86/" rel="next" title="JVM梳理">
      JVM梳理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
      <!--
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://link.hhtjim.com/163/26348068.mp3"></iframe>
      -->
      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#序言"><span class="nav-number">1.</span> <span class="nav-text">序言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是Java反射？"><span class="nav-number">2.</span> <span class="nav-text">什么是Java反射？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何获取Class类对象？"><span class="nav-number">2.1.</span> <span class="nav-text">如何获取Class类对象？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字节码文件阶段"><span class="nav-number">2.1.1.</span> <span class="nav-text">字节码文件阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存阶段"><span class="nav-number">2.1.2.</span> <span class="nav-text">内存阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时阶段"><span class="nav-number">2.1.3.</span> <span class="nav-text">运行时阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意⚠️"><span class="nav-number">2.1.4.</span> <span class="nav-text">注意⚠️</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例demo"><span class="nav-number">2.2.</span> <span class="nav-text">实例demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字节码阶段"><span class="nav-number">2.2.1.</span> <span class="nav-text">字节码阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存阶段-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">内存阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时阶段-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">运行时阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小细节"><span class="nav-number">2.2.4.</span> <span class="nav-text">小细节</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实例对照"><span class="nav-number">3.</span> <span class="nav-text">实例对照</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取Fields"><span class="nav-number">3.1.</span> <span class="nav-text">获取Fields</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取Constructor"><span class="nav-number">3.2.</span> <span class="nav-text">获取Constructor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取Methods"><span class="nav-number">3.3.</span> <span class="nav-text">获取Methods</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#灵魂体现"><span class="nav-number">4.</span> <span class="nav-text">灵魂体现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类的初始化"><span class="nav-number">4.1.</span> <span class="nav-text">类的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用内部类"><span class="nav-number">4.2.</span> <span class="nav-text">调用内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getMethod"><span class="nav-number">4.3.</span> <span class="nav-text">getMethod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#invoke"><span class="nav-number">4.4.</span> <span class="nav-text">invoke</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定的构造方法生成类的实例"><span class="nav-number">4.5.</span> <span class="nav-text">指定的构造方法生成类的实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行私有方法"><span class="nav-number">4.6.</span> <span class="nav-text">执行私有方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从Commons-collections收获的一点反思"><span class="nav-number">5.</span> <span class="nav-text">从Commons-collections收获的一点反思</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#神奇的invoke参数"><span class="nav-number">5.1.</span> <span class="nav-text">神奇的invoke参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回来继续构造调用"><span class="nav-number">5.2.</span> <span class="nav-text">回来继续构造调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#搞懂invoke函数"><span class="nav-number">6.</span> <span class="nav-text">搞懂invoke函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fynch3r"
      src="/images/yfy.png">
  <p class="site-author-name" itemprop="name">fynch3r</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fynch3r" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fynch3r" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.0kami.cn/" title="https:&#x2F;&#x2F;blog.0kami.cn&#x2F;" rel="noopener" target="_blank">wh1t3p1g</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://zebork.org/" title="https:&#x2F;&#x2F;zebork.org" rel="noopener" target="_blank">Zebork</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://apsarasx.com/" title="https:&#x2F;&#x2F;apsarasx.com" rel="noopener" target="_blank">ApsarasX</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.safe6.cn/index" title="http:&#x2F;&#x2F;www.safe6.cn&#x2F;index" rel="noopener" target="_blank">Safe6</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://su18.org/" title="https:&#x2F;&#x2F;su18.org" rel="noopener" target="_blank">su18</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://summersec.github.io/" title="https:&#x2F;&#x2F;summersec.github.io" rel="noopener" target="_blank">SummerSec</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/tr1ple/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;tr1ple&#x2F;" rel="noopener" target="_blank">tr1ple</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://4ra1n.love/" title="https:&#x2F;&#x2F;4ra1n.love&#x2F;" rel="noopener" target="_blank">4ra1n</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.cnpanda.net/" title="http:&#x2F;&#x2F;www.cnpanda.net&#x2F;" rel="noopener" target="_blank">panda</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://m0d9.me/" title="http:&#x2F;&#x2F;m0d9.me&#x2F;" rel="noopener" target="_blank">yangbh</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://anemone.top/" title="http:&#x2F;&#x2F;anemone.top" rel="noopener" target="_blank">Anemone95</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.kingkk.com/" title="https:&#x2F;&#x2F;www.kingkk.com&#x2F;" rel="noopener" target="_blank">kingkk</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.yuque.com/ni4n/blogs" title="https:&#x2F;&#x2F;www.yuque.com&#x2F;ni4n&#x2F;blogs" rel="noopener" target="_blank">Ni4n</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>




      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        


<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
   Powered By - 
  <span class="author" itemprop="copyrightHolder">fynch3r</span>

  <!--
    <span class="post-meta-divider"> | </span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">834k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23:10</span>
  -->

</div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.dataset.flagTitle;

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : 'Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz',
            'X-LC-Key'    : 'l8KvoMr1i8urA7X7BzPMtQC7',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz',
      appKey     : 'l8KvoMr1i8urA7X7BzPMtQC7',
      placeholder: "Say Something~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<!--

  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unjkp.com/valine/dist/Valine.min.js"></script>  
  <script src="/js/Valine.min.js"></script> 

   
  
  <script src="/js/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Xm92yiHJb6lBpsP02sgh3uGo-gzGzoHsz',
        appKey: 'l8KvoMr1i8urA7X7BzPMtQC7',
        placeholder: 'Say Something~',
        avatar:'mm',
        guest_info:['nick'] ,  //评论者只需要提供评论的昵称即可
        pageSize:'10' || 10,
    });
  
    var infoEle = document.querySelector('#comments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0){
      infoEle.childNodes.forEach(function(item) {
        item.parentNode.removeChild(item);
      });
    }
  </script>

-->

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/click_love.js"></script>
